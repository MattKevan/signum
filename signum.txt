FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: ios, node_modules, public
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html, *.json, *.hbs
================================================================================

File: types/index.ts
// src/types/index.ts

// Represents a node in the hierarchical site structure.
export interface StructureNode {
  type: 'page' | 'collection';
  title: string;
  path: string;
  slug: string;
  navOrder?: number;
  children?: StructureNode[];
  layout: string;
  itemLayout?: string;
  [key: string]: unknown;
}

// Represents the theme configuration.
export interface ThemeConfig {
  name: string;
  config: {
    [key: string]: string | boolean | number;
  };
}

export interface LayoutInfo {
  id: string;
  name: string;
  type: 'page' | 'collection';
  path: string; 
  description?: string;
}

// A similar structure for custom themes
export interface ThemeInfo {
  id: string;
  name: string;
  path: string; 
}

export interface Manifest {
  siteId: string;
  generatorVersion: string;
  title: string;
  description: string;
  author?: string;
  baseUrl?: string;
  theme: ThemeConfig;
  structure: StructureNode[];
  layouts?: LayoutInfo[];
  themes?: ThemeInfo[]; 
}

// A raw markdown file parsed from storage.
export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

// Represents a link used for rendering navigation menus.
// This is a derived type, not part of the core manifest data.
export interface NavLinkItem {
  href: string;
  label: string;
  isActive?: boolean;
  children?: NavLinkItem[];
}

// Represents the fields within a content file's frontmatter.
export interface MarkdownFrontmatter {
  title: string;
  [key: string]: unknown; 
}

export interface RawFile {
  path: string;    // e.g., "layouts/custom/my-grid/layout.json" or "themes/custom/my-theme/theme.css"
  content: string; // The raw text content of the file
}


export interface LocalSiteData {
  siteId: string;
  manifest: Manifest;
  contentFiles?: ParsedMarkdownFile[];
  layoutFiles?: RawFile[];
  themeFiles?: RawFile[];
}

// The state and actions for the Zustand store.
export interface AppState {
  sites: LocalSiteData[];
  addSite: (site: LocalSiteData) => Promise<void>;
  updateManifest: (siteId: string, manifest: Manifest) => Promise<void>;
  addNewCollection: (siteId: string, name: string, slug: string, layout: string) => Promise<void>;
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string, layoutId: string) => Promise<boolean>;
  deleteSiteAndState: (siteId:string) => Promise<void>;
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
}

================================================================================

File: contexts/EditorContext.tsx
// src/contexts/EditorContext.tsx
'use client';
import { toast } from 'sonner';

import { createContext, useContext, useState, ReactNode, useMemo, useRef, useCallback } from 'react';

export type SaveState = 'idle' | 'saving' | 'saved' | 'no_changes';

interface EditorContextType {
  setLeftSidebar: (content: ReactNode) => void;
  setRightSidebar: (content: ReactNode) => void;
  saveState: SaveState;
  setSaveState: (state: SaveState) => void;
  hasUnsavedChanges: boolean;
  setHasUnsavedChanges: (hasChanges: boolean) => void;
  triggerSave: () => Promise<void>;
  registerSaveAction: (saveFn: () => Promise<void>) => void;
}

export const EditorContext = createContext<EditorContextType | undefined>(undefined);

interface EditorProviderProps {
  children: (slots: { leftSidebar: ReactNode; rightSidebar: ReactNode }) => ReactNode;
}

export function EditorProvider({ children }: EditorProviderProps) {
  const [leftSidebarContent, setLeftSidebarContent] = useState<ReactNode>(null);
  const [rightSidebarContent, setRightSidebarContent] = useState<ReactNode>(null);
  const [saveState, setSaveState] = useState<SaveState>('no_changes');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const saveActionRef = useRef<(() => Promise<void>) | null>(null);

  const registerSaveAction = useCallback((saveFn: () => Promise<void>) => {
    saveActionRef.current = saveFn;
  }, []);
  
  const triggerSave = useCallback(async () => {
    if (saveActionRef.current) { // Allow manual save even if no changes (for "new file" mode)
      setSaveState('saving');
      try {
        await saveActionRef.current();
        setSaveState('saved');
        setHasUnsavedChanges(false);
        setTimeout(() => setSaveState('no_changes'), 2000);
      } catch (error) {
        console.error("Save failed:", error);
        toast.error((error as Error).message || "Failed to save.");
        setSaveState('idle'); 
      }
    }
  }, []);

  const contextValue = useMemo(() => ({
    setLeftSidebar: setLeftSidebarContent,
    setRightSidebar: setRightSidebarContent,
    // Determine saveState based on hasUnsavedChanges
    saveState: hasUnsavedChanges ? 'idle' : saveState,
    // --- EXPOSE THE SETTER FUNCTION ---
    setSaveState,
    hasUnsavedChanges,
    setHasUnsavedChanges,
    triggerSave,
    registerSaveAction,
  }), [saveState, hasUnsavedChanges, registerSaveAction, triggerSave]);

  return (
    <EditorContext.Provider value={contextValue}>
      {children({ leftSidebar: leftSidebarContent, rightSidebar: rightSidebarContent })}
    </EditorContext.Provider>
  );
}

export function useEditor() {
  const context = useContext(EditorContext);
  if (context === undefined) {
    throw new Error('useEditor must be used within an EditorProvider');
  }
  return context;
}

================================================================================

File: app/layout.tsx
// src/app/layout.tsx
'use client'; 

import { useEffect, useState, Suspense } from 'react';
import { useAppStore } from '@/stores/useAppStore';
import './globals.css'; 
import { Toaster } from "@/components/ui/sonner"; 
import { ThemeProvider } from "@/components/core/ThemeProvider";
import { useInitialiseUIStore } from '@/hooks/useInitialiseUIStore';

function AppLoadingIndicator() {
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading Signum...</p>
      </div>
    </div>
  ); 
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  useInitialiseUIStore();
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true); 
    // Initialize the app state from storage only once
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]); 

  // Show the loading indicator only on the client and before initialization is complete
  const showLoading = clientMounted && !isInitialized;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Signum - Decentralized Publishing</title>
      </head>
      <body className="h-full">
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
          {showLoading ? (
            <AppLoadingIndicator />
          ) : (
         
                <Suspense fallback={<AppLoadingIndicator />}>
                  {children}
                </Suspense>
              
          )}
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================================================================================

File: app/page.tsx
// src/app/page.tsx
'use client';

import { Button } from '@/components/ui/button';
import { Link } from '@/components/ui/link';
import { ShieldCheck, Feather, Zap, Archive, Leaf } from 'lucide-react';

export default function MarketingHomePage() {
  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto px-4 py-16 sm:py-24 text-center">
      <header className="mb-12">
        <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold tracking-tight text-foreground">
          Signum: Own Your Content.
        </h1>
        <p className="mt-4 max-w-2xl mx-auto text-lg sm:text-xl text-muted-foreground">
          A simple, private, and portable publishing platform that puts you back in control.
        </p>
      </header>

      <div className="mb-16">
        <Button asChild size="lg">
          <Link href="/sites">
            Open Dashboard & Get Started
          </Link>
        </Button>
      </div>

      <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 max-w-5xl mx-auto">
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <ShieldCheck className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Private & Secure</h3>
          <p className="text-muted-foreground text-sm">
            No tracking or surveillance by default. Your data is yours.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Feather className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Simple & Focused</h3>
          <p className="text-muted-foreground text-sm">
            A minimal, content-first editor lets you focus on writing.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Zap className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Blazingly Fast</h3>
          <p className="text-muted-foreground text-sm">
            Static sites are fast, reliable, and efficient to host.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Archive className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Truly Portable</h3>
          <p className="text-muted-foreground text-sm">
            Export your entire site anytime. No vendor lock-in, ever.
          </p>
        </div>
      </section>
    </div>
    </>
  );
}

================================================================================

File: app/globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: app/sites/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';

export default function SiteLoaderLayout({ children }: { children: React.ReactNode }) {
  const params = useParams();
  const siteId = params.siteId as string;

  // --- USE THE NEW ACTION ---
  const loadSiteAction = useAppStore(state => state.loadSite);
  
  useEffect(() => {
    if (siteId) {
      // This will now reliably load the manifest and content files.
      loadSiteAction(siteId);
    }
  }, [siteId, loadSiteAction]);

  return <>{children}</>;
}

================================================================================

File: app/sites/page.tsx
// src/app/page.tsx
'use client';

import Link from 'next/link';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';
import { PlusCircle, Edit3, Eye, Trash2, FilePlus2, Leaf } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { toast } from "sonner";

export default function HomePageDashboard() {
  const sites = useAppStore((state) => state.sites);
  const deleteSiteAndState = useAppStore((state) => state.deleteSiteAndState);

  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

  const validSites = sites.filter(site => site && site.manifest);

  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-8 gap-4">
        <h1 className="text-3xl font-bold text-foreground">My Signum Sites</h1>
        <Button asChild size="lg">
          <Link href="/create-site">
            <FilePlus2 className="mr-2 h-5 w-5" /> Create New Site
          </Link>
        </Button>
      </div>

      {validSites.length === 0 ? (
        <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
          <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
          <p className="text-muted-foreground mb-4">Click &quot;Create New Site&quot; to get started.</p>
          <Button asChild>
            <Link href="/create-site">
                <PlusCircle className="mr-2 h-4 w-4" /> Start Creating
            </Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {validSites.map((site) => (
            <div key={site.siteId} className="bg-card border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between">
              <div>
                <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.manifest.title}>
                  {site.manifest.title || "Untitled Site"}
                </h2>
                <p className="text-sm text-muted-foreground mb-4 line-clamp-2" title={site.manifest.description}>
                  {site.manifest.description || 'No description provided.'}
                </p>
              </div>
              <div className="mt-4 flex flex-wrap justify-start gap-2">
                <Button variant="outline" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/`} target="_blank" rel="noopener noreferrer">
                    <Eye className="mr-2 h-4 w-4" /> View
                  </Link>
                </Button>
                <Button variant="default" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/edit`}>
                     <Edit3 className="mr-2 h-4 w-4" /> Edit
                  </Link>
                </Button>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" size="sm">
                      <Trash2 className="mr-2 h-4 w-4" /> Delete
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This will permanently delete &quot;{site.manifest.title || 'this site'}&quot; from local storage.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={() => handleDeleteSite(site.siteId, site.manifest.title || 'Untitled Site')}>
                        Yes, delete site
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
    </>
  );
}

================================================================================

File: app/sites/[siteId]/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbEdit, TbSettings } from "react-icons/tb";
import { cn } from '@/lib/utils';
import Image from 'next/image';
import { ReactNode } from 'react';

/**
 * The root layout for a single site's backend.
 * This component provides the persistent vertical toolbar for navigating
 * between main sections like 'Edit' and 'Settings'.
 */
export default function SingleSiteLayout({ children }: { children: ReactNode }) {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const isEditorActive = pathname.startsWith(`/sites/${siteId}/edit`);
  const isSettingsActive = pathname.startsWith(`/sites/${siteId}/settings`);

  const navItems = [
    { href: `/sites/${siteId}/edit`, title: 'Edit', icon: TbEdit, isActive: isEditorActive },
    { href: `/sites/${siteId}/settings`, title: 'Settings', icon: TbSettings, isActive: isSettingsActive },
  ];

  return (
    <div className="flex h-screen flex-col lg:flex-row">
      <aside className="fixed inset-x-0 bottom-0 z-30 flex h-16 w-full shrink-0 border-t bg-background lg:static lg:inset-y-0 lg:left-0 lg:h-full lg:w-[60px] lg:border-r lg:border-t-0">
        <nav className="flex w-full items-center justify-center gap-4 px-2 lg:flex-col lg:justify-start lg:pb-5">
          <Link
            href="/sites"
            title="Dashboard"
            className='lg:flex hidden flex-col items-center w-[60px] h-[60px] border-b'
          >
            <Image src="/signum.svg" width={34} height={34} alt="Signum Logo" className='m-auto'/>
          </Link>
          
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              title={item.title}
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-lg transition-colors',
                item.isActive
                  ? 'bg-accent text-accent-foreground'
                  : 'text-muted-foreground hover:bg-accent/50 hover:text-foreground'
              )}
            >
              <item.icon className="size-6" />
            </Link>
          ))}
        </nav>
      </aside>

      {/* The rest of the page (which will be another layout like EditSiteLayout) renders here. */}
      <main className="flex-1 overflow-auto pb-16 lg:pb-0">
        {children}
      </main>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/page.tsx
// src/app/sites/[siteId]/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page now acts as a smart entry point for a site.
// Its only job is to redirect the user to the editor.
export default function SiteRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid polluting the browser's history.
      // This sends the user directly to the site editor.
      router.replace(`/sites/${siteId}/edit`);
    }
  }, [siteId, router]);

  // Display a loading message while the redirect is processed.
  return (
    <div className="flex justify-center items-center h-full">
      <p>Redirecting to editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/layout.tsx
// src/app/sites/[siteId]/settings/layout.tsx
'use client';

import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import SettingsNav from '@/components/publishing/SettingsNav';
import { ReactNode, useEffect } from 'react';
import { useUIStore } from '@/stores/uiStore';
/**
 * The root layout for the entire settings section.
 * It provides the consistent ThreeColumnLayout structure and injects the
 * a dedicated <SettingsNav /> component into the left sidebar.
 * The right sidebar is intentionally left empty for this section.
 */
export default function SettingsSectionLayout({ children }: { children: ReactNode }) {
  const { setLeftAvailable, setRightAvailable, setRightOpen } = useUIStore(state => state.sidebar);

  useEffect(() => {
    // When this layout mounts, configure the UI for the settings section.
    setLeftAvailable(true);   // Ensure the left sidebar (with SettingsNav) is available.
    setRightAvailable(false); // Mark the right sidebar as unavailable, hiding its toggle button.
    setRightOpen(false);      // Explicitly close the right sidebar in case it was open.

    // On unmount (when navigating away from settings), we can reset.
    // Setting availability to false is a safe default.
    return () => {
      setLeftAvailable(false);
      setRightAvailable(false);
    };
  }, [setLeftAvailable, setRightAvailable, setRightOpen]);

  return (
    <ThreeColumnLayout
      leftSidebar={<SettingsNav />}
      rightSidebar={null} // Pass null as content since it will be hidden.
    >
      {children}
    </ThreeColumnLayout>
  );
}

================================================================================

File: app/sites/[siteId]/settings/page.tsx
// src/app/sites/[siteId]/settings/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import SiteSettingsForm from '@/components/publishing/SiteSettingsForm';
import { Button } from '@/components/ui/button';
import { Manifest } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import Link from 'next/link';

export default function SiteSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);
  const isStoreInitialized = useAppStore(state => state.isInitialized);

  // Add baseUrl to the form state
  const [formData, setFormData] = useState({ title: '', description: '', author: '', baseUrl: '' });
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  useEffect(() => {
    if (site?.manifest) {
      setFormData({
        title: site.manifest.title,
        description: site.manifest.description,
        author: site.manifest.author || '',
        baseUrl: site.manifest.baseUrl || '',
      });
      setHasChanges(false);
    }
  }, [site]);
  
  const handleFormChange = useCallback((newData: typeof formData) => {
    setFormData(newData);
    setHasChanges(true);
  }, []);

  const handleSave = async () => {
    if (!site || !site.manifest) return;
    if (!formData.title.trim()) {
      toast.error("Site title cannot be empty.");
      return;
    }
    
    const trimmedBaseUrl = formData.baseUrl.trim();
    if (trimmedBaseUrl) {
      try {
        new URL(trimmedBaseUrl);
      } catch (error) {
        toast.error("The Base URL you entered is not a valid URL. Please include https://");
        return;
      }
    }
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      title: formData.title.trim(),
      description: formData.description.trim(),
      author: formData.author.trim(),
      baseUrl: trimmedBaseUrl,
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Site settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving site settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!isStoreInitialized || (site && !formData.title && !site.manifest.title)) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  if (!site) {
    return (
      <div className="p-6 text-center">
        <h2 className="text-xl font-semibold">Site Not Found</h2>
        <Button asChild variant="outline" className="mt-4">
          <Link href="/">Go to Dashboard</Link>
        </Button>
      </div>
    );
  }

  // The component now only returns its content, not the layout.
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Site Settings</h1>
        <p className="text-muted-foreground">Manage the core details of your website.</p>
      </div>
      <div className="border-t pt-6">
        <SiteSettingsForm 
          formData={formData}
          onFormChange={handleFormChange} 
        />
      </div>
      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/appearance/page.tsx
// src/app/sites/[siteId]/settings/appearance/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import AppearanceSettingsForm from '@/components/publishing/AppearanceSettingsForm';
import { Button } from '@/components/ui/button';
import { Manifest, ThemeConfig, ThemeInfo } from '@/types';
import { useEffect, useState, useCallback, useMemo } from 'react';
import { toast } from "sonner";
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { getAvailableThemes } from '@/lib/configHelpers';

export default function AppearanceSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);

  const [selectedThemePath, setSelectedThemePath] = useState<string>('');
  const [themeConfig, setThemeConfig] = useState<ThemeConfig['config']>({});
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  const availableThemes = useMemo(() => {
    return getAvailableThemes(site?.manifest);
  }, [site?.manifest]);

  useEffect(() => {
    if (site?.manifest.theme) {
      setSelectedThemePath(site.manifest.theme.name);
      setThemeConfig(site.manifest.theme.config);
      setHasChanges(false);
    }
  }, [site]);
  
  const handleConfigChange = useCallback((newConfig: ThemeConfig['config']) => {
    setThemeConfig(newConfig);
    setHasChanges(true);
  }, []);

  const handleThemeChange = (newThemePath: string) => {
    setSelectedThemePath(newThemePath);
    setThemeConfig({});
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!site || !site.manifest || !selectedThemePath) return;
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      theme: {
        name: selectedThemePath,
        config: themeConfig,
      },
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Appearance settings saved successfully!');
      setHasChanges(false);
    } catch {
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!site) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  // The component now only returns its content, not the layout.
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Appearance</h1>
        <p className="text-muted-foreground">Customize the visual style of your site.</p>
      </div>

      <div className="border-t pt-6 space-y-6">
        <div>
            <Label htmlFor="theme-select">Active Theme</Label>
            <Select value={selectedThemePath} onValueChange={handleThemeChange}>
                <SelectTrigger id="theme-select" className="mt-1">
                    <SelectValue placeholder="Select a theme..." />
                </SelectTrigger>
                <SelectContent>
                    {availableThemes.map((theme: ThemeInfo) => (
                        <SelectItem key={theme.path} value={theme.path}>
                            {theme.name}
                        </SelectItem>
                    ))}
                </SelectContent>
            </Select>
        </div>
        
        {selectedThemePath && (
            <AppearanceSettingsForm 
                site={site}
                themePath={selectedThemePath}
                themeConfig={themeConfig}
                onConfigChange={handleConfigChange}
            />
        )}
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Appearance'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/layout.tsx
// src/app/sites/[siteId]/edit/layout.tsx
'use client';

import { EditorProvider } from '@/contexts/EditorContext';
import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import { ReactNode } from 'react';

/**
 * The layout for the entire editing section (/edit).
 * It provides the EditorContext for managing save state and sidebars,
 * and renders the ThreeColumnLayout which is the main UI for editing.
 * Any page inside the `/edit` directory will be rendered as a child of this layout.
 */
export default function EditSiteLayout({ children }: { children: ReactNode }) {
  return (
    // The EditorProvider MUST wrap the components that use the `useEditor` hook.
    <EditorProvider>
      {({ leftSidebar, rightSidebar }) => (
        <ThreeColumnLayout
          leftSidebar={leftSidebar}
          rightSidebar={rightSidebar}
        >
          {/* The {children} prop here will be the actual page, e.g., EditContentPage */}
          {children}
        </ThreeColumnLayout>
      )}
    </EditorProvider>
  );
}

================================================================================

File: app/sites/[siteId]/edit/page.tsx
// src/app/sites/[siteId]/edit/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page acts as a default entry point for the editor.
// It immediately redirects to the editor for the site's homepage (index.md).
export default function SiteEditorRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid adding this redirect page to the browser history.
      // This will navigate to the content editor for the file at `content/index.md`.
      router.replace(`/sites/${siteId}/edit/content/`);
    }
  }, [siteId, router]);

  // Return a loading state while the redirect is happening.
  return (
    <div className="p-6 flex justify-center items-center h-full">
      <p>Loading editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/collection/[collectionName]/page.tsx
// src/app/sites/[siteId]/edit/collection/[collectionName]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import React, { useMemo, useState, useEffect, useCallback } from 'react';
import { useEditor } from '@/contexts/EditorContext';
import { useAutosave } from '@/hooks/useAutosave';
import { useUIStore } from '@/stores/uiStore';
import { useAppStore } from '@/stores/useAppStore';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import LeftSidebar from '@/components/publishing/LeftSidebar';
import PrimaryContentFields from '@/components/publishing/PrimaryContentFields';
import GroupedFrontmatterForm from '@/components/publishing/GroupedFrontmatterFields';
import { toast } from 'sonner';
import { FileText, PlusCircle } from 'lucide-react';
import type { StructureNode, LayoutInfo, MarkdownFrontmatter, LocalSiteData } from '@/types';
import { getAvailableLayouts, getLayoutManifest, type LayoutManifest } from '@/lib/configHelpers';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

type StableSiteDataForSidebar = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;

/**
 * A sub-component that renders the right sidebar UI for editing collection settings.
 * It is memoized to prevent re-renders unless its specific props change.
 */
const CollectionSettingsSidebar = React.memo(function CollectionSettingsSidebar({
    collectionNodeData,
    availableLayouts,
    layoutManifest,
    onLayoutChange,
    onPrimaryFieldsChange,
    onFormChange,
}: {
    collectionNodeData: StructureNode,
    availableLayouts: LayoutInfo[],
    layoutManifest: LayoutManifest | null,
    onLayoutChange: (newLayoutPath: string) => void,
    onPrimaryFieldsChange: (data: Partial<MarkdownFrontmatter>) => void,
    onFormChange: (data: Partial<StructureNode>) => void,
}) {
    const { title, description, ...otherFields } = collectionNodeData;
    const primaryFields = {
        title: typeof title === 'string' ? title : '',
        description: typeof description === 'string' ? description : '',
    };

    return (
        <div className="flex h-full flex-col p-4">
            <div className="flex-grow space-y-6">
                <h2 className="text-lg font-semibold border-b pb-3">Collection Settings</h2>
                <div className="space-y-4">
                    <PrimaryContentFields
                        frontmatter={primaryFields}
                        onFrontmatterChange={onPrimaryFieldsChange}
                        showDescription={true}
                    />
                </div>
                <div className="border-t pt-4 space-y-4">
                    <div>
                        <Label htmlFor="layout-select">Collection Layout</Label>
                        <Select value={collectionNodeData.layout} onValueChange={onLayoutChange}>
                            <SelectTrigger id="layout-select" className="mt-1">
                                <SelectValue placeholder="Select a layout..." />
                            </SelectTrigger>
                            <SelectContent>
                                {availableLayouts.map(layout => (
                                    <SelectItem key={layout.path} value={layout.path}>{layout.name}</SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    </div>
                    {layoutManifest?.layoutSchema ? (
                        <GroupedFrontmatterForm
                            schema={layoutManifest.layoutSchema}
                            uiSchema={layoutManifest.uiSchema}
                            formData={otherFields}
                            onFormChange={onFormChange}
                        />
                    ) : (
                        <p className="text-sm text-muted-foreground pt-4">This layout has no additional settings.</p>
                    )}
                </div>
            </div>
        </div>
    );
});


/**
 * The main page component for editing a collection's settings and viewing its items.
 * It relies on the parent `SiteLoaderLayout` to command the loading of site data
 * and reacts to that data becoming available in the `useAppStore`.
 */
export default function EditCollectionPage() {
    const params = useParams();
    const router = useRouter();
    const siteId = params.siteId as string;
    const collectionName = params.collectionName as string;
    
    // --- Context and Store Hooks ---
    const { hasUnsavedChanges, setHasUnsavedChanges, registerSaveAction, setLeftSidebar, setRightSidebar } = useEditor();
    const { setLeftAvailable, setRightAvailable } = useUIStore((state) => state.sidebar);
    
    // Subscribe to the site data. This component will re-render when the data is loaded by the parent layout.
    const site = useAppStore(state => state.getSiteById(siteId));
    const updateManifest = useAppStore(state => state.updateManifest);

    // --- Component State ---
    const [isDataReady, setIsDataReady] = useState(false);
    const [collectionNodeData, setCollectionNodeData] = useState<StructureNode | null>(null);
    const [layoutManifest, setLayoutManifest] = useState<LayoutManifest | null>(null);
    const [availableLayouts, setAvailableLayouts] = useState<LayoutInfo[]>([]);

    const collectionPath = `content/${collectionName}`;

    const originalCollectionNode = useMemo(() => {
        if (!site?.manifest) return undefined;
        return site.manifest.structure.find((node: StructureNode) => node.path === collectionPath);
    }, [site?.manifest, collectionPath]);
    
    /**
     * This is the main data orchestrator effect. It *reacts* to the `site` data from the store.
     * It does NOT command data loading.
     */
    useEffect(() => {
        // Guard 1: Wait for the site manifest to be loaded by the parent layout.
        if (!site?.manifest) {
            console.log(`[EditCollectionPage] Waiting for site manifest for ${siteId}...`);
            return;
        }

        // Guard 2: Wait for the site content to be loaded by the parent layout.
        if (!site.contentFiles) {
            console.log(`[EditCollectionPage] Waiting for site content files for ${siteId}...`);
            // The UI will show a loading indicator because isDataReady is false.
            return;
        }

        // --- Data is now guaranteed to be loaded ---
        console.log(`[EditCollectionPage] All required site data is loaded for ${siteId}.`);
        if (originalCollectionNode) {
            setCollectionNodeData(originalCollectionNode);
            setHasUnsavedChanges(false);
            setIsDataReady(true); // Data is ready, we can now render the full UI.
        } else {
            // If content is loaded but we still can't find the node, it's a 404.
            toast.error(`Collection "${collectionName}" not found.`);
            router.push(`/sites/${siteId}/edit`);
        }
    }, [site, originalCollectionNode, collectionName, siteId, router, setHasUnsavedChanges]);


    // --- Handlers (Memoized for performance) ---
    const handleFormChange = useCallback((data: Partial<StructureNode>) => {
        setCollectionNodeData(prev => prev ? { ...prev, ...data } : null);
        setHasUnsavedChanges(true);
    }, [setHasUnsavedChanges]);

    const handlePrimaryFieldsChange = useCallback((data: Partial<MarkdownFrontmatter>) => {
        setCollectionNodeData(prev => prev ? { ...prev, ...data } : null);
        setHasUnsavedChanges(true);
    }, [setHasUnsavedChanges]);

    const handleLayoutChange = useCallback((newLayoutPath: string) => {
        setCollectionNodeData(prev => prev ? { ...prev, layout: newLayoutPath, itemLayout: DEFAULT_PAGE_LAYOUT_PATH } : null);
        setHasUnsavedChanges(true);
    }, [setHasUnsavedChanges]);

    const handleSaveChanges = useCallback(async () => {
        if (!site?.manifest || !collectionNodeData) {
            throw new Error("Cannot save, essential data not found.");
        }
        const newStructure = site.manifest.structure.map((node: StructureNode) =>
            node.path === collectionPath ? collectionNodeData : node
        );
        const newManifest = { ...site.manifest, structure: newStructure };
        
        await updateManifest(siteId, newManifest);
        //toast.success(`Collection "${collectionNodeData.title}" updated successfully!`);
    }, [site?.manifest, collectionNodeData, collectionPath, siteId, updateManifest]);

    // --- Effect for registering save action and autosave ---
    useEffect(() => {
        registerSaveAction(handleSaveChanges);
    }, [handleSaveChanges, registerSaveAction]);
    
    useAutosave<StructureNode | null>({
        dataToSave: collectionNodeData,
        hasUnsavedChanges,
        isSaveable: !!collectionNodeData,
        onSave: handleSaveChanges,
    });
    
    // --- Effects for loading schemas and setting up sidebars ---
    useEffect(() => {
        if(site?.manifest) {
            const allLayouts = getAvailableLayouts(site.manifest);
            setAvailableLayouts(allLayouts.filter((l: LayoutInfo) => l.type === 'collection'));
        }
    }, [site?.manifest]);

    useEffect(() => {
        async function loadSchema() {
            if (site?.manifest && site.layoutFiles && site.themeFiles && collectionNodeData?.layout) {
                const siteForAssets: StableSiteDataForSidebar = { manifest: site.manifest, layoutFiles: site.layoutFiles, themeFiles: site.themeFiles };
                const loadedManifest = await getLayoutManifest(siteForAssets, collectionNodeData.layout);
                setLayoutManifest(loadedManifest);
            }
        }
        loadSchema();
    }, [collectionNodeData?.layout, site?.manifest, site?.layoutFiles, site?.themeFiles]);

    useEffect(() => {
        setLeftAvailable(true);
        setLeftSidebar(<LeftSidebar />);
        if (collectionNodeData) {
            setRightAvailable(true);
            setRightSidebar(
                <CollectionSettingsSidebar
                    collectionNodeData={collectionNodeData}
                    availableLayouts={availableLayouts}
                    layoutManifest={layoutManifest}
                    onLayoutChange={handleLayoutChange}
                    onPrimaryFieldsChange={handlePrimaryFieldsChange}
                    onFormChange={handleFormChange}
                />
            );
        } else {
            setRightAvailable(false);
            setRightSidebar(null);
        }
        return () => {
            setLeftAvailable(false);
            setRightAvailable(false);
            setLeftSidebar(null);
            setRightSidebar(null);
        };
    }, [collectionNodeData, availableLayouts, layoutManifest, handleLayoutChange, handlePrimaryFieldsChange, handleFormChange, setLeftAvailable, setRightAvailable, setLeftSidebar, setRightSidebar]);
    
    
    // --- RENDER GUARD ---
    // This is the crucial fix. We show a loading state until isDataReady is true.
    if (!isDataReady || !collectionNodeData) {
        return <div className="p-6 flex justify-center items-center h-full"><p>Loading Collection...</p></div>;
    }

    // --- Main Component Render ---
    return (
        <div className="h-full flex flex-col p-6">
            <div className="flex shrink-0 items-center justify-between mb-4">
                <h1 className="text-3xl font-bold truncate pr-4">Editing: {originalCollectionNode?.title}</h1>
                <Button asChild>
                    <Link href={`/sites/${siteId}/edit/content/${collectionName}/_new`}>
                        <PlusCircle className="mr-2 h-4 w-4" /> New Item
                    </Link>
                </Button>
            </div>
            <div className="flex-grow rounded-lg bg-background p-4 border overflow-y-auto">
                <h2 className="text-lg font-semibold mb-3">Items in this Collection</h2>
                {collectionNodeData.children && collectionNodeData.children.length > 0 ? (
                    <ul className="space-y-2">
                        {collectionNodeData.children.map((item: StructureNode) => {
                            const relativePath = item.path.replace(/^content\//, '').replace(/\.md$/, '');
                            return (
                                <li key={item.path}>
                                    <Link href={`/sites/${siteId}/edit/content/${relativePath}`} className="flex items-center rounded-md p-2 transition-colors hover:bg-muted">
                                        <FileText className="mr-3 h-4 w-4 text-muted-foreground" />
                                        <span className="font-medium">{item.title || item.slug}</span>
                                    </Link>
                                </li>
                            );
                        })}
                    </ul>
                ) : (
                    <p className="text-center text-muted-foreground py-8">No items have been added to this collection yet.</p>
                )}
            </div>
        </div>
    );
}

================================================================================

File: app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
// src/app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useEffect, useState, useCallback, useMemo, useRef } from 'react';
import { useAppStore } from '@/stores/useAppStore';
import { useUIStore } from '@/stores/uiStore';
import { useEditor } from '@/contexts/EditorContext';

// --- Component Imports ---
import MarkdownEditor, { type MarkdownEditorRef } from '@/components/publishing/MarkdownEditor';
import FrontmatterSidebar from '@/components/publishing/FrontmatterSidebar';
import PrimaryContentFields from '@/components/publishing/PrimaryContentFields';
import LeftSidebar from '@/components/publishing/LeftSidebar';

// --- Type Imports ---
import type { LocalSiteData, MarkdownFrontmatter } from '@/types';

// --- Util & Library Imports ---
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { slugify } from '@/lib/utils';
import { findNodeByPath } from '@/lib/fileTreeUtils';
import { toast } from "sonner";
import * as localSiteFs from '@/lib/localSiteFs';
import { NEW_FILE_SLUG_MARKER, AUTOSAVE_DELAY, DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

type StableSiteDataForSidebar = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;

/**
 * The main page for editing markdown content. This component uses a robust,
 * local state management pattern with a debounced autosave managed directly
 * inside the component to ensure performance and reliability.
 */
export default function EditContentPage() {
  const params = useParams();
  const router = useRouter();
  const siteId = params.siteId as string;
  const slugSegments = useMemo(() => (params.slug as string[]) || [], [params.slug]);

  // --- Store and Context Hooks ---
  const site = useAppStore(state => state.getSiteById(siteId));
  const { addOrUpdateContentFile, updateContentFileOnly, deleteContentFileAndState } = useAppStore.getState();
  const { setLeftAvailable, setRightAvailable } = useUIStore(state => state.sidebar);
  const { setHasUnsavedChanges, registerSaveAction, hasUnsavedChanges, setLeftSidebar, setRightSidebar, setSaveState } = useEditor();
  // --- Local State Management ---
  const [currentFrontmatter, setCurrentFrontmatter] = useState<MarkdownFrontmatter | null>(null);
  const [currentBodyContent, setCurrentBodyContent] = useState<string>('');
  const [slug, setSlug] = useState('');
  const [layoutPath, setLayoutPath] = useState('');
  const [isDataReady, setIsDataReady] = useState(false);
  const isNewFileMode = useMemo(() => slugSegments.includes(NEW_FILE_SLUG_MARKER), [slugSegments]);

  // --- Refs ---
  const editorRef = useRef<MarkdownEditorRef>(null);
  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const currentFilePath = useMemo(() => {
    if (isNewFileMode) {
      const newMarkerIndex = slugSegments.indexOf(NEW_FILE_SLUG_MARKER);
      const parentSlug = newMarkerIndex > 0 ? slugSegments.slice(0, newMarkerIndex).join('/') : '';
      return parentSlug ? `content/${parentSlug}` : 'content';
    }
    const pathParts = slugSegments.length > 0 ? slugSegments.join('/') : 'index';
    return `content/${pathParts}.md`;
  }, [slugSegments, isNewFileMode]);

  const handleSave = useCallback(async () => {
    if (autoSaveTimeoutRef.current) clearTimeout(autoSaveTimeoutRef.current);
    
    const bodyContent = editorRef.current?.getMarkdown();
    if (typeof bodyContent !== 'string' || !currentFrontmatter || !siteId || !layoutPath) {
      throw new Error("Cannot save: component is not ready or data is missing.");
    }
    const title = currentFrontmatter.title.trim();
    if (!title) {
      throw new Error("A title is required to save.");
    }

    const filePathToSave = isNewFileMode
      ? `${currentFilePath}/${slug.trim()}.md`.replace(/\/\//g, '/') 
      : currentFilePath;

    if (!filePathToSave.endsWith('.md')) throw new Error("Invalid file path for saving.");
    
    const rawMarkdownToSave = stringifyToMarkdown(currentFrontmatter, bodyContent);
    await addOrUpdateContentFile(siteId, filePathToSave, rawMarkdownToSave, layoutPath);

    if (isNewFileMode) {
      const newEditPath = filePathToSave.replace(/^content\//, '').replace(/\.md$/, '');
      router.replace(`/sites/${siteId}/edit/content/${newEditPath}`);
    }
  }, [currentFrontmatter, siteId, layoutPath, isNewFileMode, currentFilePath, slug, addOrUpdateContentFile, router]);
  
  const handleAutoSave = useCallback(async () => {
    setSaveState('saving'); // Tell the header we are saving
    
    const bodyContent = editorRef.current?.getMarkdown();
    if (typeof bodyContent !== 'string' || !currentFrontmatter || !currentFilePath.endsWith('.md')) {
        setSaveState('idle'); // Abort, revert state
        return;
    }
    
    try {
        const rawMarkdownToSave = stringifyToMarkdown(currentFrontmatter, bodyContent);
        const savedFile = await localSiteFs.saveContentFile(siteId, currentFilePath, rawMarkdownToSave);
        updateContentFileOnly(siteId, savedFile);
        setHasUnsavedChanges(false);
        
        setSaveState('saved'); // Tell the header we are done
        setTimeout(() => setSaveState('no_changes'), 2000); // Reset after a delay

    } catch(error) {
        console.error("Autosave failed:", error);
        toast.error("Autosave failed.");
        setSaveState('idle'); // Revert to idle on error to allow another attempt
    }
  }, [siteId, currentFilePath, currentFrontmatter, updateContentFileOnly, setHasUnsavedChanges, setSaveState]);
  
  const debouncedAutoSave = useCallback(() => {
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }
    autoSaveTimeoutRef.current = setTimeout(() => {
      console.log("[Autosave] Debounced timer finished. Executing save.");
      handleAutoSave();
    }, AUTOSAVE_DELAY);
  }, [handleAutoSave]);

  const onContentModified = useCallback(() => {
    setHasUnsavedChanges(true);
  }, [setHasUnsavedChanges]);
  
  const handleFrontmatterChange = useCallback((update: Partial<MarkdownFrontmatter>) => {
    setCurrentFrontmatter(prev => ({ ...(prev || { title: '' }), ...update }));
    if (update.title !== undefined && isNewFileMode) {
      setSlug(slugify(update.title));
    }
    onContentModified();
  }, [isNewFileMode, onContentModified]);

  const handleSlugChange = useCallback((newSlug: string) => {
    if (isNewFileMode) {
      setSlug(slugify(newSlug));
      onContentModified();
    }
  }, [isNewFileMode, onContentModified]);
  
  const handleDelete = useCallback(async () => {
    if (isNewFileMode || !currentFilePath.endsWith('.md')) return;
    try {
      await deleteContentFileAndState(siteId, currentFilePath);
      toast.success(`File "${currentFrontmatter?.title}" deleted.`);
      router.push(`/sites/${siteId}/edit`);
    } catch (error) { toast.error(`Failed to delete file: ${(error as Error).message}`); }
  }, [isNewFileMode, currentFilePath, siteId, currentFrontmatter, deleteContentFileAndState, router]);

  // --- Effects ---
  useEffect(() => {
    if (site?.contentFiles && !isDataReady) {
      if (isNewFileMode) {
        const parentNode = findNodeByPath(site.manifest.structure, currentFilePath);
        setLayoutPath(parentNode?.itemLayout || DEFAULT_PAGE_LAYOUT_PATH);
        setCurrentFrontmatter({ title: '', date: new Date().toISOString().split('T')[0], status: 'draft' });
        setCurrentBodyContent('# Start writing...');
        setSlug('');
      } else {
        const fileNode = findNodeByPath(site.manifest.structure, currentFilePath);
        const existingFile = site.contentFiles.find(f => f.path === currentFilePath);
        if (existingFile && fileNode) {
          setLayoutPath(fileNode.layout);
          setCurrentFrontmatter(existingFile.frontmatter);
          setCurrentBodyContent(existingFile.content || '');
          setSlug(existingFile.slug);
        } else {
          toast.error(`Content not found for this URL.`);
          router.push(`/sites/${siteId}/edit`);
          return;
        }
      }
      setIsDataReady(true);
      setHasUnsavedChanges(false);
    }
  }, [site, isDataReady, currentFilePath, isNewFileMode, router, siteId, setHasUnsavedChanges]);
  
  useEffect(() => {
    registerSaveAction(handleSave);
  }, [handleSave, registerSaveAction]);

  /**
   * This effect reacts to the `hasUnsavedChanges` flag. When it becomes true,
   * it triggers the debounced autosave. This correctly separates the action of
   * changing content from the reaction of saving it, and fixes the ESLint error.
   */
  useEffect(() => {
    if (hasUnsavedChanges && !isNewFileMode) {
      debouncedAutoSave();
    }
  }, [hasUnsavedChanges, isNewFileMode, debouncedAutoSave]);


  useEffect(() => {
    setLeftAvailable(true);
    setLeftSidebar(<LeftSidebar />);
    
    if (isDataReady && currentFrontmatter && site) {
      setRightAvailable(true);
      const siteForSidebar: StableSiteDataForSidebar = { manifest: site.manifest, layoutFiles: site.layoutFiles ?? [], themeFiles: site.themeFiles ?? [] };
      setRightSidebar(
        <FrontmatterSidebar
          site={siteForSidebar}
          layoutPath={layoutPath}
          frontmatter={currentFrontmatter}
          onFrontmatterChange={handleFrontmatterChange}
          isNewFileMode={isNewFileMode}
          slug={slug}
          onSlugChange={handleSlugChange}
          onDelete={handleDelete}
        />
      );
    } else {
      setRightAvailable(false);
      setRightSidebar(null);
    }
  }, [isDataReady, currentFrontmatter, site, layoutPath, isNewFileMode, slug, handleDelete, handleFrontmatterChange, handleSlugChange, setLeftAvailable, setRightAvailable, setLeftSidebar, setRightSidebar]);
  
  if (!isDataReady) {
    return <div className="p-6 flex justify-center items-center h-full"><p>Loading Editor...</p></div>;
  }
  
  return (
    <div className='flex h-full w-full flex-col p-6'>
      <div className='container mx-auto flex h-full max-w-[900px] flex-col'>
          <div className="shrink-0">
              <PrimaryContentFields
                  frontmatter={currentFrontmatter!}
                  onFrontmatterChange={handleFrontmatterChange}
                  showDescription={true}
              />
          </div>
          <div className="mt-6 flex-grow">
            <MarkdownEditor
              ref={editorRef}
              key={currentFilePath}
              initialValue={currentBodyContent}
              onContentChange={onContentModified}
            />
          </div>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/view/[[...slug]]/page.tsx
// src/app/sites/[siteId]/view/[[...slug]]/page.tsx
'use client';

import SitePreview from '@/components/view/SiteViewer';

export default function ViewSitePage() {
  // This page's only job is to render the master preview component.
  // The component itself will read the URL from the browser.
  return <SitePreview />;
}

================================================================================

File: app/create-site/page.tsx
// src/app/(publishing)/create-site/page.tsx
'use client';

import { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import { LocalSiteData, ParsedMarkdownFile, MarkdownFrontmatter, StructureNode, ThemeInfo } from '@/types';
import { Button } from '@/components/ui/button';
import { generateSiteId } from '@/lib/utils';
import { toast } from "sonner";
import { getLayoutManifest } from '@/lib/configHelpers';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { GENERATOR_VERSION, CORE_THEMES, DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

export default function CreateSitePage() {
  const router = useRouter();
  const addSite = useAppStore((state) => state.addSite);

  const [siteTitle, setSiteTitle] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  const availableThemes = useMemo(() => CORE_THEMES, []);
  const [selectedTheme, setSelectedTheme] = useState<ThemeInfo | null>(availableThemes[0] || null);

  const handleSubmit = async () => {
    if (!siteTitle.trim() || !selectedTheme) {
      toast.error('Site title and a theme are required.');
      return;
    }
    setIsLoading(true);

    const newSiteId = generateSiteId(siteTitle);
    const homepageLayoutPath = DEFAULT_PAGE_LAYOUT_PATH;

    // FIXED: 'defaultFrontmatter' is never reassigned, so it should be a const.
    const defaultFrontmatter: MarkdownFrontmatter = {
        title: 'Welcome to your new site!',
        date: new Date().toISOString().split('T')[0],
    };

    // FIXED: Create a complete mock LocalSiteData object to satisfy the type system.
    const mockSiteData: LocalSiteData = { 
        siteId: 'mock-id', 
        contentFiles: [], 
        layoutFiles: [], 
        themeFiles: [], 
        manifest: { 
            siteId: 'mock-id',
            title: 'mock',
            description: 'mock',
            generatorVersion: GENERATOR_VERSION,
            structure: [],
            theme: { 
                name: selectedTheme.path, 
                config: {} 
            } 
        } 
    };
    
    const layoutManifest = await getLayoutManifest(mockSiteData, homepageLayoutPath);
    
    if (layoutManifest?.pageSchema.properties) {
        for (const [key, prop] of Object.entries(layoutManifest.pageSchema.properties)) {
            if (typeof prop === 'object' && prop !== null && 'default' in prop && defaultFrontmatter[key] === undefined) {
                defaultFrontmatter[key] = prop.default as unknown;
            }
        }
    }

    const defaultIndexFile: ParsedMarkdownFile = {
        slug: 'index',
        path: 'content/index.md',
        frontmatter: defaultFrontmatter,
        content: `# Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`,
    };
    
    const indexStructureNode: StructureNode = {
        type: 'page',
        title: 'Home',
        path: 'content/index.md',
        slug: 'index',
        navOrder: 0,
        layout: homepageLayoutPath,
    };

    const newSiteData: LocalSiteData = {
      siteId: newSiteId,
      manifest: {
        siteId: newSiteId,
        generatorVersion: GENERATOR_VERSION,
        title: siteTitle.trim(),
        description: siteDescription.trim(),
        theme: {
          name: selectedTheme.path,
          config: {},
        },
        structure: [indexStructureNode],
      },
      contentFiles: [defaultIndexFile],
      themeFiles: [],
      layoutFiles: [],
    };

    try {
      await addSite(newSiteData);
      toast.success(`Site "${siteTitle}" created successfully!`);
      router.push(`/sites/${newSiteId}/edit/content/index`);
    } catch (error) {
      toast.error(`Failed to create site: ${(error as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-2xl">
      <div className="space-y-6">
        <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Create a New Site</h1>
            <Button onClick={() => router.push('/')} variant="outline">Cancel</Button>
        </div>

        <div className="space-y-4 p-6 border rounded-lg">
            <h2 className="text-lg font-semibold">Site Details</h2>
            <div>
                <Label htmlFor="site-title">Site Title</Label>
                <Input
                    id="site-title"
                    value={siteTitle}
                    onChange={(e) => setSiteTitle(e.target.value)}
                    placeholder="My Awesome Project"
                    required
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="site-description">Site Description (Optional)</Label>
                <Textarea
                    id="site-description"
                    value={siteDescription}
                    onChange={(e) => setSiteDescription(e.target.value)}
                    placeholder="A short and catchy description of your new site."
                    rows={3}
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="theme-select">Theme</Label>
                <Select 
                    value={selectedTheme?.path || ''} 
                    onValueChange={(themePath) => {
                        const theme = availableThemes.find(t => t.path === themePath);
                        if (theme) setSelectedTheme(theme);
                    }} 
                >
                    <SelectTrigger id="theme-select" className="mt-1">
                        <SelectValue placeholder="Select a theme..." />
                    </SelectTrigger>
                    <SelectContent>
                        {availableThemes.map(theme => (
                            <SelectItem key={theme.path} value={theme.path}>
                                {theme.name}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                 <p className="text-xs text-muted-foreground mt-1">
                    Choose the overall design for your site. You can change this later.
                </p>
            </div>
        </div>

        <div className="flex justify-end">
            <Button onClick={handleSubmit} disabled={isLoading || !siteTitle.trim() || !selectedTheme} size="lg">
                {isLoading ? 'Creating...' : 'Create Site'}
            </Button>
        </div>
      </div>
    </div>
  );
}

================================================================================

File: config/editorConfig.ts
// src/config/editorConfig.ts
import type { ThemeInfo, LayoutInfo } from '@/types';
import { RJSFSchema, UiSchema } from '@rjsf/utils'; 

/**
 * The official version of the Signum generator client.
 * This is written to the manifest.json on site creation and can be used
 * by the theme engine or other tools to check for compatibility.
 */
export const GENERATOR_VERSION = 'SignumClient/1.3.0';

/**
 * The URL segment used to identify a new, unsaved content file.
 * This allows the editor to distinguish between editing an existing file
 * and creating a new one.
 * e.g., /edit/site-id/content/blog/_new
 */
export const NEW_FILE_SLUG_MARKER = '_new';

/**
 * The delay in milliseconds for the autosave functionality in the content editor.
 * A longer delay reduces server/storage load but increases risk of data loss on close.
 * A shorter delay saves more often but can be more "chatty".
 */
export const AUTOSAVE_DELAY = 2500;

/**
 * The default layout path used for any new single page.
 * The system will fall back to this if a more specific layout isn't defined.
 * The path is relative to '/public/layouts/'.
 * e.g., 'page'
 */
export const DEFAULT_PAGE_LAYOUT_PATH = 'page';

/**
 * The default layout path used for any new collection.
 * This ensures that when a user creates a new collection, it has a sensible
 * default appearance without requiring an immediate decision.
 * The path is relative to '/public/layouts/'.
 * e.g., 'listing'
 */
export const DEFAULT_COLLECTION_LAYOUT_PATH = 'listing';

export const CORE_LAYOUTS: LayoutInfo[] = [
  { id: 'page', name: 'Page', type: 'page', path: 'page' },
  { id: 'listing', name: 'Listing', type: 'collection', path: 'listing' },
];

export const CORE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', path: 'default' },
];


/**
 * The universal base schema for all content frontmatter.
 * This object is imported directly, eliminating network requests.
 * Fields like 'title' and 'description' are not included here because they
 * are handled by dedicated UI components, not the generic form generator.
 */
export const BASE_SCHEMA: { schema: RJSFSchema; uiSchema: UiSchema } = {
  schema: {
    title: 'Base content fields',
    type: 'object',
    properties: {
      slug: {
        type: 'string',
        title: 'Slug (URL Path)',
        description: 'The URL-friendly version of the title. Auto-generated, but can be edited.',
      },
      image: {
        type: 'string',
        title: 'Image',
        description: 'URL or path to a featured image for this content.',
      },
      date: {
        type: 'string',
        title: 'Publication date',
        format: 'date',
      },
      status: {
        type: 'string',
        title: 'Status',
        enum: ['published', 'draft'],
        default: 'draft',
      },
      author: {
        type: 'string',
        title: 'Author',
      },
      tags: {
        type: 'array',
        title: 'Tags',
        items: {
          type: 'string',
        },
      },
    },
  },
  uiSchema: {
    slug: {
      'ui:widget': 'hidden',
    },
    tags: {
      'ui:options': {
        addable: true,
        removable: true,
      },
    },
  },
};

================================================================================

File: stores/uiStore.ts
import { create, StateCreator } from 'zustand';

// --- Helper for screen size ---
const isDesktopView = () => typeof window !== 'undefined' && window.innerWidth >= 1024;

// --- Type Definitions for the store structure ---

// Defines the shape of the data in the sidebar slice
interface SidebarState {
  isLeftOpen: boolean;
  isRightOpen: boolean;
  isLeftAvailable: boolean;
  isRightAvailable: boolean;
}

// Defines the actions available in the sidebar slice
interface SidebarActions {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  setLeftAvailable: (available: boolean) => void;
  setRightAvailable: (available: boolean) => void;
  setRightOpen: (isOpen: boolean) => void;
}

// Defines the shape of the data in the screen slice
interface ScreenState {
  isDesktop: boolean;
}

// Defines the actions available in the screen slice
interface ScreenActions {
    initializeScreenSize: () => void;
}

// The full store shape, combining state and actions
type UIState = {
    sidebar: SidebarState & SidebarActions;
    screen: ScreenState & ScreenActions;
}

// --- Store Slice Implementations ---

// Creates the sidebar slice of the store
const createSidebarSlice: StateCreator<UIState, [], [], { sidebar: SidebarState & SidebarActions }> = (set, get) => ({
  sidebar: {
    isLeftOpen: isDesktopView(),
    isRightOpen: isDesktopView(),
    isLeftAvailable: false,
    isRightAvailable: false,
    toggleLeftSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isLeftOpen: !state.sidebar.isLeftOpen, 
            // On mobile, opening one sidebar closes the other
            isRightOpen: !get().screen.isDesktop && !state.sidebar.isLeftOpen ? false : state.sidebar.isRightOpen 
        }
    })),
    toggleRightSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isRightOpen: !state.sidebar.isRightOpen, 
            isLeftOpen: !get().screen.isDesktop && !state.sidebar.isRightOpen ? false : state.sidebar.isLeftOpen 
        }
    })),
    setLeftAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isLeftAvailable: available }})),
    setRightAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isRightAvailable: available }})),
    setRightOpen: (isOpen) => set(state => ({ sidebar: { ...state.sidebar, isRightOpen: isOpen }})),

  }
});

// Creates the screen slice of the store
const createScreenSlice: StateCreator<UIState, [], [], { screen: ScreenState & ScreenActions }> = (set, get) => ({
    screen: {
        isDesktop: isDesktopView(),
        initializeScreenSize: () => {
          if (typeof window === 'undefined') return;

          const handleResize = () => {
            const desktop = isDesktopView();
            // Only update state if the view mode has actually changed
            if (desktop !== get().screen.isDesktop) {
              set({ 
                  screen: { ...get().screen, isDesktop: desktop }, 
                  // When the breakpoint is crossed, reset sidebars to default for that size
                  sidebar: { ...get().sidebar, isLeftOpen: desktop, isRightOpen: desktop }
                });
            }
          };
          window.addEventListener('resize', handleResize);
          handleResize(); // Set initial state on mount
        },
    }
});


// Combine the slices to create the final store
export const useUIStore = create<UIState>()((...a) => ({
    ...createSidebarSlice(...a),
    ...createScreenSlice(...a),
}));

================================================================================

File: stores/useAppStore.ts
// src/stores/useAppStore.ts
import { create } from 'zustand';
import { produce, enableMapSet } from 'immer';
import { AppState, LocalSiteData, Manifest, StructureNode, ParsedMarkdownFile } from '@/types';
import * as localSiteFs from '@/lib/localSiteFs';
import { getParentPath } from '@/lib/fileTreeUtils';
import { DEFAULT_PAGE_LAYOUT_PATH, DEFAULT_COLLECTION_LAYOUT_PATH } from '@/config/editorConfig';
import { toast } from 'sonner';

// Enable the Immer plugin for Map and Set support
enableMapSet();

interface AppStoreWithInit extends AppState {
  isInitialized: boolean;
  loadingSites: Set<string>;
  initialize: () => Promise<void>;
  loadSite: (siteId: string) => Promise<void>;
  updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile) => void;
}

export const useAppStore = create<AppStoreWithInit>()(
  (set, get) => ({
    sites: [],
    isInitialized: false,
    loadingSites: new Set(),

    initialize: async () => {
      if (get().isInitialized) return;
      console.log('[AppStore] Initializing application state...');
      set({ isInitialized: true });
    },

    /**
     * Ensures a site is fully loaded into the store using an atomic update.
     * It fetches all necessary data first, then commits it to the store in a single update.
     * @param {string} siteId - The unique identifier of the site to load.
     */
    loadSite: async (siteId: string) => {
      const state = get();
      if (state.loadingSites.has(siteId)) {
        console.log(`[AppStore.loadSite] Load already in progress for siteId: ${siteId}.`);
        return;
      }

      const existingSite = state.getSiteById(siteId);
      if (existingSite && existingSite.contentFiles) {
        console.log(`[AppStore.loadSite] Site ${siteId} is already fully loaded.`);
        return;
      }
      
      console.log(`[AppStore.loadSite] Starting atomic load for siteId: ${siteId}...`);
      set(produce((draft) => { draft.loadingSites.add(siteId); }));

      try {
        // --- Step 1: Gather all required data asynchronously ---
        const manifest = await localSiteFs.getManifestById(siteId);
        if (!manifest) {
          toast.error(`Site data could not be found for ID: ${siteId}`);
          throw new Error(`Failed to load manifest for siteId: ${siteId}`);
        }

        const contentFiles = await localSiteFs.getSiteContentFiles(siteId);
        const layoutFiles = await localSiteFs.getSiteLayoutFiles(siteId); // Also fetch layout/theme files
        const themeFiles = await localSiteFs.getSiteThemeFiles(siteId);

        // --- Step 2: Assemble the final, complete site object ---
        const loadedSiteData: LocalSiteData = {
          siteId,
          manifest,
          contentFiles,
          layoutFiles,
          themeFiles,
        };

        // --- Step 3: Commit the final state in a single, atomic update ---
        set(produce((draft: AppStoreWithInit) => {
          const siteIndex = draft.sites.findIndex((s: LocalSiteData) => s.siteId === siteId);
          if (siteIndex > -1) {
            draft.sites[siteIndex] = loadedSiteData;
          } else {
            draft.sites.push(loadedSiteData);
          }
        }));

        console.log(`[AppStore.loadSite] Atomic load successful for siteId: ${siteId}.`);

      } catch (error) {
        console.error(`[AppStore.loadSite] Error during atomic load for ${siteId}:`, error);
      } finally {
        console.log(`[AppStore.loadSite] Finished load process for siteId: ${siteId}.`);
        set(produce((draft) => { draft.loadingSites.delete(siteId); }));
      }
    },

    /**
     * Adds a new site to persistent storage and then atomically updates the application state.
     * @param {LocalSiteData} newSiteData - The complete data object for the new site.
     */
    addSite: async (newSiteData: LocalSiteData) => {
      console.log(`[AppStore.addSite] Creating new site: "${newSiteData.manifest.title}" (ID: ${newSiteData.siteId})`);
      
      // --- Step 1: Perform the async operation ---
      await localSiteFs.saveSite(newSiteData);
      
      // --- Step 2: Perform the atomic state update ---
      set(produce((draft: AppStoreWithInit) => {
        // Prevent duplicates in case of race conditions
        if (!draft.sites.some((s: LocalSiteData) => s.siteId === newSiteData.siteId)) {
          draft.sites.push(newSiteData);
        }
      }));
      
      console.log(`[AppStore.addSite] Site "${newSiteData.siteId}" successfully saved and added to state.`);
    },

    /**
     * Updates a site's manifest in both persistent storage and the current application state.
     * @param {string} siteId - The ID of the site whose manifest is being updated.
     * @param {Manifest} newManifest - The new manifest object to save.
     */
    updateManifest: async (siteId: string, newManifest: Manifest) => {
      console.log(`[AppStore.updateManifest] Updating manifest for siteId: ${siteId}`);
      await localSiteFs.saveManifest(siteId, newManifest);
      set(produce((draft: AppStoreWithInit) => {
        const site = draft.sites.find((s: LocalSiteData) => s.siteId === siteId);
        if (site) {
          site.manifest = newManifest;
        }
      }));
    },
    
    // ... (The rest of the store actions (addNewCollection, updateContentFileOnly, etc.) remain the same as they were already correct) ...

    addNewCollection: async (siteId: string, name: string, slug: string, layout: string) => {
      console.log(`[AppStore.addNewCollection] Adding collection "${name}" to site ${siteId}`);
      const site = get().getSiteById(siteId);
      if (!site) return;

      const newCollectionNode: StructureNode = {
        type: 'collection',
        title: name.trim(),
        path: `content/${slug}`,
        slug: slug,
        children: [],
        navOrder: site.manifest.structure.length,
        layout: layout || DEFAULT_COLLECTION_LAYOUT_PATH,
        itemLayout: DEFAULT_PAGE_LAYOUT_PATH,
      };
      
      const newManifest = produce(site.manifest, draft => {
        draft.structure.push(newCollectionNode);
      });
      
      await get().updateManifest(siteId, newManifest);
    },
    
    updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile) => {
        set(produce((draft: AppStoreWithInit) => {
            const site = draft.sites.find((s: LocalSiteData) => s.siteId === siteId);
            if (!site?.contentFiles) {
              console.warn(`[AppStore.updateContentFileOnly] Attempted to update file, but content for site ${siteId} is not loaded. Aborting.`);
              return;
            }

            const fileIndex = site.contentFiles.findIndex(f => f.path === savedFile.path);
            if (fileIndex !== -1) {
                site.contentFiles[fileIndex] = savedFile;
            } else {
                site.contentFiles.push(savedFile);
            }
        }));
    },

    addOrUpdateContentFile: async (siteId: string, filePath: string, rawMarkdownContent: string, layoutId: string): Promise<boolean> => {
      console.log(`[AppStore.addOrUpdateContentFile] Saving file "${filePath}" for site ${siteId}.`);
      const savedFile = await localSiteFs.saveContentFile(siteId, filePath, rawMarkdownContent);
      
      const site = get().getSiteById(siteId);
      if (!site || !site.contentFiles) return false;

      const isNewFile = !site.contentFiles.some(f => f.path === filePath);

      const newManifest = produce(site.manifest, draft => {
          let parentFound = false;
          
          const mapNode = (node: StructureNode): StructureNode => {
              if (isNewFile && node.path === getParentPath(filePath)) {
                  parentFound = true;
                  return { ...node, children: [...(node.children || []), { type: 'page', title: savedFile.frontmatter.title, path: filePath, slug: savedFile.slug, layout: layoutId }] };
              }
              if (!isNewFile && node.path === filePath && node.title !== savedFile.frontmatter.title) {
                  return { ...node, title: savedFile.frontmatter.title };
              }
              if (node.children) {
                  return { ...node, children: node.children.map(mapNode) };
              }
              return node;
          };

          draft.structure = draft.structure.map(mapNode);

          if (isNewFile && !parentFound && getParentPath(filePath) === 'content') {
            draft.structure.push({ type: 'page', title: savedFile.frontmatter.title, path: filePath, slug: savedFile.slug, layout: layoutId, navOrder: draft.structure.length });
          }
      });
      
      set(produce((draft: AppStoreWithInit) => {
          const siteToUpdate = draft.sites.find((s: LocalSiteData) => s.siteId === siteId);
          if (siteToUpdate) {
              if (!siteToUpdate.contentFiles) siteToUpdate.contentFiles = [];

              const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === filePath);
              if (fileIndex !== -1) {
                  siteToUpdate.contentFiles[fileIndex] = savedFile;
              } else {
                  siteToUpdate.contentFiles.push(savedFile);
              }
              siteToUpdate.manifest = newManifest;
          }
      }));

      await localSiteFs.saveManifest(siteId, newManifest);
      return true;
    },
        
    deleteSiteAndState: async (siteId: string) => {
        console.warn(`[AppStore.deleteSiteAndState] DELETING siteId: ${siteId}`);
        await localSiteFs.deleteSite(siteId);
        set(state => ({
            sites: state.sites.filter((s: LocalSiteData) => s.siteId !== siteId),
        }));
    },

    deleteContentFileAndState: async (siteId: string, filePath: string) => {
      console.warn(`[AppStore.deleteContentFileAndState] DELETING file "${filePath}" from site ${siteId}`);
      const site = get().getSiteById(siteId);
      if (!site) return;

      await localSiteFs.deleteContentFile(siteId, filePath);
      
      const newManifest = produce(site.manifest, draft => {
          const filterStructure = (nodes: StructureNode[]): StructureNode[] => {
              return nodes.filter(node => node.path !== filePath).map(node => {
                  if (node.children) {
                      node.children = filterStructure(node.children);
                  }
                  return node;
              });
          };
          draft.structure = filterStructure(draft.structure);
      });
      
      await localSiteFs.saveManifest(siteId, newManifest);
      
      set(produce((draft: AppStoreWithInit) => {
          const siteToUpdate = draft.sites.find((s: LocalSiteData) => s.siteId === siteId);
          if(siteToUpdate) {
            if (siteToUpdate.contentFiles) {
                siteToUpdate.contentFiles = siteToUpdate.contentFiles.filter(f => f.path !== filePath);
            }
            siteToUpdate.manifest = newManifest;
          }
      }));
    },

    getSiteById: (siteId: string): LocalSiteData | undefined => {
      return get().sites.find((s: LocalSiteData) => s.siteId === siteId);
    },
  })
);

================================================================================

File: components/publishing/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { Label } from '@/components/ui/label';

interface MarkdownEditorProps {
  initialValue: string;
  // onContentChange is now used primarily by the parent to trigger its own state updates
  onContentChange: (markdown: string) => void;
}

// The ref now needs to expose a method to get the current content
export interface MarkdownEditorRef {
  getMarkdown: () => string;
}

const MarkdownEditor = forwardRef<MarkdownEditorRef, MarkdownEditorProps>(
  ({ initialValue, onContentChange }, ref) => {
    // We'll manage the textarea's value with local state
    const [content, setContent] = useState(initialValue);

    // If the initialValue prop changes from the parent (e.g., loading a new file),
    // we update the local state.
    useEffect(() => {
      setContent(initialValue);
    }, [initialValue]);

    // Expose a function for the parent component to get the current content
    useImperativeHandle(ref, () => ({
      getMarkdown: () => {
        return content;
      },
    }));

    // This handler updates both local state and informs the parent of a change
    const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
      const newContent = event.target.value;
      setContent(newContent);
      onContentChange(newContent); // Let the parent know things have changed
    };

    return (
      <div className="space-y-2 h-full">
      <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400">
            Content
          </Label>
      <textarea
        id="content-body"
        value={content}
        onChange={handleChange}
        placeholder="Start writing your Markdown here..."
        className="w-full h-full bg-background 
                   text-base font-mono leading-relaxed resize-none 
                   focus:ring-2 focus:ring-ring focus:outline-none"
      />
      </div>
    );
  }
);

MarkdownEditor.displayName = 'MarkdownEditor';
export default MarkdownEditor;

================================================================================

File: components/publishing/EditorHeader.tsx
'use client';

import { useState, useContext } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import { useUIStore } from '@/stores/uiStore';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';
import { toast } from 'sonner';
import { exportSiteToZip } from '@/lib/siteExporter';
import { EditorContext, useEditor } from '@/contexts/EditorContext'; 
import { slugify } from '@/lib/utils';
import { Eye, PanelLeft, UploadCloud, PanelRight, Save, Check, Loader2 } from 'lucide-react';
import Image from 'next/image';

const SaveButton = () => {
  // --- START OF FIX ---
  // Directly get the context. If it's undefined, we are not in an EditorProvider.
  const editorContext = useContext(EditorContext);

  // If there's no context, this button has no purpose, so render nothing.
  if (!editorContext) {
    return null;
  }
  // --- END OF FIX ---

  // Now that we know the context exists, we can safely call the hook.
  const { saveState, triggerSave } = useEditor();

  const buttonContent = {
    idle: { icon: <Save className="h-4 w-4" />, text: 'Save ' },
    saving: { icon: <Loader2 className="h-4 w-4 animate-spin" />, text: 'Saving' },
    saved: { icon: <Check className="h-4 w-4" />, text: 'Saved' },
    no_changes: { icon: <Check className="h-4 w-4" />, text: 'Saved' },
  };

  const current = buttonContent[saveState];
  const isDisabled = saveState === 'saving' || saveState === 'saved' || saveState === 'no_changes';

  return (
    <Button variant='ghost' onClick={triggerSave} disabled={isDisabled}>
      {current.icon}
      <span className='hidden md:block'>{current.text}</span>
    </Button>
  );
};


export default function EditorHeader() {
  const params = useParams();
  const siteId = params.siteId as string;
  const [isPublishing, setIsPublishing] = useState(false);
  const site = useAppStore((state) => state.getSiteById(siteId));
  
  const toggleLeftSidebar = useUIStore((state) => state.sidebar.toggleLeftSidebar);
  const toggleRightSidebar = useUIStore((state) => state.sidebar.toggleRightSidebar);
  const isLeftAvailable = useUIStore((state) => state.sidebar.isLeftAvailable);
  const isRightAvailable = useUIStore((state) => state.sidebar.isRightAvailable);


  const handlePublishSite = async () => {
    if (!site) {
      toast.error("Site data not found. Cannot publish.");
      return;
    }
    setIsPublishing(true);
    toast.info("Generating site bundle for download...");
    try {
      const blob = await exportSiteToZip(site);
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${slugify(site.manifest.title || 'signum-site')}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      toast.success("Site bundle downloaded!");
    } catch (error) {
      console.error("Error publishing site to Zip:", error);
      toast.error(`Failed to generate Zip: ${(error as Error).message}`);
    } finally {
        setIsPublishing(false);
    }
  };
  
  if (!site) {
    return (
        <header className="sticky top-0 z-20 flex h-[60px] items-center gap-4 border-b bg-background px-4 lg:h-[60px]"></header>
    );
  }

  return (
    <header className="sticky top-0 z-20 flex shrink-0 items-center gap-4 border-b bg-background lg:pl-4 pr-4 h-[60px]">
      <div className="flex items-center gap-2">
        {/* Render button only if the left sidebar is available for the current page */}
        <Link
            href="/sites"
            title="Dashboard"
            className=' flex lg:hidden flex-col w-[60px] h-[60px] items-center border-r mr-2'
          >
            <Image src="/signum.svg" width={34} height={34} alt="" className='m-auto'/>
          </Link>
        {isLeftAvailable && (
            <Button 
                variant="outline" 
                size="icon" 
                className="shrink-0" 
                onClick={toggleLeftSidebar}
            >
                <PanelLeft className="h-5 w-5" />
                <span className="sr-only">Toggle file tree</span>
            </Button>
        )}
      </div>

      <div className="flex-1 text-lg text-muted-foreground">
       <span className="font-bold text-foreground">{site.manifest.title}</span>
      </div>
      
      <div className="flex items-center justify-end gap-2">
        <SaveButton />
        <Button variant="outline" asChild>
            <Link href={`/sites/${siteId}/view`} target="_blank">
                <Eye className="h-4 w-4" /> <span className='hidden md:block '>View</span>
            </Link>
        </Button>
        <Button variant="default" onClick={handlePublishSite} disabled={isPublishing}>
            <UploadCloud className="h-4 w-4" /> 
            <span className='hidden md:block '>{isPublishing ? 'Publishing...' : 'Publish'}</span>
        </Button>

        {/* Render button only if the right sidebar is available for the current page */}
        {isRightAvailable && (
            <Button variant="outline" size="icon" className="shrink-0" onClick={toggleRightSidebar}>
                <PanelRight className="h-5 w-5" />
                <span className="sr-only">Toggle settings sidebar</span>
            </Button>
        )}
      </div>
    </header>
  );
}

================================================================================

File: components/publishing/PrimaryContentFields.tsx
// src/components/publishing/PrimaryContentFields.tsx
'use client';

import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { MarkdownFrontmatter } from '@/types';

// FIXED: The interface is now much stricter and safer.
// It only defines the properties this component actually cares about.
interface PrimaryFieldsProps {
  frontmatter: {
    title?: string;
    description?: string;
  };
  // The callback expects a partial update to the main frontmatter state.
  onFrontmatterChange: (newData: Partial<MarkdownFrontmatter>) => void;
  showDescription?: boolean;
}

export default function PrimaryContentFields({
  frontmatter,
  onFrontmatterChange,
}: PrimaryFieldsProps) {

  // FIXED: The handler now only passes back the single field that changed.
  // This makes the component more reusable and decoupled from the parent's state shape.
  const handleChange = (field: 'title' | 'description', value: string) => {
    onFrontmatterChange({
      [field]: value,
    });
  };

  return (
    <div className="space-y-4 shrink-0">
      <div className="space-y-2 mb-6 border-b pb-3">
        <Label htmlFor="content-title" className="text-[10px] font-medium uppercase text-gray-400">
          Title
        </Label>
        <Input
          id="content-title"
          placeholder="Enter a title..."
          value={frontmatter.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          // These classes create the large, "invisible" input style
          className="text-2xl lg:text-3xl font-bold h-auto p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent"
        />
      </div>

        <div className="space-y-2 mb-6 border-b pb-3">
          <Label htmlFor="content-description" className="text-[10px] font-medium uppercase text-gray-400">
            Description
          </Label>
          <Textarea
            
            placeholder="Add a short description..."
            value={frontmatter.description || ''}
            onChange={(e) => handleChange('description', e.target.value)}
            // Style for a clean, borderless textarea
            className="p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent resize-none text-2xl text-black"
            rows={1}
          />
        </div>
    </div>
  );
}

================================================================================

File: components/publishing/NewCollectionDialog.tsx
// src/components/publishing/NewCollectionDialog.tsx
'use client';

import { useState, useEffect, type ReactNode } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import { type LayoutInfo } from '@/types'; // FIXED: Import the correct LayoutInfo type

interface NewCollectionDialogProps {
  children: ReactNode;
  existingSlugs: string[];
  availableLayouts: LayoutInfo[]; // FIXED: Use the correct type
  onSubmit: (name: string, slug: string, layoutPath: string) => Promise<void>;
}

export default function NewCollectionDialog({ children, existingSlugs, availableLayouts, onSubmit }: NewCollectionDialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');
  const [selectedLayout, setSelectedLayout] = useState(''); // This will now store the layout *path*

  useEffect(() => {
    if (name) {
      setSlug(slugify(name));
    } else {
      setSlug('');
    }
  }, [name]);
  
  // Set a default layout when the dialog opens
  useEffect(() => {
    if (isOpen && availableLayouts.length > 0) {
      // FIXED: Set the default value to the layout's unique path
      setSelectedLayout(availableLayouts[0].path);
    }
  }, [isOpen, availableLayouts]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !slug.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }
    if (!selectedLayout) {
        toast.error("You must select a layout for the collection.");
        return;
    }
    if (existingSlugs.includes(slug)) {
      toast.error(`A collection or page with the folder name "${slug}" already exists.`);
      return;
    }

    // FIXED: onSubmit now receives the layout path
    await onSubmit(name, slug, selectedLayout);
    
    // Reset state after submission
    setIsOpen(false);
    setName('');
    setSlug('');
    setSelectedLayout('');
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection</DialogTitle>
            <DialogDescription>
              Create a new folder to organize your content. All items in this collection will share a common layout.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
            <div className="space-y-1">
              <Label htmlFor="layout-select">Layout</Label>
               <Select value={selectedLayout} onValueChange={setSelectedLayout}>
                    <SelectTrigger id="layout-select"><SelectValue placeholder="Select a layout..." /></SelectTrigger>
                    <SelectContent>
                        {availableLayouts.map(layout => (
                            // FIXED: The key and value should be the unique path
                            <SelectItem key={layout.path} value={layout.path}>
                                {layout.name}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name || !selectedLayout}>Create Collection</Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: components/publishing/AppearanceSettingsForm.tsx
// src/components/publishing/AppearanceSettingsForm.tsx
'use client';

import { useEffect, useState } from 'react';
import { RJSFSchema } from '@rjsf/utils';
// --- FIX: We now need the type for the theme manifest ---
import { getJsonAsset, type ThemeManifest } from '@/lib/configHelpers';
import SchemaDrivenForm from './SchemaDrivenForm';
import { ThemeConfig, LocalSiteData } from '@/types';

interface AppearanceSettingsFormProps {
  site: LocalSiteData;
  themePath: string;
  themeConfig: ThemeConfig['config'];
  onConfigChange: (newConfig: ThemeConfig['config']) => void;
}

export default function AppearanceSettingsForm({ site, themePath, themeConfig, onConfigChange }: AppearanceSettingsFormProps) {
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function loadSchema() {
      if (!themePath) {
        setIsLoading(false);
        setSchema(null);
        return;
      }
      
      setIsLoading(true);

      // --- START OF CORRECTED LOGIC ---

      // 1. Fetch the entire theme.json file for the active theme.
      const themeManifest = await getJsonAsset<ThemeManifest>(
        site,
        'theme',
        themePath,
        'theme.json' // <-- Correct filename
      );

      // 2. Check if the manifest was found and if it contains the appearance schema.
      if (themeManifest && themeManifest.appearanceSchema) {
        setSchema(themeManifest.appearanceSchema);
      } else {
        // If not found, there are no settings, so set the schema to null.
        setSchema(null);
      }
      
      // --- END OF CORRECTED LOGIC ---

      setIsLoading(false);
    }

    loadSchema();
  }, [site, themePath]);
  
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onConfigChange(event.formData as ThemeConfig['config'] || {});
  };

  if (isLoading) {
    return (
        <div className="flex items-center justify-center p-4 text-muted-foreground">
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span>Loading appearance options...</span>
        </div>
    );
  }

  if (!schema) {
    return (
      <div className="text-center border-2 border-dashed p-6 rounded-lg">
        <p className="font-semibold">No Appearance Options</p>
        <p className="text-sm text-muted-foreground">The current theme ("{themePath}") does not provide any customizable appearance settings.</p>
      </div>
    );
  }

  return (
    <SchemaDrivenForm
      schema={schema}
      formData={themeConfig}
      onFormChange={handleChange}
    />
  );
}

================================================================================

File: components/publishing/SiteSettingsForm.tsx
// src/components/publishing/SiteSettingsForm.tsx
'use client';

import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

interface SiteSettingsFormProps {
  formData: {
    title: string;
    description: string;
    author: string;
    baseUrl: string; // <-- ADD THIS LINE
  };
  onFormChange: (newData: SiteSettingsFormProps['formData']) => void;
}

export default function SiteSettingsForm({ formData, onFormChange }: SiteSettingsFormProps) {
  const handleChange = (field: keyof typeof formData, value: string) => {
    onFormChange({ ...formData, [field]: value });
  };

  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Label htmlFor="title">Site Title</Label>
        <Input
          id="title"
          value={formData.title}
          onChange={(e) => handleChange('title', e.target.value)}
          placeholder="My Awesome Site"
        />
        <p className="text-sm text-muted-foreground">The main title for your website.</p>
      </div>
      <div className="space-y-2">
        <Label htmlFor="description">Site Description</Label>
        <Textarea
          id="description"
          value={formData.description}
          onChange={(e) => handleChange('description', e.target.value)}
          placeholder="A short, catchy description."
          rows={3}
        />
         <p className="text-sm text-muted-foreground">Used for search engines and social media previews.</p>
      </div>
       <div className="space-y-2">
        <Label htmlFor="author">Author (Optional)</Label>
        <Input
          id="author"
          value={formData.author}
          onChange={(e) => handleChange('author', e.target.value)}
          placeholder="Your Name or Organization"
        />
         <p className="text-sm text-muted-foreground">The default author for content on this site.</p>
      </div>
       {/* --- NEW BASE URL FIELD --- */}
       <div className="space-y-2 border-t pt-6">
        <Label htmlFor="baseUrl">Base URL</Label>
        <Input
          id="baseUrl"
          type="url"
          value={formData.baseUrl}
          onChange={(e) => handleChange('baseUrl', e.target.value)}
          placeholder="https://www.my-awesome-site.com"
        />
         <p className="text-sm text-muted-foreground">
            The full public URL of your site. Required for generating correct RSS feeds and sitemaps.
         </p>
      </div>
    </div>
  );
}

================================================================================

File: components/publishing/FileTree.tsx
// src/components/publishing/FileTree.tsx
'use client';

import React, { useState, useMemo } from 'react';
import Link from 'next/link';
import { type StructureNode } from '@/types';
import { GripVertical, ChevronRight } from 'lucide-react';

import { cn } from '@/lib/utils';
import { DndContext, closestCenter, DragEndEvent } from '@dnd-kit/core';
import { SortableContext, useSortable, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { TbFileDescription, TbLayoutGrid } from "react-icons/tb";
interface FileTreeProps {
  nodes: StructureNode[];
  baseEditPath: string;
  activePath?: string;
  onFileCreate: (parentPath: string) => void;
  onStructureChange: (nodes: StructureNode[]) => void;
}

interface FileTreeNodeProps extends Omit<FileTreeProps, 'nodes'> {
  node: StructureNode;
}

// A single sortable tree node.
const SortableNode: React.FC<FileTreeNodeProps> = ({ node, baseEditPath, activePath, onFileCreate, onStructureChange }) => {
    const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: node.path });
    const [isOpen, setIsOpen] = useState(true);
    
    const style = { transform: CSS.Transform.toString(transform), transition };

    const isFolderType = node.type === 'collection' || (node.type === 'page' && node.children && node.children.length > 0);
    
    // CORRECTED: Generate links robustly using the full relative path for pages.
    const relativeContentPath = node.path.replace(/^content\//, '').replace(/\.md$/, '');
    const href = node.type === 'collection'
        ? `${baseEditPath}/collection/${node.slug}`
        : `${baseEditPath}/content/${relativeContentPath}`;

    const isSelected = activePath === node.path;
    const NodeIcon = node.type === 'collection' ? TbLayoutGrid : (node.type === 'page' && node.children && node.children.length > 0 ? TbLayoutGrid : TbFileDescription);

    const handleChildrenStructureChange = (reorderedChildren: StructureNode[]) => {
        onStructureChange([{ ...node, children: reorderedChildren }]);
    };

    return (
        <div ref={setNodeRef} style={style} className="flex flex-col">
            <div className="flex items-center group w-full my-0.5">
                <div {...attributes} {...listeners} className="p-1 cursor-grab touch-none">
                    <GripVertical className="h-4 w-4 text-muted-foreground/50" />
                </div>
                <div className={cn("flex-grow flex items-center py-1 pl-1 pr-1 rounded-md hover:bg-muted relative", isSelected && "bg-accent text-accent-foreground")}>
                    {isFolderType && (
                        <ChevronRight 
                            className={cn("h-4 w-4 mr-1 shrink-0 transition-transform duration-200 cursor-pointer", isOpen && "rotate-90", !node.children?.length && "invisible")} 
                            onClick={() => setIsOpen(!isOpen)} 
                        />
                    )}
                    <NodeIcon className={cn("h-4 w-4 shrink-0", isFolderType ? 'text-foreground' : 'text-foreground', !isFolderType && 'ml-5')} />
                    
                    <Link href={href} className="truncate flex-grow mx-1.5 text-sm" title={node.title}>
                        {node.title}
                    </Link>

                    
                </div>
            </div>
            {isFolderType && isOpen && node.children && node.children.length > 0 && (
                <div className="pl-6">
                    <FileTree
                        nodes={node.children}
                        baseEditPath={baseEditPath}
                        activePath={activePath}
                        onFileCreate={onFileCreate}
                        onStructureChange={handleChildrenStructureChange}
                    />
                </div>
            )}
        </div>
    );
};

// The main FileTree component that sets up the DndContext.
export default function FileTree({ nodes, baseEditPath, activePath, onFileCreate, onStructureChange }: FileTreeProps) {
  const nodeIds = useMemo(() => nodes.map(n => n.path), [nodes]);

  if (!nodes || nodes.length === 0) {
    return <p className="p-2 text-sm text-muted-foreground">(No content files yet)</p>;
  }

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
        const oldIndex = nodeIds.indexOf(active.id as string);
        const newIndex = nodeIds.indexOf(over.id as string);
        if (oldIndex !== -1 && newIndex !== -1) {
            const reorderedNodes = arrayMove(nodes, oldIndex, newIndex);
            const updatedNavOrderNodes = reorderedNodes.map((node, index) => {
                if (node.navOrder !== undefined) {
                    return { ...node, navOrder: index };
                }
                return node;
            });
            onStructureChange(updatedNavOrderNodes);
        }
    }
  };

  return (
    <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
        <SortableContext items={nodeIds} strategy={verticalListSortingStrategy}>
            <div className="space-y-0">
                {nodes.map(node => (
                    <SortableNode 
                        key={node.path} 
                        node={node} 
                        baseEditPath={baseEditPath} 
                        activePath={activePath} 
                        onFileCreate={onFileCreate} 
                        onStructureChange={(updatedChildNode) => {
                            const newNodes = nodes.map(n => n.path === updatedChildNode[0].path ? updatedChildNode[0] : n);
                            onStructureChange(newNodes);
                        }}
                    />
                ))}
            </div>
        </SortableContext>
    </DndContext>
  );
}

================================================================================

File: components/publishing/NewFolderDialog.tsx
// src/components/publishing/NewFolderDialog.tsx
'use client';

import { useState, type ReactNode } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { toast } from 'sonner';

interface NewFolderDialogProps {
  children: ReactNode;
  onSubmit: (folderName: string) => Promise<void>;
}

export default function NewFolderDialog({ children, onSubmit }: NewFolderDialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) {
      toast.error("Folder name cannot be empty.");
      return;
    }
    
    try {
        await onSubmit(name);
        toast.success(`Folder "${name}" created!`);
        setIsOpen(false);
        setName('');
    } catch (error) {
        toast.error(`Failed to create folder: ${(error as Error).message}`);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
            <DialogHeader>
            <DialogTitle>Create New Folder</DialogTitle>
            <DialogDescription>
                Create a folder to organize pages. An `index.md` file will be automatically created inside it.
            </DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="name" className="text-right">
                Name
                </Label>
                <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="col-span-3"
                placeholder="e.g., About Us"
                autoComplete="off"
                />
            </div>
            </div>
            <DialogFooter>
                <DialogClose asChild>
                    <Button type="button" variant="outline">Cancel</Button>
                </DialogClose>
                <Button type="submit">Create Folder</Button>
            </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: components/publishing/SettingsNav.tsx
'use-client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbUserCircle, TbPalette } from 'react-icons/tb';
import { cn } from '@/lib/utils';

// This is the navigation component for the settings area.
export default function SettingsNav() {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const navItems = [
    { href: `/sites/${siteId}/settings`, title: 'Site Details', icon: TbUserCircle },
    { href: `/sites/${siteId}/settings/appearance`, title: 'Appearance', icon: TbPalette },
    // Add more settings links here as needed
  ];

  return (
    <div className="flex h-full flex-col p-4">
      <h2 className="px-2 text-lg font-semibold tracking-tight">Settings</h2>
      <nav className="mt-4 flex flex-col gap-1">
        {navItems.map((item) => (
          <Link
            key={item.href}
            href={item.href}
            className={cn(
              'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
              pathname === item.href
                ? 'bg-primary text-primary-foreground'
                : 'text-muted-foreground hover:bg-muted/50 hover:text-foreground'
            )}
          >
            <item.icon className="h-5 w-5" />
            {item.title}
          </Link>
        ))}
      </nav>
    </div>
  );
}

================================================================================

File: components/publishing/RightSidebar.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/stores/uiStore';
import { cn } from '@/lib/utils';

interface RightSidebarProps {
  children: ReactNode;
}

export default function RightSidebar({ children }: RightSidebarProps) {
  const { isRightOpen } = useUIStore((state) => state.sidebar);

  return (
    <aside
      className={cn(
        // Base styles
        'h-full w-80 shrink-0 border-l bg-muted/20 transition-all duration-300 ease-in-out',
        
        // Hide/Show Logic
        isRightOpen ? 'ml-0' : '-mr-[320px] w-0 border-l-0 opacity-0'
      )}
    >
      <div className="h-full overflow-y-auto">
        {children}
      </div>
    </aside>
  );
}

================================================================================

File: components/publishing/LeftSidebar.tsx
// src/components/publishing/LeftSidebar.tsx
'use client';

import Link from 'next/link';
import { useParams, usePathname, useRouter } from 'next/navigation';
import { useMemo, useCallback, useEffect, useState } from 'react';

// --- Store and Component Imports ---
import { useAppStore } from '@/stores/useAppStore';
import { useUIStore } from '@/stores/uiStore';
import { Button } from '@/components/ui/button';
import FileTree from '@/components/publishing/FileTree';
import NewCollectionDialog from '@/components/publishing/NewCollectionDialog';

// --- Type, Util, and Config Imports ---
import type { StructureNode, LayoutInfo, ParsedMarkdownFile } from '@/types'; // Added ParsedMarkdownFile
import { getAvailableLayouts } from '@/lib/configHelpers';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';

// --- Icon Imports ---
import { Home, FilePlus, FolderPlus } from 'lucide-react';

/**
 * Renders the primary left sidebar for the site editor.
 * It displays the site's file structure, handles navigation,
 * and provides actions for creating new pages and collections.
 */
export default function LeftSidebar() {
  const params = useParams();
  const pathname = usePathname();
  const router = useRouter();
  const siteId = params.siteId as string;

  // --- State & Store Hooks ---
  const [activePath, setActivePath] = useState<string | undefined>();
  
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const toggleLeftSidebar = useUIStore((state) => state.sidebar.toggleLeftSidebar);
  const isDesktop = useUIStore((state) => state.screen.isDesktop);

  // FIX: Changed `getById` to the correct `getSiteById`
  const site = useAppStore((state) => state.getSiteById(siteId));
  const addNewCollection = useAppStore((state) => state.addNewCollection);
  const updateManifest = useAppStore((state) => state.updateManifest);
  
  // --- Memoized Values ---
  const siteStructure = useMemo(() => site?.manifest.structure || [], [site?.manifest.structure]);

  const availableCollectionLayouts = useMemo(() => {
    if (!site?.manifest) return [];
    return getAvailableLayouts(site.manifest).filter((l: LayoutInfo) => l.type === 'collection');
  }, [site?.manifest]);

  // FIX: Explicitly typed `c` as `StructureNode` to resolve implicit 'any' error.
  const existingTopLevelSlugs = useMemo(() => site?.manifest.structure.map((c: StructureNode) => c.slug) || [], [site?.manifest.structure]);

  // --- Effects ---
  // Determines which file/collection is currently active based on the URL
  useEffect(() => {
    // Guard to ensure contentFiles is loaded before proceeding.
    if (!site || !site.contentFiles) {
      return;
    }

    const pathSegments = pathname.split('/');
    let currentPath = '';

    if (pathname.includes('/edit/collection/')) {
        const slug = pathSegments[pathSegments.indexOf('collection') + 1];
        currentPath = `content/${slug}`;
    } else if (pathname.includes('/edit/content/')) {
        const contentSlug = pathname.substring(pathname.indexOf('/edit/content/') + 14).replace(/\/$/, '') || 'index';
        const pathWithExt = `content/${contentSlug}.md`;
        
        // FIX: Explicitly typed `f` as `ParsedMarkdownFile` to resolve implicit 'any' error.
        currentPath = site.contentFiles.find((f: ParsedMarkdownFile) => f.path === pathWithExt)?.path || pathWithExt;
    } else {
        // Fallback for root edit pages that redirect
        currentPath = 'content/index.md';
    }
    setActivePath(currentPath);
    
  }, [pathname, site, site?.contentFiles]);

  // --- Handlers ---
  const handleStructureChange = useCallback((reorderedNodes: StructureNode[]) => {
      if (!site) return;
      const newManifest = { ...site.manifest, structure: reorderedNodes };
      updateManifest(siteId, newManifest);
  }, [site, siteId, updateManifest]);

  const handleNavigateToNewFile = useCallback((parentPath: string = 'content') => {
    const parentSlugPart = parentPath === 'content' ? '' : parentPath.replace(/^content\/?/, '');
    const newFileRoute = `/sites/${siteId}/edit/content/${parentSlugPart ? parentSlugPart + '/' : ''}${NEW_FILE_SLUG_MARKER}`;
    router.push(newFileRoute.replace(/\/\//g, '/'));
    if (!isDesktop) toggleLeftSidebar();
  }, [siteId, router, isDesktop, toggleLeftSidebar]);
  
  const handleCreateNewCollection = useCallback(async (name: string, slug: string, layout: string) => {
    if (!site) return;
    await addNewCollection(siteId, name, slug, layout);
    toast.success(`Collection "${name}" created!`);
    router.push(`/sites/${siteId}/edit/collection/${slug}`);
    if (!isDesktop) toggleLeftSidebar();
  }, [site, siteId, addNewCollection, router, isDesktop, toggleLeftSidebar]);

  // Render a loading state or null if the site manifest hasn't even loaded yet.
  if (!site) {
    return null;
  }

  return (
    <>
      {/* Mobile-only overlay to close the sidebar when clicking outside */}
      {!isDesktop && (
        <div
          onClick={toggleLeftSidebar}
          className={cn(
            'fixed inset-0 z-40 bg-black/60 transition-opacity',
            isLeftOpen ? 'opacity-100' : 'pointer-events-none opacity-0'
          )}
        ></div>
      )}

      {/* The main sidebar container */}
      <div
        className={cn(
          'flex h-full flex-col'
        )}
      >
        <div className="flex px-3 py-1 shrink-0 items-center justify-between border-b ">
            <h4 className="text-xs font-semibold uppercase tracking-wider text-muted-foreground">Content</h4>
            <div className="flex items-center gap-1">
                <Button variant="ghost" className='size-6 p-2 rounded-sm' onClick={() => handleNavigateToNewFile('content')} title="New Page">
                    <FilePlus className="h-4 w-4" />
                </Button>
                <NewCollectionDialog 
                    existingSlugs={existingTopLevelSlugs} 
                    availableLayouts={availableCollectionLayouts}
                    onSubmit={handleCreateNewCollection}
                >
                    <Button variant="ghost"  className='size-6 p-2  rounded-sm' title="New Collection">
                        <FolderPlus className="h-4 w-4" />
                    </Button>
                </NewCollectionDialog>
            </div>
        </div>
        
        <div className="flex-grow overflow-y-auto px-2 py-4">
            <FileTree 
                nodes={siteStructure} 
                baseEditPath={`/sites/${siteId}/edit`}
                activePath={activePath}
                onFileCreate={handleNavigateToNewFile} 
                onStructureChange={handleStructureChange}
            />
        </div>

        <div className="mt-auto shrink-0 border-t p-2">
            <Button variant="ghost" asChild className="w-full justify-start gap-2">
                <Link href="/sites">
                    <Home className="h-4 w-4" /> App Dashboard
                </Link>
            </Button>
        </div>
      </div>
    </>
  );
}

================================================================================

File: components/publishing/SchemaDrivenForm.tsx
'use client';

import Form from '@rjsf/shadcn';
import validator from '@rjsf/validator-ajv8';
import { RJSFSchema, UiSchema, FieldTemplateProps, ObjectFieldTemplateProps } from '@rjsf/utils';
import { Label } from '../ui/label';
// REMOVED: Unused 'Button' import
// import { Button } from '../ui/button'; 

// --- Props Definition ---
interface SchemaDrivenFormProps {
  /** The JSON Schema object that defines the form fields, types, and validation. */
  schema: RJSFSchema;
  /** The UI Schema object for customizing widget types and field appearances. */
  uiSchema?: UiSchema;
  /** The current data/state of the form. */
  formData: object;
  /** Callback function that is triggered every time the form data changes. */
  onFormChange: (data: object) => void;
  /** Set to true to enable live validation as the user types. Defaults to false. */
  liveValidate?: boolean;
}


// --- Custom Field Template (for better layout and labels) ---
function CustomFieldTemplate(props: FieldTemplateProps) {
  const { id, classNames, label, help, required, description, errors, children, schema } = props;

  if (props.hidden) {
    return <div className="hidden">{children}</div>;
  }
  
  const isCheckbox = schema.type === 'boolean' && (props.uiSchema?.['ui:widget'] === 'checkbox' || props.uiSchema?.['ui:widget'] === undefined);

  if (isCheckbox) {
      return <div className={classNames}>{children}</div>
  }

  return (
    <div className={classNames}>
      {label && (
        <Label htmlFor={id} className="block text-sm font-medium mb-1">
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}
      
      {description}
      
      {children}
      
      {errors}
      
      {help}
    </div>
  );
}

// --- Custom Object Field Template (for overall form layout) ---
function CustomObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  return (
    <div>
        {props.description && <p className="text-sm text-muted-foreground">{props.description}</p>}
        <div className="mt-4">
            {props.properties.map(element => (
                <div key={element.name} className="mb-4">
                    {element.content}
                </div>
            ))}
        </div>
    </div>
  );
}

// --- Custom Submit Button Template (to hide it) ---
// FIXED: The 'props' parameter was defined but never used, so it has been removed.
function HideSubmitButton() {
    return null;
}

/**
 * A reusable component that dynamically generates a form from a given JSON Schema.
 * It uses react-jsonschema-form with a shadcn/ui theme for a consistent look and feel.
 */
export default function SchemaDrivenForm({ 
  schema, 
  uiSchema, 
  formData, 
  onFormChange, 
  liveValidate = false 
}: SchemaDrivenFormProps) {

  const safeFormData = formData || {};

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={safeFormData}
      validator={validator}
      onChange={(e) => onFormChange(e.formData)}
      liveValidate={liveValidate}
      showErrorList={false}
      
      templates={{
        FieldTemplate: CustomFieldTemplate,
        ObjectFieldTemplate: CustomObjectFieldTemplate,
        ButtonTemplates: {
            SubmitButton: HideSubmitButton,
        }
      }}
    />
  );
}

================================================================================

File: components/publishing/FrontmatterSidebar.tsx
// src/components/publishing/FrontmatterSidebar.tsx
'use client';

import React, { useState, useEffect } from 'react';
import type { MarkdownFrontmatter, LocalSiteData } from '@/types';
import GroupedFrontmatterFields from '@/components/publishing/GroupedFrontmatterFields';
import { getLayoutManifest } from '@/lib/configHelpers';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Trash2 } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";

interface FrontmatterSidebarProps {
  site: Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;
  layoutPath: string;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: Partial<MarkdownFrontmatter>) => void;
  isNewFileMode: boolean;
  slug: string;
  onSlugChange: (newSlug: string) => void;
  onDelete: () => Promise<void>;
  // --- FIX: The onSave prop is removed as the header now controls saving ---
}

export default function FrontmatterSidebar({
  site, layoutPath, frontmatter, onFrontmatterChange,
  isNewFileMode, slug, onSlugChange, onDelete
}: FrontmatterSidebarProps) {
  
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [uiSchema, setUiSchema] = useState<UiSchema | undefined>(undefined);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function loadSchemaForLayout() {
      if (!layoutPath) return;
      setIsLoading(true);
      try {
        const manifest = await getLayoutManifest(site, layoutPath);
        setSchema(manifest?.pageSchema || null);
        setUiSchema(manifest?.uiSchema);
      } catch (error) {
        console.error(`Failed to load schema for layout '${layoutPath}':`, error);
        setSchema(null);
      } finally {
        setIsLoading(false);
      }
    }
    loadSchemaForLayout();
  }, [site, layoutPath]);
  
  if (isLoading) {
    return <div className="p-4 flex items-center justify-center"><p className="text-sm text-muted-foreground">Loading settings...</p></div>;
  }

   return (
    <div className="p-4 space-y-6">
      {/* --- FIX: The save button is completely removed from this component --- */}

      {schema && Object.keys(schema.properties || {}).length > 0 ? (
        <GroupedFrontmatterFields
            schema={schema}
            uiSchema={uiSchema}
            formData={frontmatter}
            onFormChange={onFrontmatterChange}
        />
      ) : (
        <div className="text-sm text-muted-foreground p-3 rounded-md text-center border-dashed border">
            <p>No additional settings for this layout.</p>
        </div>
      )}

      <Accordion type='single' collapsible className="w-full">
        <AccordionItem value="item-1">
          <AccordionTrigger>Advanced</AccordionTrigger>
          <AccordionContent>
            <div className="space-y-4 pt-4">
              <div className="space-y-2">
                <Label htmlFor="slug-input">URL Slug</Label>
                <Input 
                    id="slug-input"
                    value={slug}
                    onChange={(e) => onSlugChange(e.target.value)}
                    disabled={!isNewFileMode}
                    className={!isNewFileMode ? 'bg-muted/50' : ''}
                />
                <p className="text-xs text-muted-foreground">
                  {isNewFileMode 
                    ? "Auto-generates from title." 
                    : "URL cannot be changed after creation."}
                </p>
              </div>
              {!isNewFileMode && (
                <AlertDialog>
                    <AlertDialogTrigger asChild>
                        <Button variant="outline" className="w-full mt-6 text-destructive hover:text-destructive">
                            <Trash2 className="h-4 w-4 mr-2" /> Delete This Page
                        </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent> 
                        <AlertDialogHeader>
                            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                            <AlertDialogDescription>
                              This action will permanently delete the file for &quot;{frontmatter?.title || 'this content'}&quot;. This cannot be undone.
                            </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                            <AlertDialogCancel>Cancel</AlertDialogCancel>
                            <AlertDialogAction onClick={onDelete} className="bg-destructive hover:bg-destructive/90">
                                Yes, Delete Forever
                            </AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialog>
              )}
            </div>
          </AccordionContent>
        </AccordionItem>
      </Accordion>
    </div>
  );
}

================================================================================

File: components/publishing/GroupedFrontmatterFields.tsx
// src/components/publishing/GroupedFrontmatterFields.tsx
'use client';

import { useMemo } from 'react';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import SchemaDrivenForm from './SchemaDrivenForm';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";

interface Group {
  title: string;
  fields: string[];
}
type StrictUiSchema = UiSchema & { 'ui:groups'?: Group[] };

interface GroupedFrontmatterFormProps {
  schema: RJSFSchema;
  uiSchema?: StrictUiSchema;
  formData: Record<string, unknown>;
  onFormChange: (newData: Record<string, unknown>) => void;
}

function createSubSchema(originalSchema: RJSFSchema, fields: string[]): RJSFSchema {
  const subSchema: RJSFSchema = { ...originalSchema, properties: {}, required: originalSchema.required?.filter(field => fields.includes(field)) };
  if (!subSchema.properties) subSchema.properties = {};
  for (const field of fields) {
    if (originalSchema.properties && originalSchema.properties[field]) {
      subSchema.properties[field] = originalSchema.properties[field];
    }
  }
  return subSchema;
}

export default function GroupedFrontmatterForm({
  schema,
  uiSchema,
  formData,
  onFormChange,
}: GroupedFrontmatterFormProps) {
  
  const { groups, ungroupedFields } = useMemo(() => {
    const definedGroups = uiSchema?.['ui:groups'] || [];
    const allSchemaFields = Object.keys(schema.properties || {});
    const fieldsInGroups = new Set(definedGroups.flatMap(g => g.fields));
    const remainingFields = allSchemaFields.filter(f => !fieldsInGroups.has(f));
    return { groups: definedGroups, ungroupedFields: remainingFields };
  }, [schema, uiSchema]);

  // FIXED: The handler now accepts the event from rjsf and extracts the formData.
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onFormChange(event.formData || {});
  };

  if (!schema.properties || Object.keys(schema.properties).length === 0) {
    return <p className="text-sm text-muted-foreground">This layout has no configurable fields.</p>;
  }

  return (
    <div className="border-t">
      <Accordion type="multiple" defaultValue={groups.map(g => g.title)} className="w-full">
        {groups.map((group) => {
          if (group.fields.length === 0) return null;
          return (
            <AccordionItem value={group.title} key={group.title}>
              <AccordionTrigger>{group.title}</AccordionTrigger>
              <AccordionContent className="pt-4">
                <SchemaDrivenForm
                  schema={createSubSchema(schema, group.fields)}
                  formData={formData}
                  onFormChange={handleChange}
                />
              </AccordionContent>
            </AccordionItem>
          );
        })}
      </Accordion>

      {ungroupedFields.length > 0 && (
        <div className="">
            <Accordion type='single' collapsible>

<AccordionItem value="item-1">                <AccordionTrigger>
                  Fields
                </AccordionTrigger>
                <AccordionContent>
<SchemaDrivenForm
            schema={createSubSchema(schema, ungroupedFields)}
            formData={formData}
            onFormChange={handleChange}
          />
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </div>
      )}
    </div>
  );
}

================================================================================

File: components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: components/ui/link.tsx
import * as Headless from '@headlessui/react'
import NextLink, { type LinkProps } from 'next/link'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: LinkProps & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <NextLink {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})

================================================================================

File: components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: components/ui/accordion.tsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex border-b">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 text-xs font-semibold uppercase tracking-wider text-muted-foreground transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 py-2 px-2",
          className
        )}
        {...props}
      >
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0 transition-transform duration-200 mr-1" />
        {children}
        
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm py-4 px-3"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================

File: components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: components/core/Navbar.tsx
// src/components/core/Navbar.tsx
'use client';

import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation'; // Import useRouter
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input'; // Import Input
import React, { useState } from 'react';

// ... (NavLink component remains the same) ...
const NavLink: React.FC<{ href: string; label: string; icon?: React.ReactNode; }> = ({ href, label, icon }) => {
  const pathname = usePathname();
  const isActive = pathname === href || (href !== '/' && pathname.startsWith(href));
  return (
    <Button  className={`justify-start ${isActive ? 'bg-accent text-accent-foreground' : ''}`}>
      <Link href={href} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};


export default function Navbar() {
  const router = useRouter();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim()); // Basic URL validation
        // We need a way to signify this is a remote URL to our browsing pages.
        // Option 1: Special prefix for siteId, e.g., "remote::http://localhost:8080"
        // Option 2: A different route, e.g., /browse/remote?url=...
        // Option 3: Pass state via router.push (can be complex with SSR/layouts)

        // Let's use Option 1: Prefix the siteId with "remote@" or similar marker
        // and encode the URL. The browsing page will then decode it.
        const encodedUrl = encodeURIComponent(url.origin); // Use origin (scheme + hostname + port)
        router.push(`/remote@${encodedUrl}`); // Navigate to /remote@http%3A%2F%2Flocalhost%3A8080
        setRemoteUrl(''); // Clear input
      } catch (error) {
        alert("Invalid URL entered.");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        <Link href="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
        </Link>
        
        {/* Remote Site URL Input */}
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Signum site URL (e.g., http://localhost:8080)"
              className="pl-9" // Padding for the icon
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          <NavLink href="/" label="Dashboard" icon={<Home className="h-4 w-4" />} />
          {/* ... other links ... */}
        </nav>

        <div className="md:hidden">
          <Button  >
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: components/core/Footer.tsx
// src/components/core/Footer.tsx
import Link from 'next/link';
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p> {currentYear} Signum Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: components/core/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: components/core/ErrorBoundary.tsx
// src/components/core/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    // Update state so the next render will show the fallback UI.
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // You can also log the error to an error reporting service
    console.error("Uncaught error:", error, errorInfo);
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: undefined });
    // Optionally, you could try to trigger a reload or navigate home
    // window.location.assign('/'); 
  }

  public render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center bg-destructive/10 border border-destructive rounded-lg">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h1 className="text-2xl font-bold text-destructive-foreground">Something went wrong.</h1>
          <p className="text-muted-foreground mt-2 mb-4">
            An unexpected error occurred. Please try refreshing the page.
          </p>
          {this.state.error && (
            <details className="w-full max-w-lg text-left bg-background p-2 rounded border mb-4">
                <summary className="cursor-pointer text-sm font-medium">Error Details</summary>
                <pre className="mt-2 text-xs text-muted-foreground whitespace-pre-wrap break-all">
                    {this.state.error.message}
                </pre>
            </details>
          )}
          <Button onClick={() => window.location.reload()} variant="destructive">
            Refresh Page
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

================================================================================

File: components/layout/ThreeColumnLayout.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/stores/uiStore';
import { cn } from '@/lib/utils';
import EditorHeader from '@/components/publishing/EditorHeader';

interface ThreeColumnLayoutProps {
  leftSidebar: ReactNode;
  rightSidebar: ReactNode;
  children: ReactNode;
}

export default function ThreeColumnLayout({ leftSidebar, rightSidebar, children }: ThreeColumnLayoutProps) {
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const isRightOpen = useUIStore((state) => state.sidebar.isRightOpen);

  return (
    <div className="flex h-screen w-full flex-col bg-muted/20">
      <EditorHeader />
      
      {/* This is now the positioning context for all three columns */}
      <div className="relative flex-1 overflow-hidden">
        
        {/* --- START OF FIX --- */}
        
        {/* Left Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 left-0 z-20 h-full w-72 border-r bg-background transition-transform duration-300 ease-in-out',
            isLeftOpen ? 'translate-x-0' : '-translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {leftSidebar}
          </div>
        </aside>

        {/* Main Content: The layout is now controlled by padding */}
        <main
          className={cn(
            'h-full overflow-y-auto transition-all duration-300 ease-in-out',
            // When left sidebar is open, add left padding
            isLeftOpen ? 'lg:pl-72' : 'lg:pl-0',
            // When right sidebar is open, add right padding
            isRightOpen ? 'lg:pr-80' : 'lg:pr-0'
          )}
        >
          {children}
        </main>

        {/* Right Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 right-0 z-10 h-full w-80 border-l bg-background transition-transform duration-300 ease-in-out',
            isRightOpen ? 'translate-x-0' : 'translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {rightSidebar}
          </div>
        </aside>

        {/* --- END OF FIX --- */}
      </div>
    </div>
  );
}

================================================================================

File: components/view/SiteViewer.tsx
// src/components/view/SiteViewer.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useEffect, useState, useCallback } from 'react';
import { useAppStore } from '@/stores/useAppStore';
import { resolvePageContent, PageType } from '@/lib/pageResolver';
import { render as renderWithTheme } from '@/lib/themeEngine';
import { AlertTriangle, Edit } from 'lucide-react';
import { Button } from '@/components/ui/button';
import Link from 'next/link';

/**
 * Renders a live, interactive preview of a Signum site within an iframe.
 * This component acts as a mini-SPA, controlling the browser's URL history
 * to allow for deep linking and back/forward button navigation within the preview.
 */
export default function SiteViewer() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;
  const viewRootPath = `/sites/${siteId}/view`;

  const [currentRelativePath, setCurrentRelativePath] = useState(
    pathname.replace(viewRootPath, '') || '/'
  );
  const [htmlContent, setHtmlContent] = useState<string>('<p>Loading Preview...</p>');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const site = useAppStore((state) => state.getSiteById(siteId));

  const sandboxAttributes = 
    process.env.NODE_ENV === 'development'
      ? 'allow-scripts allow-forms allow-same-origin'
      : 'allow-scripts allow-forms';


  const updateIframeContent = useCallback(async () => {
    if (!site) return;

    // This ensures we don't try to render before the site's content is loaded.
    if (!site.contentFiles) {
        console.log("SiteViewer is waiting for content files to load...");
        return;
    }

    const slugArray = currentRelativePath.split('/').filter(Boolean);
    const resolution = resolvePageContent(site, slugArray);
    
    if (resolution.type === PageType.NotFound) {
      setErrorMessage(resolution.errorMessage);
      return;
    }

    try {
      const pureHtml = await renderWithTheme(site, resolution, {
        siteRootPath: viewRootPath,
        isExport: false,
      });

      // --- START: NEW ROBUST COMMUNICATION SCRIPT ---
      const parentOrigin = typeof window !== 'undefined' ? window.location.origin : '';

      const communicationScript = `
        <script>
          // The parent component injects its own origin here. This is the key.
          const PARENT_ORIGIN = '${parentOrigin}'; 

          document.addEventListener('click', function(e) {
            const link = e.target.closest('a');

            // 1. If it's not a link, do nothing.
            if (!link || !link.href) return;
            
            // 2. If it's an in-page anchor link, let the browser handle it.
            if (link.hash && link.pathname === window.location.pathname) return;

            // 3. This is the crucial check: Does the link point to the same origin
            //    as the parent application? This works in ANY sandbox mode.
            if (link.origin === PARENT_ORIGIN) {
              e.preventDefault();
              const newPath = new URL(link.href).pathname;
              // Post the message back to the parent, specifying its own origin for security.
              window.parent.postMessage({ type: 'SIGNUM_NAVIGATE', path: newPath }, PARENT_ORIGIN);
            }
            // 4. If it's an external link (e.g., to google.com), the condition fails
            //    and the browser handles it normally (opening in a new tab if target="_blank").
          });
        <\/script>
      `;
      // --- END: NEW ROBUST COMMUNICATION SCRIPT ---

      const finalHtml = pureHtml.replace('</body>', `${communicationScript}</body>`);
      setHtmlContent(finalHtml);
      setErrorMessage(null);
    } catch (e) {
      const error = e as Error;
      console.error("Error during site rendering:", error);
      setErrorMessage(`Theme Error: ${error.message}`);
    }
  }, [site, viewRootPath, currentRelativePath]);

  // Re-render the iframe whenever the path or the site data itself changes.
  useEffect(() => {
    updateIframeContent();
  }, [updateIframeContent]);

  // This effect manages the browser history and remains unchanged.
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // Security: Only accept messages from our own origin.
      if (event.origin !== window.location.origin) return;
      
      const { type, path } = event.data;
      if (type === 'SIGNUM_NAVIGATE' && path !== window.location.pathname) {
        history.pushState({ path }, '', path);
        setCurrentRelativePath(path.replace(viewRootPath, '') || '/');
      }
    };

    const handlePopState = (event: PopStateEvent) => {
        const newPath = event.state?.path || pathname;
        setCurrentRelativePath(newPath.replace(viewRootPath, '') || '/');
    };

    window.addEventListener('message', handleMessage);
    window.addEventListener('popstate', handlePopState);

    return () => {
      window.removeEventListener('message', handleMessage);
      window.removeEventListener('popstate', handlePopState);
    };
  }, [viewRootPath, pathname]);

  if (errorMessage) {
    return (
      <div className="p-8 text-center">
        <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
        <h1 className="text-2xl font-bold mb-2">Could Not Render Preview</h1>
        <p className="text-muted-foreground">{errorMessage}</p>
        <Button asChild variant="default" className="mt-6">
          <Link href={`/sites/${siteId}/edit`}>
            <Edit className="mr-2 h-4 w-4" /> Go to Editor
          </Link>
        </Button>
      </div>
    );
  }

  return (
    <iframe
      srcDoc={htmlContent}
      title={site?.manifest.title || 'Site Preview'}
      className="w-full h-full border-0"
      sandbox={sandboxAttributes}
    />
  );
}

================================================================================

File: components/view/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; // It uses `dangerouslySetInnerHTML`, making it client-side for this pattern.
              // Alternatively, HTML parsing can be done on the server and HTML passed as prop.

import { marked } from 'marked';
import { useEffect, useMemo } from 'react'; // useMemo for parsing, useEffect if parsing were async
// Optional: Add DOMPurify for sanitization if markdown source is not 100% trusted
// import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {
        // If running in an SSR context where marked might be called without DOMPurify (if used),
        // or if you want to ensure it's only parsed once.
        // However, for this component marked as 'use client', this check is less critical
        // as it primarily renders client-side.
    }
    const rawHtml = marked.parse(markdown) as string;
    // Example of sanitization if you were to use DOMPurify:
    // if (typeof window !== 'undefined') { // DOMPurify only runs in browser
    //   return DOMPurify.sanitize(rawHtml);
    // }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Signum, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: hooks/useContentEditorState.ts
// src/hooks/useContentEditorState.ts
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useAppStore } from '@/stores/useAppStore';
import type { MarkdownFrontmatter } from '@/types';
import { findNodeByPath } from '@/lib/fileTreeUtils';
import * as localSiteFs from '@/lib/localSiteFs';
import { parseMarkdownString } from '@/lib/markdownParser';
import { NEW_FILE_SLUG_MARKER, DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';
import { toast } from 'sonner';

/**
 * Defines the possible loading states of the content editor.
 * - `initializing`: The initial state or when navigating to a new page.
 * - `loading_content`: The state when the component is waiting for site-wide content files to be loaded into the store.
 * - `ready`: The editor has all necessary data and can be rendered.
 * - `not_found`: The requested content file or its manifest entry could not be found.
 */
export type EditorStatus = 'initializing' | 'loading_content' | 'ready' | 'not_found';

/**
 * Represents the complete state required by the content editor UI to render a page.
 * This is the data payload that is delivered when the status becomes 'ready'.
 */
export interface EditorState {
  frontmatter: MarkdownFrontmatter;
  bodyContent: string;
  layoutPath: string;
  slug: string;
}

/**
 * A custom hook that orchestrates the data loading and state management
 * for the main content editor (`EditContentPage`). It handles lazy-loading,
 * file fetching, parsing, and provides a clean status and data payload to the UI,
 * preventing race conditions and loading freezes.
 *
 * This hook *reacts* to the state of the `useAppStore`. It expects that another
 * component (like `SiteLoaderLayout`) is responsible for *commanding* the store
 * to load the site data via the `loadSite` action.
 *
 * @param {string} siteId The unique identifier of the site being edited.
 * @param {string[]} slugSegments An array of URL segments that identify the content file.
 * @returns {object} An object containing the current status, the editor's state data,
 *          and other relevant information for the UI.
 */
export function useContentEditorState(siteId: string, slugSegments: string[]) {
  // Subscribe to the entire site object from the store.
  // Zustand's shallow comparison will trigger a re-render when the object is updated (e.g., when `contentFiles` is added).
  const site = useAppStore(useCallback((state) => state.getSiteById(siteId), [siteId]));

  const [status, setStatus] = useState<EditorStatus>('initializing');
  const [editorState, setEditorState] = useState<EditorState | null>(null);

  // Memoize the calculation of the mode and file path from URL segments.
  const { isNewFileMode, currentFilePath } = useMemo(() => {
    const isNewIntent = slugSegments.includes(NEW_FILE_SLUG_MARKER);
    let path = '';
    if (isNewIntent) {
      // For a new file, the path is the parent directory.
      const newMarkerIndex = slugSegments.indexOf(NEW_FILE_SLUG_MARKER);
      const parentSlug = newMarkerIndex > 0 ? slugSegments.slice(0, newMarkerIndex).join('/') : '';
      path = parentSlug ? `content/${parentSlug}` : 'content';
    } else {
      // For an existing file, construct the full file path.
      const pathParts = slugSegments.length > 0 ? slugSegments.join('/') : 'index';
      path = `content/${pathParts}.md`;
    }
    return { isNewFileMode: isNewIntent, currentFilePath: path };
  }, [slugSegments]);


  /**
   * The main state machine effect. It runs whenever the site data or URL changes.
   * It follows a clear sequence of checks to determine the editor's state.
   */
  useEffect(() => {
    console.group(`[useContentEditorState] State Machine Triggered`);
    console.log(`> Path: "${currentFilePath}", Mode: ${isNewFileMode ? 'New File' : 'Edit File'}`);

    // Always reset state on re-run to ensure a clean loading sequence.
    setStatus('initializing');
    setEditorState(null);

    const processContent = async () => {
      // --- Guard 1: Is the site object (with manifest) loaded in the store? ---
      if (!site?.manifest) {
        console.warn(`> WAITING: Site object or manifest for "${siteId}" not yet available in store.`);
        console.groupEnd();
        return;
      }
      console.log('> CHECK PASSED: Manifest is loaded.');

      // --- Guard 2: Are the site's content files loaded in the store? ---
      if (!site.contentFiles) {
        console.warn('> WAITING: Content files for this site are not yet loaded. Setting status to "loading_content".');
        setStatus('loading_content'); // This is the state the UI shows "Loading Site Content..."
        console.groupEnd();
        return;
      }
      console.log('> CHECK PASSED: Content files are loaded.');

      // --- Data is ready, proceed with processing ---
      console.log('> PROCESSING: Preparing editor state...');

      if (isNewFileMode) {
        // Handle the creation of a new, unsaved file.
        const parentNode = findNodeByPath(site.manifest.structure, currentFilePath);
        setEditorState({
          layoutPath: parentNode?.itemLayout || DEFAULT_PAGE_LAYOUT_PATH,
          frontmatter: { title: '', date: new Date().toISOString().split('T')[0], status: 'draft' },
          bodyContent: '# Start writing...',
          slug: '',
        });
        setStatus('ready');
        console.log('%c> SUCCESS: Editor state set for a new file.', 'color: green');
      } else {
        // Handle loading an existing file.
        const fileNode = findNodeByPath(site.manifest.structure, currentFilePath);
        const rawContent = await localSiteFs.getContentFileRaw(siteId, currentFilePath);

        if (fileNode && rawContent !== null) {
          const { frontmatter, content } = parseMarkdownString(rawContent);
          setEditorState({
            frontmatter,
            bodyContent: content,
            layoutPath: fileNode.layout,
            slug: fileNode.slug,
          });
          setStatus('ready');
          console.log('%c> SUCCESS: Editor state set from loaded file.', 'color: green');
        } else {
          toast.error(`Content not found at path: ${currentFilePath}`);
          setStatus('not_found');
          console.error(`%c> FAILURE: Could not find node or content for path "${currentFilePath}".`, 'color: red');
        }
      }
    };

    processContent();
    console.groupEnd();

  // This dependency array ensures the effect re-runs whenever the URL changes or the site data is updated in the store.
  }, [site, siteId, currentFilePath, isNewFileMode]);

  return {
    /** The current loading status of the editor. */
    status,
    /** The data required by the editor UI, available when status is 'ready'. */
    editorState,
    /** A function to allow the UI to update the editor's state (e.g., on title change). */
    setEditorState,
    /** A boolean indicating if the editor is for a new, unsaved file. */
    isNewFileMode,
    /** The full path of the content being edited or the parent path for a new file. */
    currentFilePath,
  };
}

================================================================================

File: hooks/useAutosave.ts
// src/hooks/useAutosave.ts
'use client';

import { useEffect, useRef } from 'react';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';

interface AutosaveParams<TData> {
  /** The generic data to be saved. */
  dataToSave: TData;
  /** A flag indicating if there are pending changes. */
  hasUnsavedChanges: boolean;
  /** A flag to prevent saving if the content isn't in a saveable state. */
  isSaveable: boolean;
  /** The function that performs the save operation with the generic data. */
  onSave: (data: TData) => Promise<void>;
}

/**
 * A generic custom hook to handle autosaving content after a specified delay.
 * It encapsulates the timer logic and effect management for saving drafts.
 */
export function useAutosave<TData>({ dataToSave, hasUnsavedChanges, isSaveable, onSave }: AutosaveParams<TData>) {
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (autosaveTimeoutRef.current) {
      clearTimeout(autosaveTimeoutRef.current);
    }

    if (hasUnsavedChanges && isSaveable) {
      autosaveTimeoutRef.current = setTimeout(() => {
        onSave(dataToSave);
      }, AUTOSAVE_DELAY);
    }

    return () => {
      if (autosaveTimeoutRef.current) {
        clearTimeout(autosaveTimeoutRef.current);
      }
    };
  }, [dataToSave, hasUnsavedChanges, isSaveable, onSave]);
}

================================================================================

File: hooks/useInitialiseUIStore.ts
'use client';

import { useUIStore } from '@/stores/uiStore';
import { useEffect } from 'react';

export function useInitialiseUIStore() {
  const initialize = useUIStore((state) => state.screen.initializeScreenSize);
  const isInitialized = useUIStore((state) => state.screen.isInitialized);

  useEffect(() => {
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);
}   

================================================================================

File: lib/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { Input } from 'gray-matter'; // Import GrayMatterOption and Input
//import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { MarkdownFrontmatter, ParsedMarkdownFile } from '@/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Signum focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: lib/pageResolver.ts
// src/lib/pageResolver.ts
import { LocalSiteData, ParsedMarkdownFile, StructureNode } from '@/types';

export enum PageType {
  SinglePage,
  Collection,
  NotFound,
}

export type PageResolutionResult = {
  type: PageType.SinglePage;
  pageTitle: string;
  contentFile: ParsedMarkdownFile;
  layoutPath: string;
} | {
  type: PageType.Collection;
  pageTitle: string;
  collectionNode: StructureNode; 
  items: ParsedMarkdownFile[];
  layoutPath: string;
} | {
  type: PageType.NotFound;
  errorMessage: string;
};

function findNodeBySlugPath(nodes: StructureNode[], slugSegments: string[]): StructureNode | null {
  if (!slugSegments || slugSegments.length === 0) {
    return nodes.find(node => node.slug === 'index' || node.path === 'content/index.md') || null;
  }

  const currentSlug = slugSegments[0];
  const remainingSlugs = slugSegments.slice(1);
  const foundNode = nodes.find(node => node.slug === currentSlug);

  if (!foundNode) return null;
  if (remainingSlugs.length === 0) return foundNode;
  if (foundNode.children) return findNodeBySlugPath(foundNode.children, remainingSlugs);

  return null;
}

export function resolvePageContent(siteData: LocalSiteData, slugArray: string[]): PageResolutionResult {
  const targetNode = findNodeBySlugPath(siteData.manifest.structure, slugArray);

  if (!targetNode) {
    return { type: PageType.NotFound, errorMessage: `Content not found for path: /${slugArray.join('/')}` };
  }

  if (targetNode.type === 'page') {
    const contentFile = siteData.contentFiles.find(f => f.path === targetNode.path);
    if (!contentFile) {
      return { type: PageType.NotFound, errorMessage: `Manifest references "${targetNode.path}" but its content file is missing.` };
    }
    return {
      type: PageType.SinglePage,
      pageTitle: targetNode.title,
      contentFile,
      layoutPath: targetNode.layout,
    };
  }

  if (targetNode.type === 'collection') {
    const items = (targetNode.children || [])
      .map(childNode => siteData.contentFiles.find(f => f.path === childNode.path))
      .filter((file): file is ParsedMarkdownFile => !!file);
        
    return {
        type: PageType.Collection,
        pageTitle: targetNode.title,
        collectionNode: targetNode,
        items,
        layoutPath: targetNode.layout,
    };
  }

  return { type: PageType.NotFound, errorMessage: `Unknown node type encountered for path: /${slugArray.join('/')}` };
}

================================================================================

File: lib/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: lib/urlUtils.ts
// src/lib/urlUtils.ts

/**
 * Generates a URL for a given site node, correctly handling the 'index' case
 * and creating paths appropriate for either static export or live preview.
 * 
 * @param node - An object representing a node in the site structure.
 * @param isExport - A boolean indicating if the URL is for a static export.
 * @returns A string representing the URL segment or full filename.
 */
export function getUrlForNode(
  node: { slug: string, path: string, type: 'page' | 'collection' },
  isExport: boolean
): string {
    const isRootIndex = node.slug === 'index' && node.type === 'page' && !node.path.includes('/');

    if (isExport) {
        // --- EXPORT PATHS ---
        if (isRootIndex) return 'index.html';
        if (node.type === 'collection') return `${node.slug}/index.html`;
        // Generates "about.html" or "posts/my-post.html"
        return `${node.path.replace(/^content\//, '').replace(/\.md$/, '')}.html`;
    }

    // --- LIVE PREVIEW PATH SEGMENTS ---
    if (isRootIndex) return ''; // The root path segment is empty
    // Generates "about" or "posts/my-post", without leading slash
    return node.path.replace(/^content\//, '').replace(/\.md$/, '').replace(/\/index$/, '');
}

================================================================================

File: lib/configHelpers.ts
// src/lib/configHelpers.ts
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { CORE_LAYOUTS, CORE_THEMES, BASE_SCHEMA } from '@/config/editorConfig';
import {
    LocalSiteData,
    Manifest,
    LayoutInfo,
    ThemeInfo,
    RawFile,
} from '@/types';

// --- Type Definitions ---

export type StrictUiSchema = UiSchema & { 'ui:groups'?: { title: string; fields: string[] }[] };
export type PartialsMap = Record<string, string>;

export type AssetFileType = 
  | 'manifest' 
  | 'base'
  | 'page'
  | 'collection-index'
  | 'collection-item'
  | 'partial' 
  | 'stylesheet' 
  | 'script' 
  | 'asset';

export interface AssetFile {
  path: string;
  type: AssetFileType;
  name?: string;
}

/** The base properties shared by both Theme and Layout manifests. */
export interface BaseAssetManifest {
  name: string;
  files: AssetFile[];
}

/** The structure of a theme.json file. */
export interface ThemeManifest extends BaseAssetManifest {
  appearanceSchema?: RJSFSchema;
}

/** The structure of a layout.json file. */
export interface LayoutManifest extends BaseAssetManifest {
  type: 'page' | 'collection';
  layoutSchema?: RJSFSchema;
  pageSchema: RJSFSchema;
  uiSchema?: StrictUiSchema;
}

/** The structure of a theme.json file. It extends the base and adds the appearance schema. */
export interface ThemeManifest extends BaseAssetManifest {
  appearanceSchema?: RJSFSchema;
}

/** The structure of a layout.json file. */
export interface LayoutManifest extends BaseAssetManifest {
  type: 'page' | 'collection';
  layoutSchema?: RJSFSchema;
  pageSchema: RJSFSchema;
  uiSchema?: StrictUiSchema;
}

type SiteDataForAssets = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;


// --- Caching and Core Helpers ---
const fileContentCache = new Map<string, Promise<string | null>>();

const isCoreTheme = (path: string) => CORE_THEMES.some((t: ThemeInfo) => t.path === path);
const isCoreLayout = (path: string) => CORE_LAYOUTS.some((l: LayoutInfo) => l.path === path);

function getBaseSchema(): { schema: RJSFSchema, uiSchema: UiSchema } {
    return BASE_SCHEMA;
}

// --- The rest of the file (getAssetContent, getJsonAsset, getLayoutManifest, etc.) remains unchanged. ---

export async function getAssetContent(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<string | null> {
    const isCore = assetType === 'theme' ? isCoreTheme(path) : isCoreLayout(path);
    const sourcePath = `/${assetType}s/${path}/${fileName}`;

    if (isCore) {
      if (fileContentCache.has(sourcePath)) {
        return fileContentCache.get(sourcePath)!;
      }
      const promise = fetch(sourcePath)
        .then(res => {
          if (!res.ok) return null;
          const contentType = res.headers.get('content-type');
          if (contentType && contentType.includes('text/html')) return null;
          return res.text();
        })
        .catch(() => null);
      fileContentCache.set(sourcePath, promise);
      return promise;
    } else {
      const fileStore: RawFile[] | undefined = assetType === 'theme' ? siteData.themeFiles : siteData.layoutFiles;
      const fullPath = `${assetType}s/${path}/${fileName}`;
      return fileStore?.find(f => f.path === fullPath)?.content ?? null;
    }
}

export async function getJsonAsset<T>(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<T | null> {
    const content = await getAssetContent(siteData, assetType, path, fileName);
    if (!content) return null;
    try {
      return JSON.parse(content) as T;
    } catch (e) {
      console.error(`Failed to parse JSON from ${assetType}/${path}/${fileName}:`, e);
      return null;
    }
}

function mergeSchemas(base: RJSFSchema, specific?: RJSFSchema): RJSFSchema {
    if (!specific) return { ...base };
    return {
        ...base,
        ...specific,
        properties: { ...(base.properties || {}), ...(specific.properties || {}) },
        required: [...new Set([...(base.required || []), ...(specific.required || [])])]
    };
}

// --- Public API ---

export function getAvailableLayouts(manifest?: Manifest): LayoutInfo[] {
  const available = [...CORE_LAYOUTS];
  if (manifest?.layouts) {
    const customLayouts = manifest.layouts.filter(cl => !available.some(coreL => coreL.path === cl.path));
    available.push(...customLayouts);
  }
  return available;
}

export function getAvailableThemes(manifest?: Manifest): ThemeInfo[] {
  const available = [...CORE_THEMES];
  if (manifest?.themes) {
    const customThemes = manifest.themes.filter(ct => !available.some(coreT => coreT.path === ct.path));
    available.push(...customThemes);
  }
  return available;
}

export async function getLayoutManifest(siteData: SiteDataForAssets, layoutPath: string): Promise<LayoutManifest | null> {
    const layoutManifest = await getJsonAsset<LayoutManifest>(siteData, 'layout', layoutPath, 'layout.json');
    const baseSchemaData = getBaseSchema();

    if (!layoutManifest) {
      return {
          name: layoutPath,
          type: 'page',
          pageSchema: baseSchemaData.schema,
          uiSchema: baseSchemaData.uiSchema,
          files: []
      }
    }

    layoutManifest.pageSchema = mergeSchemas(baseSchemaData.schema, layoutManifest.pageSchema);
    layoutManifest.uiSchema = { ...(baseSchemaData.uiSchema || {}), ...(layoutManifest.uiSchema || {}) };

    if (layoutManifest.pageSchema?.properties) {
      delete layoutManifest.pageSchema.properties.title;
      delete layoutManifest.pageSchema.properties.description;
      delete layoutManifest.pageSchema.properties.slug;
    }
    if (layoutManifest.layoutSchema?.properties) {
        delete layoutManifest.layoutSchema.properties.title;
        delete layoutManifest.layoutSchema.properties.description;
    }

    return layoutManifest;
}

================================================================================

File: lib/siteExporter.ts
// src/lib/siteExporter.ts
import JSZip from 'jszip';
import { LocalSiteData, ParsedMarkdownFile, StructureNode } from '@/types';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { flattenStructureToRenderableNodes } from './fileTreeUtils';
import { resolvePageContent, PageType } from './pageResolver';
import { render } from './themeEngine';
import { getUrlForNode } from './urlUtils';
import { getAssetContent, getJsonAsset, ThemeManifest, LayoutManifest } from './configHelpers'; 

/**
 * Escapes special XML characters in a string to make it safe for RSS/Sitemap feeds.
 * @param {unknown} str - The input string to escape.
 * @returns {string} The escaped string.
 */
function escapeForXml(str: unknown): string {
    if (str === undefined || str === null) return '';
    return String(str)
        .replace(/&/g, '&')
        .replace(/</g, '<')
        .replace(/>/g, '>')
        .replace(/"/g, '"')
        .replace(/'/g, "'");
}

/**
 * A helper function to find all files for a given asset (theme or layout)
 * by reading its manifest's `files` array, and then add them to the ZIP archive.
 * This ensures that core and custom assets are bundled with the site.
 *
 * @param {JSZip} zip - The JSZip instance to add files to.
 * @param {LocalSiteData} siteData - The complete site data, including any custom asset files.
 * @param {'theme' | 'layout'} assetType - The type of asset to bundle.
 * @param {string} assetPath - The path/ID of the asset (e.g., 'default' or 'my-custom-theme').
 */
async function bundleAsset(zip: JSZip, siteData: LocalSiteData, assetType: 'theme' | 'layout', assetPath: string) {
    const assetFolder = zip.folder('_signum')?.folder(`${assetType}s`)?.folder(assetPath);
    if (!assetFolder) return;

    // 1. Fetch the manifest for the asset (e.g., theme.json or layout.json).
    const manifest = await getJsonAsset<ThemeManifest | LayoutManifest>(siteData, assetType, assetPath, `${assetType}.json`);
    
    // 2. If the manifest has a 'files' array, iterate through it. This is our source of truth.
    if (!manifest || !manifest.files) {
        console.warn(`Asset manifest for ${assetType}/${assetPath} is missing or has no 'files' array. Skipping bundle.`);
        return;
    }

    // 3. For each file listed in the manifest, fetch its content and add it to the ZIP.
    for (const file of manifest.files) {
        const content = await getAssetContent(siteData, assetType, assetPath, file.path);
        if (content) {
            assetFolder.file(file.path, content);
        } else {
            console.warn(`Could not find content for declared file: ${assetType}s/${assetPath}/${file.path}`);
        }
    }
}


/**
 * Compiles a full Signum site into a downloadable ZIP archive, ready for deployment.
 * This function orchestrates HTML generation, source file packaging, asset bundling, and feed creation.
 *
 * @param {LocalSiteData} siteData - The complete, in-memory representation of the site.
 * @returns {Promise<Blob>} A promise that resolves to a Blob containing the ZIP archive.
 */
export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
    const zip = new JSZip();
    const { manifest } = siteData;
    const allRenderableNodes = flattenStructureToRenderableNodes(manifest.structure);

    // --- 1. Generate All HTML Pages ---
    for (const node of allRenderableNodes) {
        const slugArray = (node.type === 'collection') ? [node.slug] : node.path.replace(/^content\//, '').replace(/\.md$/, '').split('/').filter(Boolean);
        const resolution = resolvePageContent(siteData, slugArray);
        if (resolution.type === PageType.NotFound) continue;
        
        const outputPath = getUrlForNode({ ...node, type: node.type as 'page' | 'collection' }, true);
        
        // Calculate the relative path depth for portable asset links (e.g., '../' or './').
        const depth = (outputPath.match(/\//g) || []).length;
        const relativePrefix = '../'.repeat(depth);

        // Render the final HTML, passing the correct export options.
        const finalHtml = await render(siteData, resolution, {
            siteRootPath: '/',
            isExport: true,
            relativeAssetPath: relativePrefix
        });
        zip.file(outputPath, finalHtml);
    }

    // --- 2. Add _signum Source Content and Asset Files ---
    const signumFolder = zip.folder('_signum');
    if (signumFolder) {
        // Add the main site manifest and all markdown content files.
        signumFolder.file('manifest.json', JSON.stringify(manifest, null, 2));
        (siteData.contentFiles ?? []).forEach(file => {
            signumFolder.file(file.path, stringifyToMarkdown(file.frontmatter, file.content));
        });
    }

    // Bundle the active theme and all layouts used by the site.
    const activeThemePath = manifest.theme.name;
    const uniqueLayoutPaths = [...new Set(allRenderableNodes.map(n => n.layout))];

    await bundleAsset(zip, siteData, 'theme', activeThemePath);
    for (const layoutPath of uniqueLayoutPaths) {
        await bundleAsset(zip, siteData, 'layout', layoutPath);
    }
    
    // --- 3. Generate RSS Feed and Sitemap with Absolute URLs ---
    const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
    const contentFiles = siteData.contentFiles ?? [];
    const allPageNodes = allRenderableNodes.filter((n: StructureNode): n is StructureNode & { type: 'page' } => n.type === 'page');
    type RssItemData = { node: StructureNode, file: ParsedMarkdownFile };

    // Create RSS items
    const rssItems = allPageNodes.map((pNode): RssItemData | null => {
            const file = contentFiles.find(f => f.path === pNode.path);
            return file ? { node: pNode, file } : null;
        })
        .filter((item): item is RssItemData => item !== null && !!item.file.frontmatter.date)
        .sort((a, b) => new Date(b.file.frontmatter.date as string).getTime() - new Date(a.file.frontmatter.date as string).getTime())
        .slice(0, 20)
        .map((item) => {
            const relativeUrl = getUrlForNode(item.node, true);
            const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
            const description = escapeForXml(item.file.frontmatter.summary);
            const pubDate = new Date(item.file.frontmatter.date as string).toUTCString();
            return `<item><title>${escapeForXml(item.node.title)}</title><link>${escapeForXml(absoluteUrl)}</link><guid isPermaLink="true">${escapeForXml(absoluteUrl)}</guid><pubDate>${pubDate}</pubDate><description>${description}</description></item>`;
        }).join('');

    const rssFeed = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(manifest.title)}</title><link>${siteBaseUrl}</link><description>${escapeForXml(manifest.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrl).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;
    zip.file('rss.xml', rssFeed);
    
    // Create Sitemap URLs
    const sitemapUrls = allPageNodes.map((node) => {
        const file = contentFiles.find(f => f.path === node.path);
        const relativeUrl = getUrlForNode(node, true);
        const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
        const lastMod = (file?.frontmatter.date as string || new Date().toISOString()).split('T')[0];
        return `<url><loc>${escapeForXml(absoluteUrl)}</loc><lastmod>${lastMod}</lastmod></url>`;
    }).join('');

    const sitemapXml = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
    zip.file('sitemap.xml', sitemapXml);

    // --- 4. Generate the Final ZIP file ---
    return zip.generateAsync({ type: 'blob' });
}

================================================================================

File: lib/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: lib/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { LocalSiteData, ParsedMarkdownFile, Manifest } from '@/types';
import { parseMarkdownString } from './markdownParser';
import { flattenStructureToPages } from './fileTreeUtils';

async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const url = new URL(filePath, baseUrl).href;
  const response = await fetch(url, { cache: 'no-store' });
  if (!response.ok) {
    throw new Error(`Fetch failed for ${url}: ${response.statusText}`);
  }
  return response.text();
}

/**
 * Fetches and reconstructs an entire remote Signum site into the LocalSiteData format.
 * It fetches the manifest, then fetches all content files listed within it.
 * @param remoteSiteUrl The base URL of the remote Signum site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json, which is now the single source of truth.
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_signum/manifest.json');
    const manifest: Manifest = JSON.parse(manifestString);

    if (!manifest || !manifest.siteId || !manifest.structure) {
        throw new Error("Invalid manifest structure fetched from remote site.");
    }
    
    // 2. Collect all unique file paths from the manifest structure.
    const allPageNodes = flattenStructureToPages(manifest.structure);
    const contentFilePaths = [...new Set(allPageNodes.map(node => node.path))];

    // 3. Fetch all content files in parallel.
    const contentFilesPromises = contentFilePaths.map(async (path) => {
        try {
            const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, `_signum/${path}`);
            const { frontmatter, content } = parseMarkdownString(rawMarkdown);
            const slug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
            return { slug, path, frontmatter, content };
        } catch (error) {
            console.warn(`Could not fetch or parse content file: ${path}`, error);
            return null; // Return null on failure for this specific file
        }
    });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];

    // 4. Construct the final LocalSiteData object.
    const finalSiteData: LocalSiteData = {
      siteId: `remote-${manifest.siteId}`, // Prefix to distinguish in local state
      manifest: manifest,
      contentFiles: validContentFiles,
    };

    return finalSiteData;

  } catch (error) {
    console.error(`CRITICAL ERROR fetching remote site data for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

File: lib/fileTreeUtils.ts
// src/lib/fileTreeUtils.ts
import { StructureNode } from '@/types';

/**
 * Finds a node in a structure tree by its exact `path`.
 * @param nodes The array of nodes to search within.
 * @param path The path of the node to find (e.g., "content/blog/first-post.md").
 * @returns The found StructureNode or undefined.
 */
export function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) {
      return node;
    }
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) {
        return found;
      }
    }
  }
  return undefined;
}

/**
 * Recursively traverses the structure tree and collects all nodes that are pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all page-type StructureNodes.
 */
export function flattenStructureToPages(nodes: StructureNode[]): StructureNode[] {
  let pages: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page') {
      pages.push(node);
    }
    if (node.children) {
      pages = pages.concat(flattenStructureToPages(node.children));
    }
  }
  return pages;
}

/**
 * Recursively traverses the structure tree and collects all nodes that can be rendered as a page.
 * This includes single pages AND collection listing pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all renderable StructureNodes.
 */
export function flattenStructureToRenderableNodes(nodes: StructureNode[]): StructureNode[] {
  let renderableNodes: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page' || node.type === 'collection') {
      renderableNodes.push(node);
    }
    if (node.children) {
      renderableNodes = renderableNodes.concat(flattenStructureToRenderableNodes(node.children));
    }
  }
  return renderableNodes;
}

/**
 * Gets the parent directory path for a given file path.
 * e.g., "content/blog/post.md" -> "content/blog"
 * @param path The full path of a file or folder.
 * @returns The path of the parent directory.
 */
export function getParentPath(path: string): string {
  if (!path.includes('/')) return 'content';
  return path.substring(0, path.lastIndexOf('/'));
}

================================================================================

File: lib/themeEngine.ts
// src/lib/themeEngine.ts
import Handlebars from 'handlebars';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import { PageResolutionResult, PageType } from './pageResolver';
import { 
    LocalSiteData, 
    ParsedMarkdownFile, 
    ThemeInfo, 
    LayoutInfo 
} from '@/types';
import { generateNavLinks } from './navigationUtils';
import { getJsonAsset, getLayoutManifest, ThemeManifest, LayoutManifest, AssetFile, AssetFileType } from './configHelpers';
import { CORE_THEMES, CORE_LAYOUTS } from '@/config/editorConfig';
import { getUrlForNode } from './urlUtils';
import { getRelativePath } from './pathUtils';

// --- Type Definitions ---

/**
 * @interface RenderOptions
 * @description Defines the configuration for a single render operation.
 */
export interface RenderOptions {
  /** The base path for generated links in live preview mode (e.g., /sites/abc/view). */
  siteRootPath: string;
  /** Determines if paths should be relative (for export) or absolute-style (for live preview). */
  isExport: boolean;
  /** For exports, the relative path to the asset root (e.g., '../' or './'). */
  relativeAssetPath?: string;
}

// --- Caching and Core Helpers ---

const fileContentCache = new Map<string, Promise<string | null>>();
let helpersRegistered = false;

const isCoreTheme = (path: string): boolean => CORE_THEMES.some((t: ThemeInfo) => t.path === path);
const isCoreLayout = (path: string): boolean => CORE_LAYOUTS.some((l: LayoutInfo) => l.path === path);

/**
 * Fetches the raw string content of a theme or layout asset.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {'theme' | 'layout'} assetType - The type of asset to fetch.
 * @param {string} path - The path/ID of the theme or layout (e.g., 'default').
 * @param {string} fileName - The name of the file to fetch (e.g., 'base.hbs').
 * @returns {Promise<string | null>} The raw file content or null if not found.
 */
async function getAssetContent(siteData: LocalSiteData, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<string | null> {
    const isCore = assetType === 'theme' ? isCoreTheme(path) : isCoreLayout(path);
    const sourcePath = `/${assetType}s/${path}/${fileName}`;

    if (isCore) {
      if (fileContentCache.has(sourcePath)) return fileContentCache.get(sourcePath)!;
      const promise = fetch(sourcePath)
        .then(res => (res.ok ? res.text() : null))
        .catch(() => null);
      fileContentCache.set(sourcePath, promise);
      return promise;
    } else {
      const fileStore = assetType === 'theme' ? siteData.themeFiles : siteData.layoutFiles;
      const fullPath = `${assetType}s/${path}/${fileName}`;
      return fileStore?.find(f => f.path === fullPath)?.content ?? null;
    }
}

/**
 * Fetches and compiles a Handlebars template from an asset file.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {'theme' | 'layout'} assetType - The type of asset to fetch.
 * @param {string} path - The path/ID of the theme or layout.
 * @param {string} fileName - The name of the Handlebars template file.
 * @returns {Promise<Handlebars.TemplateDelegate | null>} The compiled template or null on failure.
 */
async function getTemplateAsset(siteData: LocalSiteData, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<Handlebars.TemplateDelegate | null> {
    const source = await getAssetContent(siteData, assetType, path, fileName);
    if (!source) return null;
    try { 
        return Handlebars.compile(source); 
    } catch(e) { 
        console.error(`Failed to compile Handlebars template ${assetType}/${path}/${fileName}:`, e); 
        return null; 
    }
}

/**
 * Registers all partials declared in a theme or layout manifest by reading the 'files' array.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {ThemeManifest | LayoutManifest | null} manifest - The manifest object containing the files array.
 * @param {'theme' | 'layout'} assetType - The type of asset the partials belong to.
 * @param {string} assetPath - The path/ID of the theme or layout.
 */
async function registerPartialsFromManifest(siteData: LocalSiteData, manifest: ThemeManifest | LayoutManifest | null, assetType: 'theme' | 'layout', assetPath: string) {
    if (!manifest || !manifest.files) return;
    const partials = manifest.files.filter(file => file.type === 'partial');

    for (const partial of partials) {
        if (partial.name) {
            const templateSource = await getAssetContent(siteData, assetType, assetPath, partial.path);
            if (templateSource) {
                Handlebars.registerPartial(partial.name, templateSource);
            }
        }
    }
}

/**
 * Registers global Handlebars helpers. Ensures helpers are only registered once.
 */
function registerHelpers() {
    if (helpersRegistered) return;
    Handlebars.registerHelper('eq', (a, b) => a === b);
    Handlebars.registerHelper('formatDate', (date) => (date ? new Date(date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : ''));
    Handlebars.registerHelper('markdown', (md) => {
        if (!md) return '';
        const unsafeHtml = marked.parse(md, { async: false }) as string;
        const safeHtml = DOMPurify.sanitize(unsafeHtml);
        return new Handlebars.SafeString(safeHtml);
    });
    helpersRegistered = true;
}


/**
 * Renders a resolved page or collection into a full HTML string based on the active theme and layout.
 * This is the main public function of the theme engine. It handles both live previews and static exports.
 *
 * @param {LocalSiteData} siteData - The complete data for the site to be rendered.
 * @param {PageResolutionResult} resolution - The resolved content (page or collection) to render.
 * @param {RenderOptions} options - Configuration for the render, specifying context (preview vs. export).
 * @returns {Promise<string>} A promise that resolves to the final, complete HTML document string.
 */
export async function render(siteData: LocalSiteData, resolution: PageResolutionResult, options: RenderOptions): Promise<string> {
  // 1. Setup & Validation
  registerHelpers();
  fileContentCache.clear();
  Object.keys(Handlebars.partials).forEach(name => Handlebars.unregisterPartial(name));

  if (!siteData.contentFiles) {
    return 'Error: Site content has not been loaded. Cannot render page.';
  }

  const { manifest } = siteData;
  const themePath = manifest.theme.name;

  if (resolution.type === PageType.NotFound) return `<h1>Error</h1><p>${resolution.errorMessage}</p>`;
  if (!themePath) return 'Error: Site manifest has no theme specified.';
  
  const layoutPath = resolution.layoutPath;
  
  // 2. Load Manifests and Partials
  const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', themePath, 'theme.json');
  const layoutManifest = await getLayoutManifest(siteData, layoutPath);
  await registerPartialsFromManifest(siteData, themeManifest, 'theme', themePath);
  await registerPartialsFromManifest(siteData, layoutManifest, 'layout', layoutPath);
  
  // 3. Prepare Data for Rendering
  const currentPageExportPath = getUrlForNode(
      resolution.type === PageType.SinglePage ? { ...resolution.contentFile, type: 'page' } : { ...resolution.collectionNode, type: 'collection' },
      true
  );

  if (resolution.type === PageType.Collection) {
    // ... (sorting logic is unchanged) ...
    resolution.items = resolution.items.map(item => {
        const targetUrlSegment = getUrlForNode({ ...item, type: 'page' }, options.isExport);
        const itemUrl = options.isExport ? getRelativePath(currentPageExportPath, targetUrlSegment) : `${options.siteRootPath}/${targetUrlSegment}`;
        return { ...item, url: itemUrl };
    });
  }

  // 4. Render Main Content Body
  const findTemplatePath = (manifest: ThemeManifest | LayoutManifest | null, type: string) => manifest?.files?.find(f => f.type === type)?.path;
  const mainTemplateType = resolution.type === PageType.Collection ? 'collection-index' : (layoutManifest?.type === 'collection' ? 'collection-item' : 'page');
  const mainTemplatePath = findTemplatePath(layoutManifest, mainTemplateType);
  if (!mainTemplatePath) return `Error: Layout '${layoutPath}' is missing a template with type '${mainTemplateType}'.`;
  const layoutTemplate = await getTemplateAsset(siteData, 'layout', layoutPath, mainTemplatePath);
  const bodyHtml = layoutTemplate ? layoutTemplate(resolution) : `Error: Could not render template at '${mainTemplatePath}'.`;
  
  // 5. Prepare the Final Context for the Base Template
  const navLinks = generateNavLinks(siteData, currentPageExportPath, options);
  const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
  const canonicalUrl = new URL(currentPageExportPath, siteBaseUrl).href;

  let styleOverrides = '';
  const themeConfig = manifest.theme.config;
  if (themeConfig && Object.keys(themeConfig).length > 0) {
      const cssVars = Object.entries(themeConfig)
          .map(([key, value]) => `--${key.replace(/_/g, '-')}: ${value};`)
          .join(' ');
      if (cssVars) {
          styleOverrides = `<style id="signum-theme-overrides">:root { ${cssVars} }</style>`;
      }
  }
  
  const baseUrl = options.isExport ? '' : (typeof window !== 'undefined' ? window.location.origin : '');

  // 6. Render the Final HTML Document
  const baseTemplatePath = findTemplatePath(themeManifest, 'base');
  if (!baseTemplatePath) return 'Error: Active theme is missing a template with type "base".';
  const baseTemplate = await getTemplateAsset(siteData, 'theme', themePath, baseTemplatePath);
  if (!baseTemplate) return `Error: Could not render base template at '${baseTemplatePath}'.`;

  const headContext = {
      pageTitle: resolution.pageTitle,
      manifest: manifest,
      canonicalUrl: canonicalUrl,
      baseUrl: baseUrl,
      styleOverrides: new Handlebars.SafeString(styleOverrides)
  };

  return baseTemplate({
      manifest,
      navLinks,
      year: new Date().getFullYear(),
      headContext: headContext,
      body: new Handlebars.SafeString(bodyHtml),
  });
}

================================================================================

File: lib/localSiteFs.ts
// src/lib/localSiteFs.ts
import { LocalSiteData, Manifest, ParsedMarkdownFile, RawFile } from '@/types'; // Ensure RawFile is imported
import localforage from 'localforage';
import { parseMarkdownString, stringifyToMarkdown } from './markdownParser';

const DB_NAME = 'SignumDB';

const siteManifestsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteManifests',
});

const siteContentFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteContentFiles',
});

const siteLayoutFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteLayoutFiles',
});

const siteThemeFilesStore = localforage.createInstance({
    name: DB_NAME,
    storeName: 'siteThemeFiles',
});

// --- Function to load only manifests for a fast initial load ---
export async function loadAllSiteManifests(): Promise<Manifest[]> {
  const manifests: Manifest[] = [];
  await siteManifestsStore.iterate((value: Manifest) => {
    manifests.push(value);
  });
  return manifests;
}

/**
 * Fetches the manifest for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<Manifest | null>} A Promise that resolves to the Manifest object, or null if not found.
 */
export async function getManifestById(siteId: string): Promise<Manifest | null> {
  const manifest = await siteManifestsStore.getItem<Manifest>(siteId);
  return manifest ?? null;
}

/**
 * Fetches the content files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<ParsedMarkdownFile[]>} A Promise that resolves to an array of parsed markdown files.
 */
export async function getSiteContentFiles(siteId: string): Promise<ParsedMarkdownFile[]> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId);
    return contentFiles ?? [];
}

// --- START OF NEW FUNCTIONS TO FIX THE ERRORS ---

/**
 * Fetches the custom layout files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw layout files.
 */
export async function getSiteLayoutFiles(siteId: string): Promise<RawFile[]> {
    const layoutFiles = await siteLayoutFilesStore.getItem<RawFile[]>(siteId);
    return layoutFiles ?? [];
}

/**
 * Fetches the custom theme files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw theme files.
 */
export async function getSiteThemeFiles(siteId: string): Promise<RawFile[]> {
    const themeFiles = await siteThemeFilesStore.getItem<RawFile[]>(siteId);
    return themeFiles ?? [];
}

// --- END OF NEW FUNCTIONS ---


export async function saveSite(siteData: LocalSiteData): Promise<void> {
  await Promise.all([
    siteManifestsStore.setItem(siteData.siteId, siteData.manifest),
    siteContentFilesStore.setItem(siteData.siteId, siteData.contentFiles ?? []),
    siteLayoutFilesStore.setItem(siteData.siteId, siteData.layoutFiles ?? []),
    siteThemeFilesStore.setItem(siteData.siteId, siteData.themeFiles ?? []),
  ]);
}

export async function deleteSite(siteId: string): Promise<void> {
  await Promise.all([
    siteManifestsStore.removeItem(siteId),
    siteContentFilesStore.removeItem(siteId),
    siteLayoutFilesStore.removeItem(siteId),
    siteThemeFilesStore.removeItem(siteId),
  ]);
}

export async function saveManifest(siteId: string, manifest: Manifest): Promise<void> {
    await siteManifestsStore.setItem(siteId, manifest);
}

export async function saveContentFile(siteId: string, filePath: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    
    const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
    const fileSlug = filePath.substring(filePath.lastIndexOf('/') + 1).replace('.md', '');
    const savedFile: ParsedMarkdownFile = { slug: fileSlug, path: filePath, frontmatter, content };

    const fileIndex = contentFiles.findIndex(f => f.path === filePath);
    if (fileIndex > -1) {
      contentFiles[fileIndex] = savedFile;
    } else {
      contentFiles.push(savedFile);
    }
    
    await siteContentFilesStore.setItem(siteId, contentFiles);
    return savedFile;
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const updatedContentFiles = contentFiles.filter(f => f.path !== filePath);
    await siteContentFilesStore.setItem(siteId, updatedContentFiles);
}

export async function getContentFileRaw(siteId: string, filePath: string): Promise<string | null> {
    const allFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const fileData = allFiles.find(f => f.path === filePath);
    if (!fileData) return null;
    
    return stringifyToMarkdown(fileData.frontmatter, fileData.content);
}

================================================================================

File: lib/navigationUtils.ts
// src/lib/navigationUtils.ts
import { LocalSiteData, NavLinkItem, StructureNode } from '@/types';
import { getUrlForNode } from './urlUtils';
import { getRelativePath } from './pathUtils';
import { RenderOptions } from './themeEngine'; // <-- IMPORT RENDER OPTIONS

/**
 * Recursively builds a navigation link structure with context-aware paths.
 * @param nodes - The site structure nodes to build links from.
 * @param currentPagePath - The path of the page being currently rendered.
 * @param options - The render options, containing isExport and siteRootPath.
 * @returns An array of navigation link objects.
 */
function buildNavLinks(nodes: StructureNode[], currentPagePath: string, options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>): NavLinkItem[] {
  return nodes
    .filter(node => node.navOrder !== undefined)
    .sort((a, b) => (a.navOrder || 0) - (b.navOrder || 0))
    .map(node => {
      let href: string;
      const urlSegment = getUrlForNode(node, options.isExport);

      if (options.isExport) {
        // EXPORT MODE: Calculate a portable, document-relative path.
        href = getRelativePath(currentPagePath, urlSegment);
      } else {
        // PREVIEW MODE: Construct a full, absolute-style path for the SPA viewer.
        // e.g., /sites/signum-e1bry/view + / + about -> /sites/signum-e1bry/view/about
        href = `${options.siteRootPath}${urlSegment ? `/${urlSegment}` : ''}`;
      }
      
      return {
        href: href,
        label: node.title,
        children: node.children ? buildNavLinks(node.children, currentPagePath, options) : [],
      };
    });
}

/**
 * Generates the complete navigation structure for a given page.
 * @param siteData - The complete site data.
 * @param currentPagePath - The path of the HTML page being rendered (for relative calculations).
 * @param options - The full render options object.
 * @returns The final array of navigation links.
 */
export function generateNavLinks(
  siteData: LocalSiteData,
  currentPagePath: string,
  options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  const { structure } = siteData.manifest;
  return buildNavLinks(structure, currentPagePath, options);
}

================================================================================

File: lib/pathUtils.ts
// src/lib/pathUtils.ts

/**
 * Calculates the relative path from one file to another.
 * This is essential for creating portable HTML that works on any server
 * or directly from the local file system.
 *
 * @example
 * // from 'index.html' to 'about.html' -> './about.html'
 * getRelativePath('index.html', 'about.html');
 *
 * @example
 * // from 'posts/post1.html' to 'index.html' -> '../index.html'
 * getRelativePath('posts/post1.html', 'index.html');
 *
 * @example
 * // from 'posts/post1.html' to 'tags/tech.html' -> '../tags/tech.html'
 * getRelativePath('posts/post1.html', 'tags/tech.html');
 *
 * @param {string} fromPath - The path of the file containing the link.
 * @param {string} toPath - The path of the file being linked to.
 * @returns {string} The calculated relative path.
 */
export function getRelativePath(fromPath: string, toPath: string): string {
  if (fromPath === toPath) {
    return toPath.split('/').pop() || '';
  }

  const fromParts = fromPath.split('/').slice(0, -1); // Path without filename
  const toParts = toPath.split('/');

  // Find the common path segment
  let commonLength = 0;
  while (
    commonLength < fromParts.length &&
    commonLength < toParts.length &&
    fromParts[commonLength] === toParts[commonLength]
  ) {
    commonLength++;
  }

  const upLevels = fromParts.length - commonLength;
  const upPath = '../'.repeat(upLevels) || './';

  const downPath = toParts.slice(commonLength).join('/');

  return upPath + downPath;
}

================================================================================

