FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: ios, node_modules, public
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html, *.json, *.hbs
================================================================================

File: types/index.ts
// src/types/index.ts
import { SiteSecrets } from '@/core/services/siteSecrets.service';

/**
 * Represents a node in the site's hierarchical structure, as defined in `manifest.json`.
 * Every node is a page, which can have child pages nested under it.
 * Whether a page acts as a "Collection Page" is determined by its frontmatter,
 * not by a property on this node.
 */
export interface StructureNode {
  type: 'page'; // The 'type' is now always 'page'.
  title: string;
  menuTitle?: string;
  path: string; // The full path to the .md file (e.g., 'content/blog.md').
  slug: string; // The URL-friendly version of the path (e.g., 'blog').
  navOrder?: number;
  children?: StructureNode[];
  [key: string]: unknown;
}

/**
 * Represents the theme configuration saved in the manifest, including
 * the theme's name and any user-defined overrides.
 */
export interface ThemeConfig {
  name: string;
  config: {
    [key: string]: string | boolean | number;
  };
}

/**
 * Represents metadata for a layout asset, used for populating UI selectors.
 */
export interface LayoutInfo {
  id: string;
  name: string;
  type: 'page' | 'list' | 'item';
  path: string;
  description?: string;
}

/**
 * Represents metadata for a theme asset, used for populating UI selectors.
 */
export interface ThemeInfo {
  id: string;
  name: string;
  path: string;
}

/**
 * Defines the structure for a remote data source query (future feature).
 */
export interface DataSourceConfig {
  url: string;
  format: 'json' | 'csv';
  array_path?: string; // e.g., "results.items" for nested JSON
}



export interface CollectionConfig {
  item_layout: string;
  item_page_layout: string; 
  sort_by?: string;
  sort_order?: 'asc' | 'desc';
  items_per_page?: number;
  // Future: filter config
}


/**
 * Represents the fields within a content file's YAML frontmatter.
 */
export interface MarkdownFrontmatter {
  title: string;
  layout: string; 
  collection?: CollectionConfig;
  homepage?: boolean;
  [key: string]: unknown;
}

/**
 * Represents a raw markdown file that has been parsed from storage into its constituent parts.
 */
export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

/**
 * Represents a generic raw file (e.g., theme CSS, layout JSON) read from storage.
 */
export interface RawFile {
  path: string;
  content: string;
}

/**
 * Represents the data required for rendering pager controls.
 */
export interface PaginationData {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    hasPrevPage: boolean;
    hasNextPage: boolean;
    prevPageUrl?: string;
    nextPageUrl?: string;
}

/**
 * Represents the main `manifest.json` file for a single site. This is the
 * top-level configuration and site map.
 */
export interface Manifest {
  siteId: string;
  generatorVersion: string;
  title: string;
  description: string;
  author?: string;
  baseUrl?: string;
  theme: ThemeConfig;
  structure: StructureNode[];
  layouts?: LayoutInfo[];
  themes?: ThemeInfo[];
  logo?: ImageRef;
  favicon?: ImageRef;
  settings?: {
    imageService?: 'local' | 'cloudinary';
    [key: string]: any; // Allow for other future settings
  };
}

/**
 * Represents the complete data for a single site when held in the application's memory.
 */
export interface LocalSiteData {
  siteId: string;
  manifest: Manifest;
  contentFiles?: ParsedMarkdownFile[];
  layoutFiles?: RawFile[];
  themeFiles?: RawFile[];
  secrets?: SiteSecrets;
  // Future: viewFiles?: RawFile[]
}

/**
 * Represents a link used for rendering navigation menus.
 * This is a derived type, not part of the core manifest data.
 */
export interface NavLinkItem {
  href: string;
  label: string;
  isActive?: boolean;
  children?: NavLinkItem[];
}

/**
 * An enum to clearly distinguish the outcome of a page resolution attempt.
 */
export enum PageType {
  SinglePage,
  NotFound,
}

/**
 * Represents the complete, resolved data package for a single page render.
 * This object is the output of the pageResolver and the input for the themeEngine.
 */
export type PageResolutionResult = {
  type: PageType.SinglePage;
  pageTitle: string;
  contentFile: ParsedMarkdownFile;
  layoutPath: string;
  collectionItems?: ParsedMarkdownFile[]; 
  pagination?: PaginationData;
} | {
  type: PageType.NotFound;
  errorMessage: string;
};


/** The storable reference to an uploaded image. This goes in frontmatter. */
export interface ImageRef {
  serviceId: 'local' | 'cloudinary';
  src: string;
  alt?: string;
  width?: number;
  height?: number;
}

/** Transformation options requested by a template's image helper. */
export interface ImageTransformOptions {
  width?: number;
  height?: number;
  // --- FIX: Adopt Cloudinary's 'crop' and 'gravity' terminology ---
  crop?: 'fill' | 'fit' | 'scale'; // 'scale' is a simple resize, 'fit' is letterbox, 'fill' is crop
  gravity?: 'center' | 'north' | 'south' | 'east' | 'west' | 'auto';
  format?: 'webp' | 'avif' | 'jpeg';
}

/** The interface/contract that all image services must implement. */
export interface ImageService {
  id: string;
  name: string;
  upload(file: File, siteId: string): Promise<ImageRef>;
  getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions, isExport: boolean): Promise<string>;
  getExportableAssets(siteId: string, allImageRefs: ImageRef[]): Promise<{ path: string; data: Blob; }[]>;
}

================================================================================

File: core/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/state/uiStore.ts
// src/core/state/uiStore.ts

import { create, StateCreator } from 'zustand';
import { ReactNode } from 'react';

// --- Helper for screen size ---
const isDesktopView = () => typeof window !== 'undefined' && window.innerWidth >= 1024;

// --- Type Definitions for the store structure ---

// Defines the shape of the data in the sidebar slice
interface SidebarState {
  isLeftOpen: boolean;
  isRightOpen: boolean;
  isLeftAvailable: boolean;
  isRightAvailable: boolean;
  leftSidebarContent: ReactNode | null;
  rightSidebarContent: ReactNode | null;
}

// Defines the actions available in the sidebar slice
interface SidebarActions {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  setLeftAvailable: (available: boolean) => void;
  setRightAvailable: (available: boolean) => void;
  setRightOpen: (isOpen: boolean) => void;
  setLeftSidebarContent: (content: ReactNode | null) => void;
  setRightSidebarContent: (content: ReactNode | null) => void;
}

// Defines the shape of the data in the screen slice
interface ScreenState {
  isDesktop: boolean;
  isInitialized: boolean;
}

// Defines the actions available in the screen slice
interface ScreenActions {
    initializeScreenSize: () => void;
}

// The full store shape, combining state and actions
type UIState = {
    sidebar: SidebarState & SidebarActions;
    screen: ScreenState & ScreenActions;
}

// --- Store Slice Implementations ---

// Creates the sidebar slice of the store
const createSidebarSlice: StateCreator<UIState, [], [], { sidebar: SidebarState & SidebarActions }> = (set, get) => ({
  sidebar: {
    isLeftOpen: isDesktopView(),
    isRightOpen: isDesktopView(),
    isLeftAvailable: false,
    isRightAvailable: false,
    leftSidebarContent: null,
    rightSidebarContent: null,
    toggleLeftSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isLeftOpen: !state.sidebar.isLeftOpen, 
            // On mobile, opening one sidebar closes the other
            isRightOpen: !get().screen.isDesktop && !state.sidebar.isLeftOpen ? false : state.sidebar.isRightOpen 
        }
    })),
    toggleRightSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isRightOpen: !state.sidebar.isRightOpen, 
            isLeftOpen: !get().screen.isDesktop && !state.sidebar.isRightOpen ? false : state.sidebar.isLeftOpen 
        }
    })),
    setLeftAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isLeftAvailable: available }})),
    setRightAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isRightAvailable: available }})),
    setRightOpen: (isOpen) => set(state => ({ sidebar: { ...state.sidebar, isRightOpen: isOpen }})),
    setLeftSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, leftSidebarContent: content }})),
    setRightSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, rightSidebarContent: content }})),

  }
});

// Creates the screen slice of the store
const createScreenSlice: StateCreator<UIState, [], [], { screen: ScreenState & ScreenActions }> = (set, get) => ({
    screen: {
        isDesktop: isDesktopView(),
        isInitialized: false, // Initialize the flag to false
        initializeScreenSize: () => {
          // Add a guard clause to prevent running more than once
          if (get().screen.isInitialized) return;

          // Set the flag to true immediately to block re-entry
          set(state => ({
            screen: { ...state.screen, isInitialized: true }
          }));

          if (typeof window === 'undefined') return;

          const handleResize = () => {
            const desktop = isDesktopView();
            if (desktop !== get().screen.isDesktop) {
              set({
                  screen: { ...get().screen, isDesktop: desktop },
                  sidebar: { ...get().sidebar, isLeftOpen: desktop, isRightOpen: desktop }
                });
            }
          };
          window.addEventListener('resize', handleResize);
          handleResize();
        },
    }
});


// Combine the slices to create the final store
export const useUIStore = create<UIState>()((...a) => ({
    ...createSidebarSlice(...a),
    ...createScreenSlice(...a),
}));

================================================================================

File: core/state/useAppStore.ts
// src/stores/useAppStore.ts
import { create } from 'zustand';
import {  enableMapSet } from 'immer';
import { SiteSlice, createSiteSlice } from './slices/siteSlice';
import { ContentSlice, createContentSlice } from './slices/contentSlice';
import { SecretsSlice, createSecretsSlice } from './slices/secretsSlice';

// Enable Immer for Map and Set support
enableMapSet();

// The full store type is an intersection of all slice types
type AppStore = SiteSlice & ContentSlice & SecretsSlice & {
  isInitialized: boolean;
  initialize: () => void;
  activeSiteId: string | null;
  setActiveSiteId: (siteId: string | null) => void;
};

export const useAppStore = create<AppStore>()((...a) => ({
  isInitialized: false,
  initialize: () => {
    const set = a[0]; // Zustand's `set` function
    if (a[1]().isInitialized) return;
    console.log('[AppStore] Initializing application state...');
    set({ isInitialized: true });
  },

  activeSiteId: null,
  setActiveSiteId: (siteId) => {
    a[0]({ activeSiteId: siteId });
  },

  ...createSiteSlice(...a),
  ...createContentSlice(...a),
  ...createSecretsSlice(...a),
}));

================================================================================

File: core/state/slices/contentSlice.ts
// src/core/state/slices/contentSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { arrayMove } from '@dnd-kit/sortable';
import { toast } from 'sonner';
import { ParsedMarkdownFile, StructureNode, MarkdownFrontmatter } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import {
  getParentPath,
  findAndRemoveNode,
  updatePathsRecursively,
  findParentOfNode,
  updateNodeInChildren,
} from '@/core/services/fileTree.service';
import { SiteSlice } from '@/core/state/slices/siteSlice';
import { stringifyToMarkdown } from '@/lib/markdownParser';

/**
 * A private helper function to update the paths and slugs of content files
 * in the in-memory state after a move operation.
 * @param files The current array of content files.
 * @param pathsToMove An array of objects mapping old paths to new paths.
 * @returns A new array of content files with updated paths.
 */
const updateContentFilePaths = (files: ParsedMarkdownFile[], pathsToMove: { oldPath: string; newPath:string }[]): ParsedMarkdownFile[] => {
    const pathMap = new Map(pathsToMove.map(p => [p.oldPath, p.newPath]));
    return files.map(file => {
        if (pathMap.has(file.path)) {
            const newPath = pathMap.get(file.path)!;
            const newSlug = newPath.replace(/^content\//, '').replace(/\.md$/, '');
            return { ...file, path: newPath, slug: newSlug };
        }
        return file;
    });
};

/**
 * Defines the state and actions for managing a site's content and structure.
 * This includes creating, updating, deleting, and reordering pages.
 */
export interface ContentSlice {
  /**
   * Creates a new content file or updates an existing one. It persists the file
   * to storage and updates the site manifest's structure tree.
   * @param siteId The ID of the site being modified.
   * @param filePath The full path for the content file (e.g., 'content/about.md').
   * @param rawMarkdownContent The full content of the file, including frontmatter.
   * @returns A promise that resolves to true on success.
   */
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string) => Promise<boolean>;

  /**
   * Deletes a content file from storage, removes it from the manifest structure,
   * and updates all relevant state. If the deleted file was the homepage, it
   * intelligently assigns a new homepage.
   * @param siteId The ID of the site being modified.
   * @param filePath The path of the content file to delete.
   */
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;

  /**
   * Moves a node (and all its children) to a new parent in the structure tree.
   * This handles file path/slug updates and physical file moves in storage.
   * @param siteId The ID of the site being modified.
   * @param draggedNodePath The path of the node being moved.
   * @param targetNodePath The path of the new parent node, or null to move to the root.
   */
  moveNode: (siteId: string, draggedNodePath: string, targetNodePath: string | null) => Promise<void>;

  /**
   * A lightweight action to save changes to a file's content or frontmatter
   * without altering the site's structure tree.
   * @param siteId The ID of the site being modified.
   * @param savedFile The complete `ParsedMarkdownFile` object to save.
   */
  updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile) => Promise<void>;

  /**
   * Sets a specific page as the site's homepage. This action ensures that only
   * one page has the `homepage: true` flag by removing the flag from the
   * previous homepage in a single, transactional operation.
   * @param siteId The ID of the site being modified.
   * @param newHomepagePath The path of the file to designate as the new homepage.
   */
  setHomepageAction: (siteId: string, newHomepagePath: string) => Promise<void>;

  /**
   * Reorders a node within its current list of siblings.
   * @param siteId The ID of the site being modified.
   * @param activePath The path of the node being dragged.
   * @param targetPath The path of the node being dropped onto.
   * @param position Indicates whether the drop was above or below the target.
   */
  reorderNodeAction: (siteId: string, activePath: string, targetPath: string, position: 'reorder-before' | 'reorder-after') => Promise<void>;
  
  /**
   * Moves a nested node to the root level of the site structure.
   * @param siteId The ID of the site being modified.
   * @param activePath The path of the node being un-nested.
   */
  unNestNodeAction: (siteId: string, activePath: string) => Promise<void>;
    repositionNode: (siteId: string, activePath: string, overPath: string, intent: 'reorder-before' | 'reorder-after' | 'nest') => Promise<void>;

}

export const createContentSlice: StateCreator<SiteSlice & ContentSlice, [], [], ContentSlice> = (set, get) => ({

  updateContentFileOnly: async (siteId, savedFile) => {
    await localSiteFs.saveContentFile(siteId, savedFile.path, stringifyToMarkdown(savedFile.frontmatter, savedFile.content));
    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (siteToUpdate?.contentFiles) {
        const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
        if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
        else siteToUpdate.contentFiles.push(savedFile);
      }
    }));
  },

  

  addOrUpdateContentFile: async (siteId, filePath, rawMarkdownContent) => {
    const savedFile = await localSiteFs.saveContentFile(siteId, filePath, rawMarkdownContent);
    const site = get().getSiteById(siteId);
    if (!site || !site.contentFiles) return false;

    const isNewFile = !site.contentFiles.some(f => f.path === filePath);
    const menuTitle = typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined;

    const newManifest = produce(site.manifest, draft => {
      let parentFound = false;
      const parentPath = getParentPath(filePath);
      const findAndUpdateNode = (nodes: StructureNode[]): StructureNode[] => nodes.map(node => {
        if (!isNewFile && node.path === filePath) return { ...node, title: savedFile.frontmatter.title, menuTitle: menuTitle };
        const nodeAsDir = node.path.replace(/\.md$/, '');
        if (isNewFile && parentPath === nodeAsDir) {
          parentFound = true;
          return { ...node, children: [...(node.children || []), { type: 'page', title: savedFile.frontmatter.title, menuTitle: menuTitle, path: filePath, slug: savedFile.slug }] };
        }
        if (node.children) return { ...node, children: findAndUpdateNode(node.children) };
        return node;
      });
      draft.structure = findAndUpdateNode(draft.structure);
      if (isNewFile && !parentFound && parentPath === 'content') draft.structure.push({ type: 'page', title: savedFile.frontmatter.title, menuTitle: menuTitle, path: filePath, slug: savedFile.slug, navOrder: draft.structure.length });
    });

    await localSiteFs.saveManifest(siteId, newManifest);

    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (siteToUpdate) {
        siteToUpdate.manifest = newManifest;
        if (!siteToUpdate.contentFiles) siteToUpdate.contentFiles = [];
        const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === filePath);
        if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
        else siteToUpdate.contentFiles.push(savedFile);
      }
    }));
    return true;
  },

  deleteContentFileAndState: async (siteId, filePath) => {
    const site = get().getSiteById(siteId);
    if (!site) return;
    const fileToDelete = site.contentFiles?.find(f => f.path === filePath);
    const wasHomepage = fileToDelete?.frontmatter.homepage === true;

    const newManifest = produce(site.manifest, draft => {
      const filterStructure = (nodes: StructureNode[]): StructureNode[] => nodes.filter(node => node.path !== filePath).map(node => {
        if (node.children) node.children = filterStructure(node.children);
        return node;
      });
      draft.structure = filterStructure(draft.structure);
    });

    await Promise.all([localSiteFs.deleteContentFile(siteId, filePath), get().updateManifest(siteId, newManifest)]);
    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (siteToUpdate?.contentFiles) siteToUpdate.contentFiles = siteToUpdate.contentFiles.filter(f => f.path !== filePath);
    }));

    if (wasHomepage) {
      const updatedSite = get().getSiteById(siteId);
      const fallbackHomepageNode = updatedSite?.manifest.structure.find(node => node.type === 'page');
      if (fallbackHomepageNode) {
        toast.warning(`Homepage deleted. Setting "${fallbackHomepageNode.title}" as the new homepage.`);
        await get().setHomepageAction(siteId, fallbackHomepageNode.path);
      } else {
        toast.error("Homepage deleted, and no other pages were available to take its place.");
      }
    }
  },


  moveNode: async (siteId, draggedNodePath, targetNodePath) => {
    const site = get().getSiteById(siteId);
    if (!site?.contentFiles) {
      toast.error("Site data not found.");
      return;
    }

    // --- 1. PREPARE STATE CHANGES IN MEMORY ---
    const { found: draggedNode, tree: treeWithoutDraggedNode } = findAndRemoveNode([...site.manifest.structure], draggedNodePath);
    if (!draggedNode) {
      toast.error("An error occurred while moving the page.");
      return;
    }

    const newParentPath = targetNodePath ? targetNodePath.replace(/\.md$/, '') : 'content';
    const updatedNode = updatePathsRecursively(draggedNode, newParentPath);

    const pathsToMove: { oldPath: string; newPath: string }[] = [];
    const collectPaths = (newNode: StructureNode, oldNode: StructureNode) => {
      if (newNode.path !== oldNode.path) {
        pathsToMove.push({ oldPath: oldNode.path, newPath: newNode.path });
      }
      if (newNode.children && oldNode.children) {
        newNode.children.forEach((child, i) => collectPaths(child, oldNode.children![i]));
      }
    };
    collectPaths(updatedNode, draggedNode);

    let finalTree: StructureNode[];
    if (targetNodePath) {
      const insertIntoTree = (nodes: StructureNode[]): StructureNode[] => nodes.map(node => {
        if (node.path === targetNodePath) {
          return { ...node, children: [...(node.children || []), updatedNode] };
        }
        if (node.children) {
          return { ...node, children: insertIntoTree(node.children) };
        }
        return node;
      });
      finalTree = insertIntoTree(treeWithoutDraggedNode);
    } else {
      finalTree = [...treeWithoutDraggedNode, updatedNode];
    }

    // --- 2. PERSIST TO FILE SYSTEM ---
    if (pathsToMove.length > 0) {
      await localSiteFs.moveContentFiles(siteId, pathsToMove);
    }

    // --- 3. UPDATE ZUSTAND STORE TRANSACTIONALLY ---
    const newManifest = { ...site.manifest, structure: finalTree };
    const updatedContentFiles = updateContentFilePaths(site.contentFiles, pathsToMove);

    set(
      produce((draft: any) => {
        const siteToUpdate = draft.sites.find((s: any) => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = newManifest;
          siteToUpdate.contentFiles = updatedContentFiles;
        }
      })
    );
    
    // Persist the new manifest
    await localSiteFs.saveManifest(siteId, newManifest);

    toast.success(`Moved "${updatedNode.title}" successfully.`);
  },

  setHomepageAction: async (siteId, newHomepagePath) => {
    const site = get().getSiteById(siteId);
    if (!site?.contentFiles) throw new Error("Site content not loaded.");

    const targetFile = site.contentFiles.find(f => f.path === newHomepagePath);
    if (targetFile?.frontmatter.homepage === true) { toast.info("This page is already the designated homepage."); return; }

    const updates: { path: string; frontmatter: MarkdownFrontmatter }[] = [];
    let newHomepageTitle = 'the selected page';

    site.contentFiles.forEach(file => {
      if (file.path === newHomepagePath) {
        newHomepageTitle = file.frontmatter.title;
        updates.push({ path: file.path, frontmatter: { ...file.frontmatter, homepage: true } });
      } else if (file.frontmatter.homepage === true) {
        const { homepage, ...rest } = file.frontmatter;
        updates.push({ path: file.path, frontmatter: rest });
      }
    });

    if (updates.length === 0 && targetFile) {
        newHomepageTitle = targetFile.frontmatter.title;
        updates.push({ path: targetFile.path, frontmatter: { ...targetFile.frontmatter, homepage: true } });
    } else if (updates.length === 0) {
        throw new Error("Target homepage file not found.");
    }
    
    await Promise.all(updates.map(update => {
      const originalFile = site.contentFiles!.find(f => f.path === update.path)!;
      return localSiteFs.saveContentFile(siteId, update.path, stringifyToMarkdown(update.frontmatter, originalFile.content));
    }));

    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (siteToUpdate?.contentFiles) updates.forEach(update => {
        const fileInState = siteToUpdate.contentFiles!.find(f => f.path === update.path);
        if (fileInState) fileInState.frontmatter = update.frontmatter;
      });
    }));

    toast.success(`Homepage has been set to "${newHomepageTitle}".`);
  },

  reorderNodeAction: async (siteId, activePath, targetPath, position) => {
        const site = get().getSiteById(siteId);
        if (!site) return;

        const parent = findParentOfNode(site.manifest.structure, activePath);
        const list = parent ? parent.children : site.manifest.structure;

        if (!list) return;

        const oldIndex = list.findIndex((n: StructureNode) => n.path === activePath);
        let newIndex = list.findIndex((n: StructureNode) => n.path === targetPath);
        if (oldIndex === -1 || newIndex === -1) return;
        
        if (position === 'reorder-after' && oldIndex < newIndex) { /* No adjustment */ } 
        else if (position === 'reorder-before' && oldIndex > newIndex) { /* No adjustment */ } 
        else if (position === 'reorder-after') { newIndex += 1; }

        const reorderedList: StructureNode[] = arrayMove(list, oldIndex, newIndex);

        let newStructure: StructureNode[];
        if (parent) {
            newStructure = updateNodeInChildren(site.manifest.structure, parent.path, reorderedList);
        } else {
            newStructure = reorderedList;
        }
        
        await get().updateManifest(siteId, { ...site.manifest, structure: newStructure });
        toast.success("Page order updated.");
    },

    unNestNodeAction: async (siteId, activePath) => {
        return get().moveNode(siteId, activePath, null);
    },
repositionNode: async (
    siteId: string,
    activePath: string,
    overPath: string,
    intent: 'reorder-before' | 'reorder-after' | 'nest'
  ) => {
    const site = get().getSiteById(siteId);
    if (!site || !site.contentFiles) {
        toast.error("Site data not loaded. Cannot move page.");
        return;
    }

    // --- 1. VALIDATE THE MOVE ---
    const homepagePath = site.manifest.structure[0]?.path;
    if (activePath === homepagePath) {
      toast.error("The homepage cannot be moved.");
      return;
    }
    if (intent === 'reorder-before' && overPath === homepagePath) {
      toast.error("Pages cannot be moved above the homepage.");
      return;
    }
    if (intent === 'nest') {
      const targetFile = site.contentFiles.find(f => f.path === overPath);
      if (targetFile?.frontmatter.collection) {
        toast.error("Cannot nest pages under a Collection Page.");
        return;
      }
    }

    // --- 2. PREPARE THE NEW STRUCTURE (in memory) ---
    const { found: activeNode, tree: treeWithoutActive } = findAndRemoveNode([...site.manifest.structure], activePath);
    if (!activeNode) return;

    let finalTree = treeWithoutActive;

    if (intent === 'nest') {
        const insert = (nodes: StructureNode[]): boolean => {
            for (const node of nodes) {
                if (node.path === overPath) {
                    node.children = [...(node.children || []), activeNode];
                    return true;
                }
                if (node.children && insert(node.children)) return true;
            }
            return false;
        };
        insert(finalTree);
    } else { // Handle reordering (which also covers un-nesting)
        const parentOfOver = findParentOfNode(finalTree, overPath);
        const targetList = parentOfOver ? parentOfOver.children! : finalTree;
        const overIndex = targetList.findIndex(n => n.path === overPath);
        const newIndex = intent === 'reorder-after' ? overIndex + 1 : overIndex;
        targetList.splice(newIndex, 0, activeNode);
        
        if (parentOfOver) {
            finalTree = updateNodeInChildren(finalTree, parentOfOver.path, targetList);
        } else {
            finalTree = targetList;
        }
    }

    // --- 3. CALCULATE REQUIRED FILE PATH CHANGES ---
    const parentOfActiveFinal = findParentOfNode(finalTree, activePath);
    const newParentDir = parentOfActiveFinal ? parentOfActiveFinal.path.replace(/\.md$/, '') : 'content';
    const finalActiveNode = updatePathsRecursively(activeNode, newParentDir);
    
    const pathsToMove: { oldPath: string; newPath: string }[] = [];
    const collectPaths = (newNode: StructureNode, oldNode: StructureNode) => {
        if (newNode.path !== oldNode.path) pathsToMove.push({ oldPath: oldNode.path, newPath: newNode.path });
        if (newNode.children && oldNode.children) newNode.children.forEach((child, i) => collectPaths(child, oldNode.children![i]));
    };
    collectPaths(finalActiveNode, activeNode);

    // --- 4. EXECUTE THE FULLY TRANSACTIONAL UPDATE ---
    try {
        // Step 4a: Persist physical file moves first
        if (pathsToMove.length > 0) {
            await localSiteFs.moveContentFiles(siteId, pathsToMove);
        }

        // Step 4b: Prepare new state for Zustand
        const newManifest = { ...site.manifest, structure: finalTree };
        const updatedContentFiles = updateContentFilePaths(site.contentFiles, pathsToMove);
        
        // Step 4c: Update Zustand store atomically
        set(produce((draft: any) => {
            const siteToUpdate = draft.sites.find((s: any) => s.siteId === siteId);
            if (siteToUpdate) {
                siteToUpdate.manifest = newManifest;
                siteToUpdate.contentFiles = updatedContentFiles;
            }
        }));

        // Step 4d: Persist the new manifest structure
        await localSiteFs.saveManifest(siteId, newManifest);
        toast.success("Site structure updated successfully.");
    } catch (error) {
        console.error("Failed to reposition node:", error);
        toast.error("An error occurred while updating the site structure.");
        // If anything fails, reload state from storage to prevent UI inconsistencies
        get().loadSite(siteId);
    }
  },
});

================================================================================

File: core/state/slices/siteSlice.ts
// src/core/state/slices/siteSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { LocalSiteData, Manifest } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { loadSiteSecretsFromDb } from '@/core/services/siteSecrets.service';
import { toast } from 'sonner';

export interface SiteSlice {
  sites: LocalSiteData[];
  loadingSites: Set<string>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
  loadSite: (siteId: string) => Promise<void>;
  addSite: (siteData: LocalSiteData) => Promise<void>;
  updateManifest: (siteId: string, manifest: Manifest) => Promise<void>;
  deleteSiteAndState: (siteId: string) => Promise<void>;
}

export const createSiteSlice: StateCreator<SiteSlice, [], [], SiteSlice> = (set, get) => ({
  sites: [],
  loadingSites: new Set(),
  getSiteById: (siteId) => get().sites.find(s => s.siteId === siteId),

  loadSite: async (siteId) => {
    if (get().loadingSites.has(siteId)) return;
    const existingSite = get().getSiteById(siteId);
    if (existingSite && existingSite.contentFiles) return;
    
    set(produce(draft => { draft.loadingSites.add(siteId); }));

    try {
      const manifest = await localSiteFs.getManifestById(siteId);
      if (!manifest) throw new Error(`Failed to load manifest for siteId: ${siteId}`);
      
      const [contentFiles, layoutFiles, themeFiles, secrets] = await Promise.all([
        localSiteFs.getSiteContentFiles(siteId),
        localSiteFs.getSiteLayoutFiles(siteId),
        localSiteFs.getSiteThemeFiles(siteId),
        loadSiteSecretsFromDb(siteId)
      ]);

      const loadedSiteData: LocalSiteData = { siteId, manifest, contentFiles, layoutFiles, themeFiles, secrets };

      set(produce((draft: SiteSlice) => {
        const siteIndex = draft.sites.findIndex(s => s.siteId === siteId);
        if (siteIndex > -1) {
          draft.sites[siteIndex] = loadedSiteData;
        } else {
          draft.sites.push(loadedSiteData);
        }
      }));
    } catch (error) {
      toast.error(`Could not load site data for ID: ${siteId}`);
      console.error(`[AppStore.loadSite] Error during load for ${siteId}:`, error);
    } finally {
      set(produce(draft => { draft.loadingSites.delete(siteId); }));
    }
  },

  addSite: async (newSiteData) => {
    await localSiteFs.saveSite(newSiteData);
    const siteWithSecrets: LocalSiteData = {
        ...newSiteData,
        secrets: newSiteData.secrets || {}
    };
    await localSiteFs.saveSite(siteWithSecrets); // saveSite needs to be updated to handle secrets
    set(produce((draft: SiteSlice) => {
      if (!draft.sites.some(s => s.siteId === newSiteData.siteId)) {
        draft.sites.push(newSiteData);
      }
    }));
  },

  updateManifest: async (siteId, newManifest) => {
    await localSiteFs.saveManifest(siteId, newManifest);
    set(produce((draft: SiteSlice) => {
      const site = draft.sites.find(s => s.siteId === siteId);
      if (site) site.manifest = newManifest;
    }));
  },

  deleteSiteAndState: async (siteId) => {
    await localSiteFs.deleteSite(siteId);
    set(produce((draft: SiteSlice) => {
      draft.sites = draft.sites.filter(s => s.siteId !== siteId);
    }));
  },
});

================================================================================

File: core/state/slices/secretsSlice.ts
// src/core/state/slices/secretsSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { SiteSlice } from './siteSlice';
import { SiteSecrets, saveSiteSecretsToDb } from '@/core/services/siteSecrets.service';
import { toast } from 'sonner';

export interface SecretsSlice {
  /**
   * Updates the secrets for a site, persisting them to storage first
   * and then updating the in-memory state.
   * @param siteId The ID of the site to update.
   * @param secrets The new secrets object to save.
   */
  updateSiteSecrets: (siteId: string, secrets: SiteSecrets) => Promise<void>;
}

export const createSecretsSlice: StateCreator<SiteSlice & SecretsSlice, [], [], SecretsSlice> = (set, get) => ({
  updateSiteSecrets: async (siteId, newSecrets) => {
    try {
      // 1. Persist the secrets to the database first.
      await saveSiteSecretsToDb(siteId, newSecrets);

      // 2. If successful, update the in-memory state.
      set(produce((draft: SiteSlice) => {
        const site = draft.sites.find(s => s.siteId === siteId);
        if (site) {
          site.secrets = newSecrets;
        }
      }));

      toast.success("Secret settings saved successfully!");
    } catch (error) {
      console.error("Failed to save site secrets:", error);
      toast.error("Could not save secret settings.");
      // Re-throw the error if you want the calling component to handle it
      throw error;
    }
  },
});

================================================================================

File: core/components/Navbar.tsx
// src/components/core/Navbar.tsx
'use client';

import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation'; // Import useRouter
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { Button } from '@/core/components/ui/button';
import { Input } from '@/core/components/ui/input'; // Import Input
import React, { useState } from 'react';

// ... (NavLink component remains the same) ...
const NavLink: React.FC<{ href: string; label: string; icon?: React.ReactNode; }> = ({ href, label, icon }) => {
  const pathname = usePathname();
  const isActive = pathname === href || (href !== '/' && pathname.startsWith(href));
  return (
    <Button  className={`justify-start ${isActive ? 'bg-accent text-accent-foreground' : ''}`}>
      <Link href={href} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};


export default function Navbar() {
  const router = useRouter();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim()); // Basic URL validation
        // We need a way to signify this is a remote URL to our browsing pages.
        // Option 1: Special prefix for siteId, e.g., "remote::http://localhost:8080"
        // Option 2: A different route, e.g., /browse/remote?url=...
        // Option 3: Pass state via router.push (can be complex with SSR/layouts)

        // Let's use Option 1: Prefix the siteId with "remote@" or similar marker
        // and encode the URL. The browsing page will then decode it.
        const encodedUrl = encodeURIComponent(url.origin); // Use origin (scheme + hostname + port)
        router.push(`/remote@${encodedUrl}`); // Navigate to /remote@http%3A%2F%2Flocalhost%3A8080
        setRemoteUrl(''); // Clear input
      } catch (error) {
        alert("Invalid URL entered.");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        <Link href="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
        </Link>
        
        {/* Remote Site URL Input */}
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Signum site URL (e.g., http://localhost:8080)"
              className="pl-9" // Padding for the icon
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          <NavLink href="/" label="Dashboard" icon={<Home className="h-4 w-4" />} />
          {/* ... other links ... */}
        </nav>

        <div className="md:hidden">
          <Button  >
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: core/components/HashLink.tsx
// src/core/components/ui/HashLink.tsx
'use client';

import { AnchorHTMLAttributes, FC, forwardRef } from 'react';
import { cn } from '@/lib/utils';

interface HashLinkProps extends AnchorHTMLAttributes<HTMLAnchorElement> {
  // 'to' will be the path without the hash, e.g., "/sites/123"
  to: string;
}

export const HashLink: FC<HashLinkProps> = forwardRef<HTMLAnchorElement, HashLinkProps>(
  ({ to, children, className, ...props }, ref) => {
    // The href is constructed with the required # prefix.
    // We remove a leading slash from 'to' if it exists, as the # acts as the root.
    const href = `#${to.startsWith('/') ? to : `/${to}`}`;
    return (
      <a href={href} className={cn(className)} ref={ref} {...props}>
        {children}
      </a>
    );
  }
);
HashLink.displayName = 'HashLink';

================================================================================

File: core/components/Footer.tsx
// src/components/core/Footer.tsx
import Link from 'next/link';
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p>© {currentYear} Signum Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: core/components/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: core/components/ErrorBoundary.tsx
// src/components/core/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/core/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    // Update state so the next render will show the fallback UI.
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // You can also log the error to an error reporting service
    console.error("Uncaught error:", error, errorInfo);
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: undefined });
    // Optionally, you could try to trigger a reload or navigate home
    // window.location.assign('/'); 
  }

  public render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center bg-destructive/10 border border-destructive rounded-lg">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h1 className="text-2xl font-bold text-destructive-foreground">Something went wrong.</h1>
          <p className="text-muted-foreground mt-2 mb-4">
            An unexpected error occurred. Please try refreshing the page.
          </p>
          {this.state.error && (
            <details className="w-full max-w-lg text-left bg-background p-2 rounded border mb-4">
                <summary className="cursor-pointer text-sm font-medium">Error Details</summary>
                <pre className="mt-2 text-xs text-muted-foreground whitespace-pre-wrap break-all">
                    {this.state.error.message}
                </pre>
            </details>
          )}
          <Button onClick={() => window.location.reload()} variant="destructive">
            Refresh Page
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

================================================================================

File: core/components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/components/ui/link.tsx
import * as Headless from '@headlessui/react'
import NextLink, { type LinkProps } from 'next/link'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: LinkProps & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <NextLink {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})

================================================================================

File: core/components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: core/components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: core/components/ui/accordion.tsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex border-b">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 text-xs font-semibold uppercase tracking-wider text-muted-foreground transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 py-2 px-2",
          className
        )}
        {...props}
      >
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0 transition-transform duration-200 mr-1" />
        {children}
        
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm py-4 px-3"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================

File: core/components/ui/switch.tsx
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


================================================================================

File: core/components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: core/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: core/components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: core/components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: core/components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: core/hooks/useAutosave.ts
// src/hooks/useAutosave.ts
'use client';

import { useEffect, useRef } from 'react';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';

interface AutosaveParams<TData> {
  /** The generic data to be saved. */
  dataToSave: TData;
  /** A flag indicating if there are pending changes. */
  hasUnsavedChanges: boolean;
  /** A flag to prevent saving if the content isn't in a saveable state. */
  isSaveable: boolean;
  /** The function that performs the save operation with the generic data. */
  onSave: (data: TData) => Promise<void>;
}

/**
 * A generic custom hook to handle autosaving content after a specified delay.
 * It encapsulates the timer logic and effect management for saving drafts.
 */
export function useAutosave<TData>({ dataToSave, hasUnsavedChanges, isSaveable, onSave }: AutosaveParams<TData>) {
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (autosaveTimeoutRef.current) {
      clearTimeout(autosaveTimeoutRef.current);
    }

    if (hasUnsavedChanges && isSaveable) {
      autosaveTimeoutRef.current = setTimeout(() => {
        onSave(dataToSave);
      }, AUTOSAVE_DELAY);
    }

    return () => {
      if (autosaveTimeoutRef.current) {
        clearTimeout(autosaveTimeoutRef.current);
      }
    };
  }, [dataToSave, hasUnsavedChanges, isSaveable, onSave]);
}

================================================================================

File: core/hooks/useInitialiseUIStore.ts
'use client';

import { useUIStore } from '@/core/state/uiStore';
import { useEffect } from 'react';

export function useInitialiseUIStore() {
  const initialize = useUIStore((state) => state.screen.initializeScreenSize);
  const isInitialized = useUIStore((state) => state.screen.isInitialized);

  useEffect(() => {
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);
}   

================================================================================

File: core/hooks/useHashNavigation.ts
// src/core/hooks/useHashNavigation.ts
'use client';

import { useState, useEffect } from 'react';

// A helper to safely get the hash and clean it up.
function getCleanHash() {
  if (typeof window === 'undefined') return '/';
  // Get the hash, remove the leading #, and ensure it starts with a /
  const hash = window.location.hash.substring(1);
  return hash.startsWith('/') ? hash : `/${hash}`;
}

export function useHashNavigation() {
  const [currentPath, setCurrentPath] = useState(getCleanHash());

  useEffect(() => {
    const handleHashChange = () => {
      setCurrentPath(getCleanHash());
    };

    // Listen for changes to the hash
    window.addEventListener('hashchange', handleHashChange);
    // Set the initial path when the component mounts
    handleHashChange();

    return () => {
      window.removeEventListener('hashchange', handleHashChange);
    };
  }, []);

  return currentPath;
}

================================================================================

File: core/services/configHelpers.service.ts
// src/core/services/configHelpers.service.ts

import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { CORE_LAYOUTS, CORE_THEMES, BASE_SCHEMA } from '@/config/editorConfig';
import {
    LocalSiteData,
    Manifest,
    LayoutInfo,
    ThemeInfo,
    RawFile,
} from '@/types';

// --- Type Definitions ---

export type StrictUiSchema = UiSchema & { 'ui:groups'?: { title: string; fields: string[] }[] };

export type AssetFileType =
  | 'manifest'
  | 'base'      // A theme's main HTML shell
  | 'template'  // A generic template (used by all Layouts)
  | 'partial'
  | 'stylesheet'
  | 'script'
  | 'asset';

export interface AssetFile {
  path: string;
  type: AssetFileType;
  name?: string; // User-friendly name for UI selectors
}

/** The base properties shared by all asset manifests. */
export interface BaseAssetManifest {
  name: string;
  version: string;
  description?: string;
  icon?: string;
  files: AssetFile[];
}

/** The structure of a theme.json file. */
export interface ThemeManifest extends BaseAssetManifest {
  appearanceSchema?: RJSFSchema;
}

/** The structure of a layout.json file. */
export interface LayoutManifest extends BaseAssetManifest {
  id: string;
  // Use the new, clearer layout types
  layoutType: 'page' | 'list' | 'item';
  schema?: RJSFSchema; // Optional schema for a layout's own settings.
  uiSchema?: StrictUiSchema;
}

// SiteDataForAssets no longer needs `viewFiles`
export type SiteDataForAssets = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;

// --- Helper Functions ---

const fileContentCache = new Map<string, Promise<string | null>>();

const isCoreTheme = (path: string) => CORE_THEMES.some((t: ThemeInfo) => t.path === path);
const isCoreLayout = (path: string) => CORE_LAYOUTS.some((l: LayoutInfo) => l.path === path);

/**
 * Provides a base schema for all content, ensuring common fields are available.
 * @returns An object containing the base RJSFSchema and UiSchema.
 */
function getBaseSchema(): { schema: RJSFSchema, uiSchema: UiSchema } {
    return BASE_SCHEMA;
}

/**
 * Fetches the raw string content of a theme or layout asset.
 * It intelligently fetches from either the `/public` directory (for core assets)
 * or the `LocalSiteData` object (for user-provided custom assets), with caching.
 */
export async function getAssetContent(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<string | null> {
    const isCore = assetType === 'theme' ? isCoreTheme(path) : isCoreLayout(path);
    const sourcePath = `/${assetType}s/${path}/${fileName}`;

    if (isCore) {
      if (fileContentCache.has(sourcePath)) {
        return fileContentCache.get(sourcePath)!;
      }
      const promise = fetch(sourcePath)
        .then(res => res.ok ? res.text() : null)
        .catch(() => null);
      fileContentCache.set(sourcePath, promise);
      return promise;
    } else {
      const fileStore: RawFile[] | undefined =
          assetType === 'theme' ? siteData.themeFiles
          : assetType === 'layout' ? siteData.layoutFiles
          : undefined;

      const fullPath = `${assetType}s/${path}/${fileName}`;
      return fileStore?.find(f => f.path === fullPath)?.content ?? null;
    }
}

/**
 * A generic function to fetch and parse any JSON asset manifest (theme, layout).
 */
export async function getJsonAsset<T>(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<T | null> {
    const content = await getAssetContent(siteData, assetType, path, fileName);
    if (!content) return null;
    try {
      return JSON.parse(content) as T;
    } catch (e) {
      console.error(`Failed to parse JSON from ${assetType}/${path}/${fileName}:`, e);
      return null;
    }
}

/**
 * Merges a layout's specific schema with the universal base schema.
 */
function mergeSchemas(base: RJSFSchema, specific?: RJSFSchema): RJSFSchema {
    if (!specific) return { ...base };
    return {
        ...base,
        ...specific,
        properties: { ...(base.properties || {}), ...(specific.properties || {}) },
        required: [...new Set([...(base.required || []), ...(specific.required || [])])]
    };
}

// --- Public API ---

/**
 * Gets a list of all available themes (core and custom).
 */
export function getAvailableThemes(manifest?: Manifest): ThemeInfo[] {
  const available = [...CORE_THEMES];
  if (manifest?.themes) {
    const customThemes = manifest.themes.filter(ct => !available.some(coreT => coreT.path === ct.path));
    available.push(...customThemes);
  }
  return available;
}

/**
 * Fetches and processes the manifest for a specific layout, merging its
 * schema with the base content schema.
 */
export async function getLayoutManifest(siteData: SiteDataForAssets, layoutPath: string): Promise<LayoutManifest | null> {
    const layoutManifest = await getJsonAsset<LayoutManifest>(siteData, 'layout', layoutPath, 'layout.json');
    const baseSchemaData = getBaseSchema();

    if (!layoutManifest) {
      // Fallback for a missing layout.json.
      return {
          id: layoutPath, // Satisfy the required 'id' property
          name: layoutPath,
          version: '1.0.0',
          layoutType: 'page', // Default to 'page' type
          files: [],
          schema: baseSchemaData.schema,
          uiSchema: baseSchemaData.uiSchema,
      }
    }

    // Merge the layout's schema and uiSchema with the base schemas.
    layoutManifest.schema = mergeSchemas(baseSchemaData.schema, layoutManifest.schema);
    layoutManifest.uiSchema = { ...baseSchemaData.uiSchema, ...(layoutManifest.uiSchema || {}) };

    // Clean up properties that are handled by dedicated UI fields, not the generic form.
    if (layoutManifest.schema?.properties) {
      delete layoutManifest.schema.properties.title;
      delete layoutManifest.schema.properties.description;
      delete layoutManifest.schema.properties.slug;
    }

    return { ...layoutManifest, id: layoutPath };
}

/**
 * Gets a list of the full manifest objects for all available layouts,
 * optionally filtered by a specific layout type.
 */
export async function getAvailableLayouts(
  siteData: SiteDataForAssets,
  type?: LayoutManifest['layoutType']
): Promise<LayoutManifest[]> {
  const coreLayoutIds = CORE_LAYOUTS.map(l => l.id);
  const customLayoutIds = siteData.manifest.layouts?.map(l => l.id) || [];
  const allLayoutIds = [...new Set([...coreLayoutIds, ...customLayoutIds])];

  const manifestPromises = allLayoutIds.map(layoutId =>
    getLayoutManifest(siteData, layoutId)
  );

  const allManifests = (await Promise.all(manifestPromises))
    .filter((m): m is LayoutManifest => m !== null);

  if (type) {
    return allManifests.filter(m => m.layoutType === type);
  }

  return allManifests;
}

================================================================================

File: core/services/blocknote.service.ts
// src/core/services/blocknote.service.ts
import { Block, BlockNoteEditor } from '@blocknote/core';

/**
 * Converts a Markdown string into an array of Blocknote `Block` objects.
 * This works by creating a headless editor and using the `tryParseMarkdownToBlocks`
 * instance method.
 *
 * @param markdown The Markdown string to convert.
 * @returns A promise that resolves to an array of Blocks.
 */
export async function markdownToBlocks(markdown: string): Promise<Block[]> {
  // If the incoming markdown is empty, return an empty array to avoid
  // creating an unnecessary editor instance.
  if (!markdown || markdown.trim() === '') {
    return [];
  }
  
  const editor = await BlockNoteEditor.create();
  const blocks = await editor.tryParseMarkdownToBlocks(markdown);
  
  return blocks;
}

/**
 * Converts an array of Blocknote `Block` objects into a Markdown string.
 * This works by creating a headless editor pre-populated with the blocks
 * and then using its instance method to serialize them to Markdown.
 *
 * @param blocks The array of Blocks to convert.
 * @returns A promise that resolves to a Markdown string.
 */
export async function blocksToMarkdown(blocks: Block[]): Promise<string> {
  // If the blocks array is empty or undefined, return an empty string immediately.
  if (!blocks || blocks.length === 0) {
    return "";
  }
  
  // Only create an editor instance if there are blocks to process.
  const editor = await BlockNoteEditor.create({
    initialContent: blocks,
  });
  
  const markdown = await editor.blocksToMarkdownLossy();

  return markdown;
}

================================================================================

File: core/services/siteExporter.service.ts
// src/core/services/siteExporter.service.ts
import JSZip from 'jszip';
import { LocalSiteData, ParsedMarkdownFile, StructureNode, ImageRef, Manifest } from '@/types';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { flattenStructureToRenderableNodes } from './fileTree.service';
import { resolvePageContent } from './pageResolver.service';
import { PageType } from '@/types';
import { render } from './theme-engine/themeEngine.service';
import { getUrlForNode } from './urlUtils.service';
import { getAssetContent, getJsonAsset, ThemeManifest, LayoutManifest } from './configHelpers.service';
import { getActiveImageService } from '@/core/services/images/images.service';

/**
 * Escapes special XML characters in a string to make it safe for RSS/Sitemap feeds.
 */
function escapeForXml(str: unknown): string {
    if (str === undefined || str === null) return '';
    return String(str).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/'/g, "'");
}

/**
 * A helper function to find all files for a given asset (theme or layout)
 * and add them to the ZIP archive.
 */
async function bundleAsset(zip: JSZip, siteData: LocalSiteData, assetType: 'theme' | 'layout', assetId: string) {
    const assetFolder = zip.folder('_signum')?.folder(`${assetType}s`)?.folder(assetId);
    if (!assetFolder) return;
    const manifestFileName = assetType === 'theme' ? 'theme.json' : 'layout.json';
    const manifest = await getJsonAsset<ThemeManifest | LayoutManifest>(siteData, assetType, assetId, manifestFileName);
    if (!manifest || !manifest.files) {
        console.warn(`Asset manifest for ${assetType}/${assetId} is missing or has no 'files' array. Skipping bundle.`);
        return;
    }
    for (const file of manifest.files) {
        const content = await getAssetContent(siteData, assetType, assetId, file.path);
        if (content) {
            assetFolder.file(file.path, content);
        } else {
            console.warn(`Could not find content for declared file: ${assetType}s/${assetId}/${file.path}`);
        }
    }
}

/**
 * A helper function to recursively find all ImageRef objects within a site's data.
 */
function findAllImageRefs(siteData: LocalSiteData): ImageRef[] {
  const refs = new Set<ImageRef>();
  const visited = new Set<object>();

  function find(obj: any) {
    if (!obj || typeof obj !== 'object' || visited.has(obj)) return;
    visited.add(obj);
    if (obj.serviceId && obj.src) {
        refs.add(obj as ImageRef);
    }
    Object.values(obj).forEach(value => find(value));
  }

  find(siteData.manifest);
  siteData.contentFiles?.forEach(file => find(file.frontmatter));
  return Array.from(refs);
}

/**
 * Compiles a full Signum site into a downloadable ZIP archive, ready for deployment.
 */
export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
    const zip = new JSZip();
    const { manifest, contentFiles } = siteData;
    if (!contentFiles) {
        throw new Error("Cannot export site: content files are not loaded.");
    }
    const allRenderableNodes = flattenStructureToRenderableNodes(manifest.structure);

    // --- 1. Generate All HTML Pages ---
    for (const node of allRenderableNodes) {
        const initialResolution = resolvePageContent(siteData, node.slug.split('/'));
        if (initialResolution.type === PageType.NotFound) continue;
        const isPaginated = !!(initialResolution.pagination && initialResolution.pagination.totalPages > 1);

        if (isPaginated) {
            const totalPages = initialResolution.pagination!.totalPages;
            for (let i = 1; i <= totalPages; i++) {
                const resolutionForPage = resolvePageContent(siteData, node.slug.split('/'), i);
                if (resolutionForPage.type === PageType.NotFound) continue;
                const outputPath = getUrlForNode(node, manifest, true, i);
                const depth = (outputPath.match(/\//g) || []).length;
                const relativePrefix = '../'.repeat(depth > 0 ? depth - 1 : 0);
                const finalHtml = await render(siteData, resolutionForPage, { siteRootPath: '/', isExport: true, relativeAssetPath: relativePrefix });
                zip.file(outputPath, finalHtml);
            }
        } else {
            const outputPath = getUrlForNode(node, manifest, true);
            const depth = (outputPath.match(/\//g) || []).length;
            const relativePrefix = '../'.repeat(depth > 0 ? depth - 1 : 0);
            const finalHtml = await render(siteData, initialResolution, { siteRootPath: '/', isExport: true, relativeAssetPath: relativePrefix });
            zip.file(outputPath, finalHtml);
        }
    }

    // --- 2. Add _signum Source Content and Asset Files ---
    const signumFolder = zip.folder('_signum');
    if (signumFolder) {
        signumFolder.file('manifest.json', JSON.stringify(manifest, null, 2));
        contentFiles.forEach(file => {
            signumFolder.file(file.path, stringifyToMarkdown(file.frontmatter, file.content));
        });
    }

    const allImageRefs = findAllImageRefs(siteData);
    if (allImageRefs.length > 0) {
        const imageService = getActiveImageService(manifest);
        const assetsToBundle = await imageService.getExportableAssets(siteData.siteId, allImageRefs);
        for (const asset of assetsToBundle) {
            zip.file(asset.path, asset.data);
        }
    }

    const layoutIds = new Set<string>();
    contentFiles.forEach(file => {
        if (file.frontmatter.layout) layoutIds.add(file.frontmatter.layout);
        if (file.frontmatter.collection) {
            layoutIds.add(file.frontmatter.collection.item_layout);
        }
    });

    await bundleAsset(zip, siteData, 'theme', manifest.theme.name);
    for (const layoutId of Array.from(layoutIds)) {
        await bundleAsset(zip, siteData, 'layout', layoutId);
    }

    // --- 3. Generate RSS Feed and Sitemap ---
    const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
    type RssItemData = { node: StructureNode, file: ParsedMarkdownFile };

    const rssItems = allRenderableNodes
        .map((node): RssItemData | null => {
            const file = contentFiles.find(f => f.path === node.path);
            return file ? { node, file } : null;
        })
        .filter((item): item is RssItemData => {
            if (!item || !item.file) return false;
            return !!item.file.frontmatter.date && !item.file.frontmatter.collection;
        })
        .sort((a, b) => new Date(b.file.frontmatter.date as string).getTime() - new Date(a.file.frontmatter.date as string).getTime())
        .slice(0, 20)
        .map((item) => {
            const relativeUrl = getUrlForNode(item.node, manifest, false);
            const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
            const description = escapeForXml(item.file.frontmatter.description);
            const pubDate = new Date(item.file.frontmatter.date as string).toUTCString();
            return `<item><title>${escapeForXml(item.node.title)}</title><link>${escapeForXml(absoluteUrl)}</link><guid isPermaLink="true">${escapeForXml(absoluteUrl)}</guid><pubDate>${pubDate}</pubDate><description>${description}</description></item>`;
        }).join('');

    const rssFeed = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(manifest.title)}</title><link>${siteBaseUrl}</link><description>${escapeForXml(manifest.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrl).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;
    zip.file('rss.xml', rssFeed);

    const sitemapUrls = allRenderableNodes.map((node) => {
        const file = contentFiles.find(f => f.path === node.path);
        const relativeUrl = getUrlForNode(node, manifest, false);
        const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
        const lastMod = (file?.frontmatter.date as string || new Date().toISOString()).split('T')[0];
        return `<url><loc>${escapeForXml(absoluteUrl)}</loc><lastmod>${lastMod}</lastmod></url>`;
    }).join('');

    const sitemapXml = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
    zip.file('sitemap.xml', sitemapXml);

    return zip.generateAsync({ type: 'blob' });
}

================================================================================

File: core/services/urlUtils.service.ts
// src/core/services/urlUtils.service.ts
import { Manifest, StructureNode } from '@/types';

/**
 * Generates a URL for a given site node based on its position and context.
 * This is a critical utility for both the live preview and the final static site export.
 *
 * It implements the "First Page is Homepage" rule:
 * - The very first page in the site's root structure (`manifest.structure[0]`) is
 *   always treated as the homepage and mapped to the root URL (`/` or `index.html`).
 * - All other pages are mapped to subdirectories based on their slug for clean URLs
 *   (e.g., a page with slug 'about' becomes '/about/').
 *
 * @param node - The `StructureNode` object for which to generate a URL. It must have `path` and `slug`.
 * @param manifest - The complete site manifest. This is required to identify the homepage by its position.
 * @param isExport - A boolean indicating if the URL is for a static export (e.g., `about/index.html`) or a live preview (e.g., `/about`).
 * @param pageNumber - An optional page number for generating paginated links (e.g., `/blog/page/2`).
 * @returns A string representing the final URL segment or filename.
 */
export function getUrlForNode(
  node: { path: string; slug: string },
  manifest: Manifest,
  isExport: boolean,
  pageNumber?: number,
): string {
  // --- Homepage Check ---
  // The homepage is defined as the first node in the root of the manifest's structure array.
  // The optional chaining `?.` safely handles an empty structure for a brand new site.
  const isDesignatedHomepage = manifest.structure[0]?.path === node.path;

  if (isDesignatedHomepage) {
    // --- Homepage URL Logic ---
    if (isExport) {
      // For a paginated homepage, page 2 and beyond go into a subdirectory.
      // e.g., /page/2/index.html
      if (pageNumber && pageNumber > 1) {
        return `page/${pageNumber}/index.html`;
      }
      // The homepage itself is always the root index.html file.
      return 'index.html';
    } else {
      // Live Preview URL
      if (pageNumber && pageNumber > 1) {
        return `page/${pageNumber}`;
      }
      // For the live preview, the root URL is represented by an empty string,
      // which the browser/router interprets as '/'.
      return '';
    }
  }

  // --- Logic for All Other Pages ---
  const baseSlug = node.slug;

  if (isExport) {
    // Paginated collection pages, e.g., blog/page/2/index.html
    if (pageNumber && pageNumber > 1) {
      return `${baseSlug}/page/${pageNumber}/index.html`;
    }
    // All other pages are placed in their own directory with an index.html
    // to create clean URLs, e.g., /about-us/
    return `${baseSlug}/index.html`;
  } else {
    // Live Preview URLs for other pages
    if (pageNumber && pageNumber > 1) {
      return `${baseSlug}/page/${pageNumber}`;
    }
    // A standard page preview URL is just its slug, e.g., /about-us
    return baseSlug;
  }
}

================================================================================

File: core/services/relativePaths.service.ts
// src/lib/pathUtils.ts

/**
 * Calculates the relative path from one file to another.
 * This is essential for creating portable HTML that works on any server
 * or directly from the local file system.
 *
 * @example
 * // from 'index.html' to 'about.html' -> './about.html'
 * getRelativePath('index.html', 'about.html');
 *
 * @example
 * // from 'posts/post1.html' to 'index.html' -> '../index.html'
 * getRelativePath('posts/post1.html', 'index.html');
 *
 * @example
 * // from 'posts/post1.html' to 'tags/tech.html' -> '../tags/tech.html'
 * getRelativePath('posts/post1.html', 'tags/tech.html');
 *
 * @param {string} fromPath - The path of the file containing the link.
 * @param {string} toPath - The path of the file being linked to.
 * @returns {string} The calculated relative path.
 */
export function getRelativePath(fromPath: string, toPath: string): string {
  if (fromPath === toPath) {
    return toPath.split('/').pop() || '';
  }

  const fromParts = fromPath.split('/').slice(0, -1); // Path without filename
  const toParts = toPath.split('/');

  // Find the common path segment
  let commonLength = 0;
  while (
    commonLength < fromParts.length &&
    commonLength < toParts.length &&
    fromParts[commonLength] === toParts[commonLength]
  ) {
    commonLength++;
  }

  const upLevels = fromParts.length - commonLength;
  const upPath = '../'.repeat(upLevels) || './';

  const downPath = toParts.slice(commonLength).join('/');

  return upPath + downPath;
}

================================================================================

File: core/services/localFileSystem.service.ts
// src/lib/localSiteFs.ts
import { LocalSiteData, Manifest, ParsedMarkdownFile, RawFile } from '@/types'; // Ensure RawFile is imported
import localforage from 'localforage';
import { stringifyToMarkdown, parseMarkdownString } from '@/lib/markdownParser';

const DB_NAME = 'SignumDB';

const siteManifestsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteManifests',
});

const siteContentFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteContentFiles',
});

const siteLayoutFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteLayoutFiles',
});

const siteThemeFilesStore = localforage.createInstance({
    name: DB_NAME,
    storeName: 'siteThemeFiles',
});

const siteImageAssetsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteImageAssets',
});

// --- Function to load only manifests for a fast initial load ---
export async function loadAllSiteManifests(): Promise<Manifest[]> {
  const manifests: Manifest[] = [];
  await siteManifestsStore.iterate((value: Manifest) => {
    manifests.push(value);
  });
  return manifests;
}

/**
 * Fetches the manifest for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<Manifest | null>} A Promise that resolves to the Manifest object, or null if not found.
 */
export async function getManifestById(siteId: string): Promise<Manifest | null> {
  const manifest = await siteManifestsStore.getItem<Manifest>(siteId);
  return manifest ?? null;
}

/**
 * Fetches the content files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<ParsedMarkdownFile[]>} A Promise that resolves to an array of parsed markdown files.
 */
export async function getSiteContentFiles(siteId: string): Promise<ParsedMarkdownFile[]> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId);
    return contentFiles ?? [];
}

/**
 * Fetches the custom layout files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw layout files.
 */
export async function getSiteLayoutFiles(siteId: string): Promise<RawFile[]> {
    const layoutFiles = await siteLayoutFilesStore.getItem<RawFile[]>(siteId);
    return layoutFiles ?? [];
}

/**
 * Fetches the custom theme files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw theme files.
 */
export async function getSiteThemeFiles(siteId: string): Promise<RawFile[]> {
    const themeFiles = await siteThemeFilesStore.getItem<RawFile[]>(siteId);
    return themeFiles ?? [];
}

export async function saveSite(siteData: LocalSiteData): Promise<void> {
  await Promise.all([
    siteManifestsStore.setItem(siteData.siteId, siteData.manifest),
    siteContentFilesStore.setItem(siteData.siteId, siteData.contentFiles ?? []),
    siteLayoutFilesStore.setItem(siteData.siteId, siteData.layoutFiles ?? []),
    siteThemeFilesStore.setItem(siteData.siteId, siteData.themeFiles ?? []),
  ]);
}

export async function deleteSite(siteId: string): Promise<void> {
  await Promise.all([
    siteManifestsStore.removeItem(siteId),
    siteContentFilesStore.removeItem(siteId),
    siteLayoutFilesStore.removeItem(siteId),
    siteThemeFilesStore.removeItem(siteId),
  ]);
}

export async function saveManifest(siteId: string, manifest: Manifest): Promise<void> {
    await siteManifestsStore.setItem(siteId, manifest);
}

export async function saveContentFile(siteId: string, filePath: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];

    const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
    const fileSlug = filePath.replace(/^content\//, '').replace(/\.md$/, '');
    const savedFile: ParsedMarkdownFile = { slug: fileSlug, path: filePath, frontmatter, content };

    const fileIndex = contentFiles.findIndex(f => f.path === filePath);
    if (fileIndex > -1) {
      contentFiles[fileIndex] = savedFile;
    } else {
      contentFiles.push(savedFile);
    }

    await siteContentFilesStore.setItem(siteId, contentFiles);
    return savedFile;
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const updatedContentFiles = contentFiles.filter(f => f.path !== filePath);
    await siteContentFilesStore.setItem(siteId, updatedContentFiles);
}

export async function getContentFileRaw(siteId: string, filePath: string): Promise<string | null> {
    const allFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const fileData = allFiles.find(f => f.path === filePath);
    if (!fileData) return null;
    
    return stringifyToMarkdown(fileData.frontmatter, fileData.content);
}

/**
 * Moves a set of content files from old paths to new paths in a single transaction.
 * @param {string} siteId - The ID of the site.
 * @param {{oldPath: string, newPath: string}[]} pathsToMove - An array of path mapping objects.
 * @returns {Promise<void>}
 */
export async function moveContentFiles(siteId: string, pathsToMove: { oldPath: string, newPath: string }[]): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    
    const updatedFiles = contentFiles.map(file => {
        const moveInstruction = pathsToMove.find(p => p.oldPath === file.path);
        if (moveInstruction) {
            const newSlug = moveInstruction.newPath.split('/').pop()?.replace('.md', '') || '';
            return { ...file, path: moveInstruction.newPath, slug: newSlug };
        }
        return file;
    });
    
    await siteContentFilesStore.setItem(siteId, updatedFiles);
}

/**
 * Saves a binary image asset (as a Blob) to storage for a specific site.
 * @param siteId The ID of the site.
 * @param imagePath The relative path to the image (e.g., 'assets/images/foo.jpg').
 * @param imageData The image data as a Blob.
 */
export async function saveImageAsset(siteId: string, imagePath: string, imageData: Blob): Promise<void> {
  const imageMap = await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId) || {};
  imageMap[imagePath] = imageData;
  await siteImageAssetsStore.setItem(siteId, imageMap);
}

/**
 * Retrieves a binary image asset (as a Blob) from storage for a specific site.
 * @param siteId The ID of the site to look within.
 * @param imagePath The relative path of the image to retrieve.
 * @returns A Promise that resolves to the image Blob, or null if not found.
 */
export async function getImageAsset(siteId: string, imagePath: string): Promise<Blob | null> {
  // <-- FIX: This is now much more efficient and correct.
  // 1. Get the image map for the specific site.
  const imageMap = await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId);
  if (!imageMap) {
    return null; // The site has no images.
  }
  // 2. Return the image from the map, or null if it doesn't exist.
  return imageMap[imagePath] || null;
}


================================================================================

File: core/services/navigationStructure.service.ts
// src/core/services/navigationStructure.service.ts
import { LocalSiteData, NavLinkItem, StructureNode } from '@/types';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { getRelativePath } from '@/core/services/relativePaths.service';
import { RenderOptions } from '@/core/services/theme-engine/themeEngine.service';

/**
 * Recursively builds a navigation link structure with context-aware paths.
 * @param siteData - The full site data, needed for URL generation.
 * @param nodes - The site structure nodes to build links from.
 * @param currentPagePath - The path of the page being currently rendered.
 * @param options - The render options, containing isExport and siteRootPath.
 * @returns An array of navigation link objects.
 */
function buildNavLinks(
    siteData: LocalSiteData, 
    nodes: StructureNode[], 
    currentPagePath: string, 
    options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  return nodes
    .filter(node => node.type === 'page' && node.navOrder !== undefined)
    .sort((a, b) => (a.navOrder || 0) - (b.navOrder || 0))
    .map(node => {
      let href: string;
      // --- FIX: Pass siteData.manifest instead of the whole siteData object ---
      const urlSegment = getUrlForNode(node, siteData.manifest, options.isExport);

      if (options.isExport) {
        href = getRelativePath(currentPagePath, urlSegment);
      } else {
        const path = `/${urlSegment}`.replace(/\/$/, '') || '/';
        href = `${options.siteRootPath}${path === '/' ? '' : path}`;
      }

      const children = (node.children && node.children.length > 0)
        ? buildNavLinks(siteData, node.children, currentPagePath, options)
        : [];

      return {
        href: href,
        label: node.menuTitle || node.title,
        children: children,
      };
    });
}

/**
 * Generates the complete navigation structure for a given page.
 */
export function generateNavLinks(
  siteData: LocalSiteData,
  currentPagePath: string,
  options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  const { structure } = siteData.manifest;
  return buildNavLinks(siteData, structure, currentPagePath, options);
}

================================================================================

File: core/services/pageResolver.service.ts
// src/core/services/pageResolver.service.ts

import {
    LocalSiteData,
    ParsedMarkdownFile,
    CollectionConfig,
    PaginationData,
    PageResolutionResult,
    PageType,
    StructureNode,
} from '@/types';
import { findNodeByPath, findChildNodes } from './fileTree.service';
import { getUrlForNode } from './urlUtils.service';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

/**
 * Executes a declarative query for a Collection Page.
 * This pure function takes the config and site data, finds all child pages
 * in the structure, fetches their content, and returns a fully sorted array.
 * Pagination is handled by the main resolver.
 *
 * @param {CollectionConfig} collectionConfig - The configuration object from the page's frontmatter.
 * @param {StructureNode} collectionNode - The structure node for the Collection Page itself.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @returns {ParsedMarkdownFile[]} A sorted array of all content files that are children of the collection page.
 */
function executeCollectionQuery(
    collectionConfig: CollectionConfig,
    collectionNode: StructureNode,
    siteData: LocalSiteData,
): ParsedMarkdownFile[] {
    if (!siteData.contentFiles) {
        return [];
    }

    // Find all direct child nodes of the collection page in the site's structure.
    const childNodes = findChildNodes(siteData.manifest.structure, collectionNode.path);
    const childPaths = new Set(childNodes.map(child => child.path));

    // Filter the site's content files to get only the ones that are children.
    const items = siteData.contentFiles.filter(file => childPaths.has(file.path));

    // --- Sorting Logic ---
    const sortBy = collectionConfig.sort_by || 'date';
    const sortOrder = collectionConfig.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    // Create a copy of the array before sorting to avoid mutating the original.
    return [...items].sort((a, b) => {
        const valA = a.frontmatter[sortBy];
        const valB = b.frontmatter[sortBy];

        if (sortBy === 'date' && valA && valB) {
            const dateA = new Date(valA as string).getTime();
            const dateB = new Date(valB as string).getTime();
            if (isNaN(dateA) || isNaN(dateB)) return 0;
            return (dateA - dateB) * orderModifier;
        }

        if (typeof valA === 'string' && typeof valB === 'string') {
            return valA.localeCompare(valB) * orderModifier;
        }

        if (typeof valA === 'number' && typeof valB === 'number') {
            return (valA - valB) * orderModifier;
        }
        return 0;
    });
}

/**
 * Finds the correct page to render based on a URL slug path.
 * If the page is a Collection Page, this function executes the query, handles pagination,
 * and attaches the results to the final resolution object.
 *
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {string[]} slugArray - The URL segments used for path matching.
 * @param {number} [pageNumber=1] - The current page number for pagination.
 * @returns {PageResolutionResult} An object containing all data needed to render the page or a not-found error.
 */
export function resolvePageContent(
    siteData: LocalSiteData,
    slugArray: string[],
    pageNumber: number = 1,
): PageResolutionResult {
    const pathSuffix = slugArray.length > 0 ? slugArray.join('/') : 'index';
    const potentialPagePath = `content/${pathSuffix}.md`;

    const targetNode = findNodeByPath(siteData.manifest.structure, potentialPagePath);

    if (!targetNode) {
        return {
            type: PageType.NotFound,
            errorMessage: `No page found at the path: /${slugArray.join('/')}`,
        };
    }

    const contentFile = siteData.contentFiles?.find(f => f.path === targetNode.path);
    if (!contentFile) {
        return {
            type: PageType.NotFound,
            errorMessage: `Manifest references "${targetNode.path}" but its content file is missing.`,
        };
    }

    let collectionItems: ParsedMarkdownFile[] | undefined = undefined;
    let pagination: PaginationData | undefined = undefined;

    const collectionConfig = contentFile.frontmatter.collection;
    if (collectionConfig) {
        const allItems = executeCollectionQuery(collectionConfig, targetNode, siteData);
        const itemsPerPage = collectionConfig.items_per_page;

        if (itemsPerPage && itemsPerPage > 0) {
            // Handle pagination if configured
            const totalItems = allItems.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const currentPage = Math.max(1, Math.min(pageNumber, totalPages));

            const startIndex = (currentPage - 1) * itemsPerPage;
            collectionItems = allItems.slice(startIndex, startIndex + itemsPerPage);

            const pageUrlSegment = getUrlForNode(targetNode, false);
            const baseUrl = pageUrlSegment ? `/${pageUrlSegment}` : '/';

            pagination = {
                currentPage,
                totalPages,
                totalItems,
                hasPrevPage: currentPage > 1,
                hasNextPage: currentPage < totalPages,
                prevPageUrl: currentPage > 1 ? `${baseUrl}?page=${currentPage - 1}` : undefined,
                nextPageUrl: currentPage < totalPages ? `${baseUrl}?page=${currentPage + 1}` : undefined,
            };
        } else {
            // If no pagination, just return all items
            collectionItems = allItems;
        }
    }

    // The result object has been renamed for clarity ('viewItems' -> 'collectionItems')
    return {
        type: PageType.SinglePage,
        pageTitle: contentFile.frontmatter.title,
        contentFile: contentFile,
        layoutPath: contentFile.frontmatter.layout || DEFAULT_PAGE_LAYOUT_PATH,
        collectionItems: collectionItems,
        pagination: pagination,
    };
}

================================================================================

File: core/services/siteSecrets.service.ts
// src/core/services/siteSecrets.service.ts
import localforage from 'localforage';

const DB_NAME = 'SignumDB';

// This store is NEVER included in the site export.
const siteSecretsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteSecrets',
});

// Define the shape of the secrets object for a site.
export interface SiteSecrets {
  cloudinary?: {
    uploadPreset?: string;
  };
}

/**
 * Loads the secrets object for a specific site from the database.
 * @param siteId The ID of the site.
 * @returns A promise that resolves to the SiteSecrets object, or an empty object.
 */
export async function loadSiteSecretsFromDb(siteId: string): Promise<SiteSecrets> {
  return (await siteSecretsStore.getItem<SiteSecrets>(siteId)) || {};
}

/**
 * Saves the complete secrets object for a specific site to the database.
 * @param siteId The ID of the site.
 * @param secrets The SiteSecrets object to save.
 */
export async function saveSiteSecretsToDb(siteId: string, secrets: SiteSecrets): Promise<void> {
  await siteSecretsStore.setItem(siteId, secrets);
}

================================================================================

File: core/services/fileTree.service.ts
// src/core/services/fileTree.service.ts
import { StructureNode } from '@/types';

/**
 * Finds a node in a structure tree by its exact `path`.
 */
export function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) return node;
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) return found;
    }
  }
  return undefined;
}

/**
 * Recursively traverses the structure tree and collects all nodes.
 */
export function flattenStructureToRenderableNodes(nodes: StructureNode[]): StructureNode[] {
  let renderableNodes: StructureNode[] = [];
  for (const node of nodes) {
    renderableNodes.push(node);
    if (node.children) {
      renderableNodes = renderableNodes.concat(flattenStructureToRenderableNodes(node.children));
    }
  }
  return renderableNodes;
}

/**
 * Gets the parent directory path for a given file path.
 */
export function getParentPath(path: string): string {
  if (!path.includes('/')) return 'content';
  return path.substring(0, path.lastIndexOf('/'));
}

/**
 * Finds and removes a node from a tree structure.
 */
export function findAndRemoveNode(nodes: StructureNode[], path: string): { found: StructureNode | null, tree: StructureNode[] } {
  let found: StructureNode | null = null;
  const filterRecursively = (currentNodes: StructureNode[]): StructureNode[] => currentNodes.reduce((acc: StructureNode[], node) => {
    if (node.path === path) {
      found = node;
      return acc;
    }
    if (node.children) node.children = filterRecursively(node.children);
    acc.push(node);
    return acc;
  }, []);
  const newTree = filterRecursively(nodes);
  return { found, tree: newTree };
}

/**
 * Recursively updates the path of a node and all of its descendants.
 */
export function updatePathsRecursively(node: StructureNode, newParentPath: string): StructureNode {
  const oldFileName = node.path.substring(node.path.lastIndexOf('/'));
  const newPath = `${newParentPath}${oldFileName}`;
  const newSlug = newPath.replace(/^content\//, '').replace(/\.md$/, '');
  const updatedNode: StructureNode = { ...node, path: newPath, slug: newSlug };
  if (updatedNode.children) {
    const newChildsParentPath = newPath.replace(/\.md$/, '');
    updatedNode.children = updatedNode.children.map(child => updatePathsRecursively(child, newChildsParentPath));
  }
  return updatedNode;
}

/**
 * Finds all direct child nodes of a given parent node path.
 */
export function findChildNodes(nodes: StructureNode[], parentPath: string): StructureNode[] {
    const parentNode = findNodeByPath(nodes, parentPath);
    return parentNode?.children || [];
}

/**
 * Finds the parent of a node in the structure tree.
 */
export function findParentOfNode(nodes: StructureNode[], path: string, parent: StructureNode | null = null): StructureNode | null {
    for (const node of nodes) {
        if (node.path === path) return parent;
        if (node.children) {
            const found = findParentOfNode(node.children, path, node);
            if (found) return found;
        }
    }
    return null;
}

/**
 * Updates a specific node's children within a larger tree structure.
 */
export function updateNodeInChildren(nodes: StructureNode[], parentPath: string, newChildren: StructureNode[]): StructureNode[] {
    return nodes.map(node => {
        if (node.path === parentPath) {
            return { ...node, children: newChildren };
        }
        if (node.children) {
            return { ...node, children: updateNodeInChildren(node.children, parentPath, newChildren) };
        }
        return node;
    });
}

/**
 * --- FIX: ADDED MISSING FUNCTION ---
 * Recursively traverses a node tree and returns a flat array of all
 * node paths (IDs), including all descendants. This is required for dnd-kit's
 * SortableContext to be aware of all possible draggable items.
 *
 * @param {StructureNode[]} nodes - The array of nodes to flatten.
 * @returns {string[]} A flat array of all descendant paths.
 */
export function getDescendantIds(nodes: StructureNode[]): string[] {
  return nodes.flatMap(node => [
    node.path,
    ...(node.children ? getDescendantIds(node.children) : []),
  ]);
}

================================================================================

File: core/services/images/images.service.ts
// src/core/services/images/images.service.ts

// <-- FIX: Import all necessary types from the central types file.
import { ImageService, Manifest } from '@/types';

import { localImageService } from './localImage.service';
import { cloudinaryImageService } from './cloudinaryImage.service';

const services: Record<string, ImageService> = {
  local: localImageService,
  cloudinary: cloudinaryImageService,
};

export function getActiveImageService(manifest: Manifest): ImageService {
  // This now correctly type-checks against the updated Manifest interface.
  const serviceId = manifest.settings?.imageService || 'local';
  return services[serviceId] || localImageService;
}

================================================================================

File: core/services/images/types.ts
// src/core/services/theme-engine/helpers/types.ts
import { LocalSiteData } from '@/types';
import Handlebars from 'handlebars';

/**
 * Defines the function signature for a Handlebars helper function within Signum.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
export type SignumHelperFunction = (
  this: any, ...args: any[]
// <-- FIX: The return type now includes a Promise, allowing for async helpers.
) => string | Handlebars.SafeString | boolean | Promise<string | Handlebars.SafeString>;

/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 */
export type SignumHelper = (siteData: LocalSiteData) => Record<string, SignumHelperFunction>;

================================================================================

File: core/services/images/localImage.service.ts
// src/core/services/images/localImage.service.ts

import { ImageService, ImageRef, ImageTransformOptions, Manifest } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { slugify } from '@/lib/utils';
import { getCachedDerivative, setCachedDerivative, getAllCacheKeys } from './derivativeCache.service';
import imageCompression from 'browser-image-compression';

const sourceImageCache = new Map<string, Blob>();
const processingPromises = new Map<string, Promise<Blob>>();

const getImageDimensions = (blob: Blob): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
      URL.revokeObjectURL(url);
    };
    img.onerror = (err) => {
      reject(err);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });
};

class LocalImageService implements ImageService {
  id = 'local';
  name = 'Store in Site Bundle';

  async upload(file: File, siteId: string): Promise<ImageRef> {
    const extIndex = file.name.lastIndexOf('.');
    if (extIndex === -1) {
      throw new Error("Uploaded file is missing an extension.");
    }
    const baseName = file.name.substring(0, extIndex);
    const extension = file.name.substring(extIndex);
    const slugifiedBaseName = slugify(baseName);
    const fileName = `${Date.now()}-${slugifiedBaseName}${extension}`;
    const relativePath = `assets/images/${fileName}`;

    await localSiteFs.saveImageAsset(siteId, relativePath, file as Blob);
    const { width, height } = await getImageDimensions(file as Blob);

    return {
      serviceId: 'local',
      src: relativePath,
      alt: file.name,
      width,
      height,
    };
  }

  /**
   * Main method to get a displayable URL for an image.
   * This has been refactored into a single, unified pipeline to prevent deadlocks.
   */
  async getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions, isExport: boolean): Promise<string> {
    const { width, height, crop = 'scale', gravity = 'center' } = options;
    const extIndex = ref.src.lastIndexOf('.');
    if (extIndex === -1) throw new Error("Source image has no extension.");
    
    const pathWithoutExt = ref.src.substring(0, extIndex);
    const ext = ref.src.substring(extIndex);
    const derivativePath = `${pathWithoutExt}_w${width || 'auto'}_h${height || 'auto'}_c-${crop}_g-${gravity}${ext}`;

    // The core logic is now in a separate, private method.
    const finalBlob = await this.getOrProcessDerivative(manifest.siteId, ref.src, derivativePath, options);
    
    // After getting the blob, simply decide what to return based on the context.
    return isExport ? derivativePath : URL.createObjectURL(finalBlob);
  }

  /**
   * The core processing pipeline. It checks all caches and processes the image
   * only if absolutely necessary, preventing race conditions.
   */
  private async getOrProcessDerivative(siteId: string, srcPath: string, cacheKey: string, options: ImageTransformOptions): Promise<Blob> {
    // 1. Check persistent cache for a completed job.
    const cachedBlob = await getCachedDerivative(cacheKey);
    if (cachedBlob) {
      return cachedBlob;
    }

    // 2. Check in-memory cache for an in-progress job.
    if (processingPromises.has(cacheKey)) {
      return processingPromises.get(cacheKey)!;
    }
    
    // 3. If no cache hit, create and store a new processing promise.
    const processingPromise = (async (): Promise<Blob> => {
      try {
        const sourceBlob = await this.getSourceBlob(siteId, srcPath);

        const compressionOptions: any = {
            maxSizeMB: 1.5,
            initialQuality: 0.8,
            useWebWorker: true,
            exifOrientation: -1,
        };
        const { width, height, crop } = options;
        if (crop === 'fill' && width && height) {
          compressionOptions.maxWidth = width;
          compressionOptions.maxHeight = height;
        } else {
          compressionOptions.maxWidthOrHeight = Math.max(width || 0, height || 0) || undefined;
        }

        console.log(`[ImageService] Processing new derivative: ${cacheKey}`);
        const derivativeBlob = await imageCompression(sourceBlob as File, compressionOptions);
        
        await setCachedDerivative(cacheKey, derivativeBlob);
        
        return derivativeBlob;
      } finally {
        processingPromises.delete(cacheKey);
      }
    })();

    processingPromises.set(cacheKey, processingPromise);
    return processingPromise;
  }

  private async getSourceBlob(siteId: string, srcPath: string): Promise<Blob> {
    let sourceBlob = sourceImageCache.get(srcPath);
    if (!sourceBlob) {
        const blobData = await localSiteFs.getImageAsset(siteId, srcPath);
        if (!blobData) throw new Error(`Source image not found in local storage: ${srcPath}`);
        sourceBlob = blobData;
        sourceImageCache.set(srcPath, sourceBlob);
    }
    return sourceBlob;
  }

  async getExportableAssets(siteId: string, allImageRefs: ImageRef[]): Promise<{ path: string; data: Blob; }[]> {
    const exportableMap = new Map<string, Blob>();
    
    // Add all original source images
    for (const ref of allImageRefs) {
      if (ref.serviceId === 'local' && !exportableMap.has(ref.src)) {
        const sourceBlob = await localSiteFs.getImageAsset(siteId, ref.src);
        if (sourceBlob) {
          exportableMap.set(ref.src, sourceBlob);
        }
      }
    }
    
    // Add all derivatives from the persistent cache
    const derivativeKeys = await getAllCacheKeys();
    for (const key of derivativeKeys) {
      if (!exportableMap.has(key)) {
        const derivativeBlob = await getCachedDerivative(key);
        if (derivativeBlob) {
          exportableMap.set(key, derivativeBlob);
        }
      }
    }
    
    return Array.from(exportableMap.entries()).map(([path, data]) => ({ path, data }));
  }
}

export const localImageService = new LocalImageService();

================================================================================

File: core/services/images/derivativeCache.service.ts
// src/core/services/images/derivativeCache.service.ts
import localforage from 'localforage';

const derivativeCacheStore = localforage.createInstance({
  name: 'SignumDB',
  storeName: 'derivativeCacheStore',
});

/**
 * Retrieves a cached image derivative from IndexedDB by its key.
 * @param key The unique key for the derivative.
 * @returns A promise that resolves to the derivative Blob, or null if not found.
 */
export async function getCachedDerivative(key: string): Promise<Blob | null> {
  return derivativeCacheStore.getItem<Blob>(key);
}

/**
 * Stores an image derivative Blob in IndexedDB.
 * @param key The unique key for the derivative.
 * @param blob The derivative image data as a Blob.
 */
export async function setCachedDerivative(key: string, blob: Blob): Promise<void> {
  await derivativeCacheStore.setItem(key, blob);
}

/**
 * --- FIX: Add the missing exported function. ---
 * Retrieves all keys currently stored in the derivative cache. This is used
 * by the exporter to bundle all generated images.
 * @returns A promise that resolves to an array of all keys (strings).
 */
export async function getAllCacheKeys(): Promise<string[]> {
  return derivativeCacheStore.keys();
}

================================================================================

File: core/services/images/imageCache.service.ts
// src/core/services/images/derivativeCache.service.ts
import localforage from 'localforage';

const derivativeCacheStore = localforage.createInstance({
  name: 'SignumDB',
  storeName: 'derivativeCacheStore',
});

/**
 * Retrieves a cached image derivative from IndexedDB by its key.
 * @param key The unique key for the derivative.
 * @returns A promise that resolves to the derivative Blob, or null if not found.
 */
export async function getCachedDerivative(key: string): Promise<Blob | null> {
  return derivativeCacheStore.getItem<Blob>(key);
}

/**
 * Stores an image derivative Blob in IndexedDB.
 * @param key The unique key for the derivative.
 * @param blob The derivative image data as a Blob.
 */
export async function setCachedDerivative(key: string, blob: Blob): Promise<void> {
  await derivativeCacheStore.setItem(key, blob);
}

/**
 * Retrieves all keys currently stored in the derivative cache.
 * @returns A promise that resolves to an array of all keys (strings).
 */
export async function getAllCacheKeys(): Promise<string[]> {
  return derivativeCacheStore.keys();
}

================================================================================

File: core/services/images/cloudinaryImage.service.ts
// src/core/services/images/cloudinaryImage.service.ts

import { ImageService, ImageRef, ImageTransformOptions, Manifest } from '@/types';
import { useAppStore } from '@/core/state/useAppStore';
import { Cloudinary } from "@cloudinary/url-gen";
import { fill, fit, scale } from "@cloudinary/url-gen/actions/resize";
import { Gravity } from "@cloudinary/url-gen/qualifiers/gravity";
import { format, quality } from "@cloudinary/url-gen/actions/delivery";

/**
 * A type declaration for the Cloudinary Upload Widget.
 * In a real application, you would import this from its own package.
 */
declare const cloudinary: {
  createUploadWidget: (
    options: any,
    callback: (error: any, result: any) => void
  ) => {
    open: () => void;
    close: () => void;
  };
};

class CloudinaryImageService implements ImageService {
  id = 'cloudinary';
  name = 'Upload to Cloudinary';

  async upload(file: File, siteId: string): Promise<ImageRef> {
    const site = useAppStore.getState().getSiteById(siteId);
    if (!site) {
      throw new Error(`Site with ID "${siteId}" not found in state.`);
    }

    const cloudName = site.manifest?.settings?.cloudinary?.cloudName;
    const uploadPreset = site.secrets?.cloudinary?.uploadPreset;

    if (!cloudName || !uploadPreset) {
      throw new Error("Cloudinary Cloud Name and Upload Preset must be configured in your site's image settings.");
    }

    return new Promise((resolve, reject) => {
      const widget = cloudinary.createUploadWidget(
        {
          cloudName: cloudName,
          uploadPreset: uploadPreset,
          sources: ['local', 'url', 'camera'],
          multiple: false,
        },
        (error, result) => {
          if (error) {
            console.error('Cloudinary Upload Error:', error);
            widget.close();
            return reject(new Error('Image upload failed. Please try again.'));
          }

          if (result && result.event === 'success') {
            const { public_id, version, format, width, height } = result.info;
            // The 'src' we store is just the public ID with folder structure.
            // The version is handled by the SDK.
            const srcPath = public_id;
            
            widget.close();
            resolve({
              serviceId: 'cloudinary',
              src: srcPath,
              alt: result.info.original_filename || 'Uploaded image',
              width,
              height,
            });
          }
        }
      );
      widget.open();
    });
  }

  async getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions, isExport: boolean): Promise<string> {
    const cloudName = manifest.settings?.cloudinary?.cloudName;
    if (!cloudName) { /* error handling */ }
    
    const cld = new Cloudinary({ cloud: { cloudName: cloudName } });
    const cldImage = cld.image(ref.src);

    const { width, height, crop = 'scale', gravity } = options;

    switch (crop) {
        case 'fill':
            const fillResize = fill(width, height);
            
            // --- FIX: Map our simple gravity terms to the correct SDK methods ---
            if (gravity === 'auto') {
                fillResize.gravity(Gravity.autoGravity());
            } else if (gravity && ['north', 'south', 'east', 'west'].includes(gravity)) {
                // For cardinal directions, use compass
                fillResize.gravity(Gravity.compass(gravity));
            } else if (gravity === 'center') {
                // For center, use the correctly named xyCenter
                fillResize.gravity(Gravity.xyCenter());
            }
            // If no gravity is specified, Cloudinary defaults to center, which is fine.

            cldImage.resize(fillResize);
            break;
        case 'fit':
            cldImage.resize(fit(width, height));
            break;
        case 'scale':
        default:
            cldImage.resize(scale(width, height));
            break;
    }


    // Use the correct delivery and quality actions
    cldImage.delivery(format('auto')).delivery(quality('auto'));
    
    return cldImage.toURL();
  }

  async getExportableAssets(siteId: string, allImageRefs: ImageRef[]): Promise<{ path: string; data: Blob; }[]> {
    return Promise.resolve([]);
  }
}

export const cloudinaryImageService = new CloudinaryImageService();

================================================================================

File: core/services/theme-engine/themeEngine.service.ts
// src/core/services/theme-engine/themeEngine.service.ts
import Handlebars from 'handlebars';
import {
    LocalSiteData,
    PageResolutionResult,
    PageType,
    ImageRef,
} from '@/types';
import {
    getJsonAsset,
    getAvailableLayouts,
    ThemeManifest,
    AssetFile,
    getAssetContent,
} from '@/core/services/configHelpers.service';
import { coreHelpers } from './helpers';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { generateNavLinks } from '@/core/services/navigationStructure.service';
import { getActiveImageService } from '@/core/services/images/images.service';


// --- Type Definitions ---
export interface RenderOptions {
  siteRootPath: string;
  isExport: boolean;
  relativeAssetPath?: string;
}

// --- Helper Registration ---
function registerCoreHelpers(siteData: LocalSiteData) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((Handlebars as any)._helpersRegistered) return;

    for (const helperFactory of coreHelpers) {
        const helperMap = helperFactory(siteData);
        for (const helperName in helperMap) {
            Handlebars.registerHelper(helperName, helperMap[helperName]);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Handlebars as any)._helpersRegistered = true;
}

/**
 * Pre-compiles and caches all available layout templates and theme partials.
 * This is crucial for performance and allows helpers to synchronously access templates during rendering.
 * @param {LocalSiteData} siteData - The complete site data.
 */
async function cacheAllTemplates(siteData: LocalSiteData) {
    // Clear all existing partials to ensure a clean state
    for (const partial in Handlebars.partials) {
        if (Object.prototype.hasOwnProperty.call(Handlebars.partials, partial)) {
            Handlebars.unregisterPartial(partial);
        }
    }

    const { manifest } = siteData;

    // 1. Get ALL layouts of ALL types (page, list, item).
    const allLayouts = await getAvailableLayouts(siteData);

    // 2. Loop through every layout and register its main template as a partial using its ID.
    const layoutPromises = allLayouts.map(async (layoutManifest) => {
        if (!layoutManifest?.files) return;

        const templateFile = layoutManifest.files.find((f: AssetFile) => f.type === 'template');
        if (templateFile) {
            const templateSource = await getAssetContent(siteData, 'layout', layoutManifest.id, templateFile.path);
            if (templateSource) {
                // Register the partial using the layout's ID (e.g., 'page', 'listing', 'teaser').
                Handlebars.registerPartial(layoutManifest.id, templateSource);
            }
        }
    });

    // 3. Register the theme's global partials (header, footer, head).
    const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', manifest.theme.name, 'theme.json');
    const themePartialPromises = (themeManifest?.files || [])
        .filter((file: AssetFile) => file.type === 'partial' && file.name)
        .map(async (partial) => {
            const templateSource = await getAssetContent(siteData, 'theme', manifest.theme.name, partial.path);
            if (templateSource) {
                Handlebars.registerPartial(partial.name!, templateSource);
            }
        });

    await Promise.all([...layoutPromises, ...themePartialPromises]);
}

/**
 * Renders a resolved page into a full HTML string based on the active theme and assets.
 */
export async function render(siteData: LocalSiteData, resolution: PageResolutionResult, options: RenderOptions): Promise<string> {
    if (resolution.type === PageType.NotFound) {
      // You can create a simple 404 template or just return a basic error message.
      return `<h1>404 - Not Found</h1><p>${resolution.errorMessage}</p>`;
  }
  registerCoreHelpers(siteData);
  await cacheAllTemplates(siteData);

  if (!siteData.contentFiles) { /* error handling */ }

  const { manifest } = siteData;
  const themePath = manifest.theme.name;
  const pageLayoutPath = resolution.layoutPath;

  // --- STEP 1: Render the main body content first ---
  // The body render might call the async `{{{image}}}` helper, so we must await it.
  const pageLayoutSource = Handlebars.partials[pageLayoutPath];
  if (!pageLayoutSource) { /* error handling */ }
  const pageLayoutTemplate = Handlebars.compile(pageLayoutSource);
  
  // This render pass populates the image derivative cache.
  const bodyHtml = await pageLayoutTemplate({
    ...resolution,
    options: options // Pass options down for the image helper
  });


  // --- STEP 2: Resolve ALL top-level asynchronous data ---
    const currentPageExportPath = getUrlForNode(resolution.contentFile, siteData.manifest, true);
    const navLinks = generateNavLinks(siteData, currentPageExportPath, options);
  const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
  const canonicalUrl = new URL(currentPageExportPath, siteBaseUrl).href;
  const baseUrl = options.isExport ? (options.relativeAssetPath ?? '') : (typeof window !== 'undefined' ? window.location.origin : '');

  // Resolve logo and favicon URLs, passing the isExport flag.
  let logoUrl: string | undefined = undefined;
  if (siteData.manifest.logo) {
      try {
          const service = getActiveImageService(siteData.manifest);
          logoUrl = await service.getDisplayUrl(siteData.manifest, siteData.manifest.logo, { height: 32 }, options.isExport);
      } catch (e) { console.warn("Could not generate logo URL:", e); }
  }
  
  let faviconUrl: string | undefined = undefined;
  if (siteData.manifest.favicon) {
      try {
          const service = getActiveImageService(siteData.manifest);
          faviconUrl = await service.getDisplayUrl(siteData.manifest, siteData.manifest.favicon, { width: 32, height: 32 }, options.isExport);
      } catch (e) { console.warn("Could not generate favicon URL:", e); }
  }

  let styleOverrides = '';
  if (manifest.theme.config && Object.keys(manifest.theme.config).length > 0) { /* style logic */ }


  // --- STEP 3: Render the final document with all data now resolved ---
   const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', themePath, 'theme.json');
  if (!themeManifest) return 'Error: Could not load theme manifest.';
   const baseTemplateFile = themeManifest.files.find((f: AssetFile) => f.type === 'base');
  if (!baseTemplateFile) return 'Error: Theme manifest is missing a file with type "base".';
  
  const baseTemplateSource = await getAssetContent(siteData, 'theme', themePath, baseTemplateFile.path);
  if (!baseTemplateSource) return 'Error: Could not load base template source.';
  const baseTemplate = Handlebars.compile(baseTemplateSource);

  const finalContext = {
      manifest,
      navLinks,
      year: new Date().getFullYear(),
      headContext: {
          // All these accesses are now safe.
          pageTitle: resolution.pageTitle,
          manifest: manifest,
          contentFile: resolution.contentFile,
          canonicalUrl: canonicalUrl,
          baseUrl: baseUrl,
          styleOverrides: new Handlebars.SafeString(styleOverrides),
          faviconUrl: faviconUrl,
      },
      body: new Handlebars.SafeString(bodyHtml),
      logoUrl: logoUrl,
      options: options, // For any helpers still needing it
      ...resolution,
  };

  // This final render is now synchronous because all async data has been prepared.
  const finalHtml = baseTemplate(finalContext);

  return finalHtml;
}

================================================================================

File: core/services/theme-engine/helpers/strUtil.helper.ts
// src/lib/theme-helpers/strUtil.helper.ts
import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const strUtilHelper: SignumHelper = () => ({
  /**
   * A generic string utility helper for common text manipulations.
   * @example {{str-util some.text op="truncate" len=100}}
   * @example {{str-util some.text op="uppercase"}}
   */
  'str-util': function(input: string, options: HelperOptions): string {
    if (!input || typeof input !== 'string') return '';
  
    const op = options.hash.op;
  
    switch (op) {
      case 'truncate':
        const len = options.hash.len || 140;
        if (input.length <= len) return input;
        return input.substring(0, len) + '…';
      case 'uppercase':
        return input.toUpperCase();
      case 'lowercase':
        return input.toLowerCase();
      default:
        return input;
    }
  }
});

================================================================================

File: core/services/theme-engine/helpers/concat.helper.ts
// src/core/services/theme-engine/helpers/concat.helper.ts

import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const concatHelper: SignumHelper = () => ({
  /**
   * Concatenates multiple string arguments into a single string.
   *
   * @example
   * {{concat "Hello" " " "World"}} -> "Hello World"
   *
   * @example
   * <img alt=(concat @root.manifest.title " Logo")>
   */
  concat: function(...args: any[]): string {
    // The last argument provided by Handlebars is the 'options' object. We don't need it.
    const options = args.pop() as HelperOptions;

    // Join all other arguments with an empty string.
    return args.join('');
  },
});

================================================================================

File: core/services/theme-engine/helpers/query.helper.ts
// src/lib/theme-helpers/query.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { PageResolutionResult } from '@/types';

export const queryHelper: SignumHelper = (siteData) => ({
  /**
   * Fetches, filters, and sorts a list of content items from a collection.
   * The resulting array is made available to the inner block of the helper.
   * @param {HelperOptions} options - The Handlebars options object.
   * @returns The rendered block content.
   *
   * @example
   * {{#query source_collection="blog" limit=5 as |posts|}}
   *   {{#each posts}} ... {{/each}}
   * {{/query}}
   */
  query: function(this: PageResolutionResult, options: Handlebars.HelperOptions) {
    const config = options.hash;

    // 1. Validate that a source collection was provided.
    const sourceCollectionSlug = config.source_collection;
    if (!sourceCollectionSlug) {
      console.warn("Query helper called without a 'source_collection'.");
      return options.inverse(this); // Render the {{else}} block if it exists.
    }

    // 2. Find the source collection node in the site's structure.
    const collectionNode = siteData.manifest.structure.find(
        n => n.slug === sourceCollectionSlug
    );
    if (!collectionNode || !collectionNode.children) {
      console.warn(`Query could not find collection with slug: "${sourceCollectionSlug}"`);
      return options.inverse(this);
    }
    
    // 3. Get all content files associated with that collection.
    const childPaths = new Set(collectionNode.children.map(c => c.path));
    let items = (siteData.contentFiles ?? []).filter(f => childPaths.has(f.path));

    // 4. (Future) Apply any filters here.
    // e.g., if (config.filter_by_tag) { ... }

    // 5. Sort the resulting items.
    const sortBy = config.sort_by || 'date';
    const sortOrder = config.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    items.sort((a, b) => {
      const valA = a.frontmatter[sortBy];
      const valB = b.frontmatter[sortBy];

      if (sortBy === 'date') {
        const dateA = valA ? new Date(valA as string).getTime() : 0;
        const dateB = valB ? new Date(valB as string).getTime() : 0;
        if (isNaN(dateA) || isNaN(dateB)) return 0;
        return (dateA - dateB) * orderModifier;
      }
      if (typeof valA === 'string' && typeof valB === 'string') {
        return valA.localeCompare(valB) * orderModifier;
      }
      if (typeof valA === 'number' && typeof valB === 'number') {
        return (valA - valB) * orderModifier;
      }
      return 0;
    });

    // 6. Limit the number of results.
    if (config.limit) {
      const limit = parseInt(config.limit, 10);
      if (!isNaN(limit)) {
        items = items.slice(0, limit);
      }
    }

    // 7. Render the inner block, passing the queried items as a block parameter.
    // This makes the `as |posts|` syntax work.
    if (options.data && options.fn) {
        const data = Handlebars.createFrame(options.data);
        const blockParamName = options.data.blockParams?.[0];
        if (blockParamName) {
            data[blockParamName] = items;
        }
        return options.fn(items, { data });
    }
    
    // Fallback if no block parameter is used.
    return options.fn(items);
  }
});

================================================================================

File: core/services/theme-engine/helpers/markdown.helper.ts
// src/lib/theme-helpers/markdown.helper.ts
import { SignumHelper } from './types';
import Handlebars from 'handlebars';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

export const markdownHelper: SignumHelper = () => ({
  /**
   * Safely renders a string of Markdown into HTML.
   * @example {{{markdown some.body_content}}}
   */
  markdown: function(markdownString: string): Handlebars.SafeString {
    if (!markdownString) return new Handlebars.SafeString('');

    // Use marked to parse, then DOMPurify to sanitize against XSS attacks.
    const unsafeHtml = marked.parse(markdownString, { async: false }) as string;
    const safeHtml = DOMPurify.sanitize(unsafeHtml);

    return new Handlebars.SafeString(safeHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/comparison.helper.ts
// src/lib/theme-helpers/comparison.helper.ts
import { SignumHelper } from './types';

// This code is now valid because SignumHelperFunction accepts a boolean return.
export const comparisonHelpers: SignumHelper = () => ({
  eq: (a, b) => a === b,
  gt: (a, b) => a > b,
  lt: (a, b) => a < b,
});

================================================================================

File: core/services/theme-engine/helpers/getUrl.helper.ts
import { SignumHelper } from './types';
import { getUrlForNode as getUrlUtil } from '@/core/services/urlUtils.service';
import { StructureNode } from '@/types';

export const getUrlHelper: SignumHelper = () => ({
  /**
   * A Handlebars helper to expose the getUrlForNode utility to templates.
   */
  getUrlForNode: function(node: StructureNode, isExport: boolean): string {
    return getUrlUtil(node, isExport);
  }
});

================================================================================

File: core/services/theme-engine/helpers/types.ts
import { LocalSiteData } from '@/types';
import Handlebars from 'handlebars';

/**
 * Defines the function signature for a Handlebars helper function within Signum.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
export type SignumHelperFunction = (
  this: any,
  ...args: any[]
) => string | Handlebars.SafeString | boolean | Promise<Handlebars.SafeString>;

/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 */
export type SignumHelper = (siteData: LocalSiteData) => Record<string, SignumHelperFunction>;

================================================================================

File: core/services/theme-engine/helpers/pager.helper.ts
// src/core/services/theme-engine/helpers/pager.helper.ts

import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { PaginationData } from '@/types';

/**
 * Renders a complete pagination control component.
 * It generates 'Previous' and 'Next' links and a 'Page X of Y' indicator.
 * The links are disabled when not applicable (e.g., on the first or last page).
 * 
 * @param {PaginationData} pagination - The pagination data object from the page resolver.
 * @returns {Handlebars.SafeString} The full HTML for the pager component.
 *
 * @example
 * {{{pager pagination}}}
 */
export const pagerHelper: SignumHelper = () => ({
  pager: function(pagination: PaginationData | undefined): Handlebars.SafeString {
    if (!pagination || pagination.totalPages <= 1) {
      return new Handlebars.SafeString('');
    }

    const prevLink = pagination.hasPrevPage
      ? `<a href="${pagination.prevPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">‹ Previous</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50">‹ Previous</span>`;

    const nextLink = pagination.hasNextPage
      ? `<a href="${pagination.nextPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">Next ›</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50">Next ›</span>`;
    
    const pageIndicator = `<div class="f6 mid-gray">Page ${pagination.currentPage} of ${pagination.totalPages}</div>`;

    const pagerHtml = `
      <div class="flex items-center justify-between mt4 pt3 bt b--black-10">
        <div>${prevLink}</div>
        <div>${pageIndicator}</div>
        <div>${nextLink}</div>
      </div>
    `;

    return new Handlebars.SafeString(pagerHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/assign.helper.ts
import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const assignHelper: SignumHelper = () => ({
  /**
   * A Handlebars helper to add a new property to an object's context.
   * Useful for augmenting data inside a loop.
   * This version uses generics for full type safety.
   *
   * @template T The type of the `this` context.
   * @template K The type of the object being extended.
   * @template V The type of the value being added.
   */
  assign: function<T, K extends object, V>(
    this: T,
    object: K,
    key: string,
    value: V,
    options: HelperOptions,
  ): string {
    // Create a new object by spreading the original and adding the new key-value pair.
    const newContext = { ...object, [key]: value };

    // Execute the inner block of the helper with the new, augmented context.
    return options.fn(newContext);
  },
});

================================================================================

File: core/services/theme-engine/helpers/index.ts
// src/lib/theme-helpers/index.ts
// ... (other helper imports)
import { queryHelper } from './query.helper';
import { comparisonHelpers } from './comparison.helper';
import { renderLayoutForItemHelper } from './renderLayoutForItem.helper';
import { markdownHelper } from './markdown.helper';
import { strUtilHelper } from './strUtil.helper';
import { formatDateHelper } from './formatDate.helper';
import { pagerHelper } from './pager.helper';
import { SignumHelper } from './types';
import { getUrlHelper } from './getUrl.helper';
import { assignHelper } from './assign.helper';
import { imageHelper } from './image.helper';
import { concatHelper } from './concat.helper';

export const coreHelpers: SignumHelper[] = [
  queryHelper,
  strUtilHelper,
  formatDateHelper,
  comparisonHelpers,
  markdownHelper,
  renderLayoutForItemHelper, 
  pagerHelper,
  getUrlHelper,
  assignHelper,
  imageHelper,
  concatHelper
];

================================================================================

File: core/services/theme-engine/helpers/formatDate.helper.ts
// src/lib/theme-helpers/formatDate.helper.ts
import { SignumHelper } from './types';

export const formatDateHelper: SignumHelper = () => ({
  /**
   * Formats a date string into a more readable format.
   * @example {{formatDate some.date_string}}
   */
  formatDate: function(dateString: string | Date): string {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    if (isNaN(date.getTime())) {
      return ''; // Return empty for invalid dates
    }

    return date.toLocaleDateString('en-GB', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  }
});

================================================================================

File: core/services/theme-engine/helpers/renderLayoutForItem.helper.ts
// src/core/services/theme-engine/helpers/renderLayoutForItem.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';
// Import the specific types we need
import { ParsedMarkdownFile, PageResolutionResult } from '@/types';
import { HelperOptions } from 'handlebars';

export const renderLayoutForItemHelper: SignumHelper = () => ({
  /**
   * Renders a specific layout for a single content item.
   * This is used inside a view template's `each` loop.
   * @example {{{render_layout_for_item this layout=../contentFile.frontmatter.collection.item_layout}}}
   */
  render_layout_for_item: function(
    // The 'this' context for a helper is typically the top-level data object
    // passed to the template that contains the helper call. PageResolutionResult is a good, safe type.
    this: PageResolutionResult,
    item: ParsedMarkdownFile,
    options: HelperOptions
  ) {
    const layoutId = options.hash.layout;
    if (!item || !layoutId) {
        return '';
    }

    const layoutTemplateSource = Handlebars.partials[layoutId];

    if (layoutTemplateSource) {
        const layoutTemplate = Handlebars.compile(layoutTemplateSource);
        return new Handlebars.SafeString(layoutTemplate(item));
    }

    console.warn(`[render_layout_for_item] Item layout template "${layoutId}" not found.`);
    return `<!-- Item layout "${layoutId}" not found -->`;
  }
});

================================================================================

File: core/services/theme-engine/helpers/image.helper.ts
// src/core/services/theme-engine/helpers/image.helper.ts

import Handlebars from 'handlebars';
import { SignumHelper } from './types';
// --- FIX: Import ImageTransformOptions along with the other types ---
import { ImageRef, LocalSiteData, ImageTransformOptions } from '@/types';
import { getActiveImageService } from '@/core/services/images/images.service';

interface RootTemplateContext {
  options: {
    isExport: boolean;
  };
}

export const imageHelper: SignumHelper = (siteData: LocalSiteData) => ({
  image: async function(this: any, options: Handlebars.HelperOptions): Promise<Handlebars.SafeString> {
    const rootContext = options.data.root as RootTemplateContext;
    const isExport = rootContext.options?.isExport || false;

    const { src, width, height, crop, gravity, alt, lazy = true, class: className = '' } = options.hash;

    if (!src || typeof src !== 'object' || !('serviceId' in src)) {
      return new Handlebars.SafeString('<!-- Invalid ImageRef provided to image helper -->');
    }

    const imageRef = src as ImageRef;

    try {
      const imageService = getActiveImageService(siteData.manifest);
      
      const transformOptions: ImageTransformOptions = {
        width: width,
        height: height,
        crop: crop,
        gravity: gravity,
      };

      const displayUrl = await imageService.getDisplayUrl(siteData.manifest, imageRef, transformOptions, isExport);
      
      const lazyAttr = lazy ? 'loading="lazy"' : '';
      const altAttr = `alt="${alt || imageRef.alt || ''}"`;
      const classAttr = className ? `class="${className}"` : '';
      const widthAttr = width ? `width="${width}"` : '';
      const heightAttr = height ? `height="${height}"` : '';

      const imgTag = `<img src="${displayUrl}" ${widthAttr} ${heightAttr} ${altAttr} ${classAttr} ${lazyAttr}>`;

      return new Handlebars.SafeString(imgTag);
    } catch (error) {
      console.error(`[ImageHelper] Failed to render image for src: ${imageRef.src}`, error);
      return new Handlebars.SafeString(`<!-- Image render failed: ${(error as Error).message} -->`);
    }
  }
});

================================================================================

File: app/layout.tsx
// src/app/layout.tsx
'use client'; 

import { useEffect, useState, Suspense } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import './globals.css'; 
import { Toaster } from "@/core/components/ui/sonner"; 
import { ThemeProvider } from "@/core/components/ThemeProvider";
import { useInitialiseUIStore } from '@/core/hooks/useInitialiseUIStore';

function AppLoadingIndicator() {
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading Signum...</p>
      </div>
    </div>
  ); 
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  useInitialiseUIStore();
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true); 
    // Initialize the app state from storage only once
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]); 

  // Show the loading indicator only on the client and before initialization is complete
  const showLoading = clientMounted && !isInitialized;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Signum - Decentralized Publishing</title>
      </head>
      <body className="h-full">
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
          {showLoading ? (
            <AppLoadingIndicator />
          ) : (
         
                <Suspense fallback={<AppLoadingIndicator />}>
                  {children}
                </Suspense>
              
          )}
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================================================================================

File: app/page.tsx
// src/app/page.tsx
'use client';

import { Button } from '@/core/components/ui/button';
import { Link } from '@/core/components/ui/link';
import { ShieldCheck, Feather, Zap, Archive, Leaf } from 'lucide-react';

export default function MarketingHomePage() {
  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto px-4 py-16 sm:py-24 text-center">
      <header className="mb-12">
        <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold tracking-tight text-foreground">
          Signum: Own Your Content.
        </h1>
        <p className="mt-4 max-w-2xl mx-auto text-lg sm:text-xl text-muted-foreground">
          A simple, private, and portable publishing platform that puts you back in control.
        </p>
      </header>

      <div className="mb-16">
        <Button asChild size="lg">
          <Link href="/sites">
            Open Dashboard & Get Started
          </Link>
        </Button>
      </div>

      <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 max-w-5xl mx-auto">
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <ShieldCheck className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Private & Secure</h3>
          <p className="text-muted-foreground text-sm">
            No tracking or surveillance by default. Your data is yours.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Feather className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Simple & Focused</h3>
          <p className="text-muted-foreground text-sm">
            A minimal, content-first editor lets you focus on writing.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Zap className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Blazingly Fast</h3>
          <p className="text-muted-foreground text-sm">
            Static sites are fast, reliable, and efficient to host.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Archive className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Truly Portable</h3>
          <p className="text-muted-foreground text-sm">
            Export your entire site anytime. No vendor lock-in, ever.
          </p>
        </div>
      </section>
    </div>
    </>
  );
}

================================================================================

File: app/globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: app/sites/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';

export default function SiteLoaderLayout({ children }: { children: React.ReactNode }) {
  const params = useParams();
  const siteId = params.siteId as string;

  // --- USE THE NEW ACTION ---
  const loadSiteAction = useAppStore(state => state.loadSite);
  
  useEffect(() => {
    if (siteId) {
      // This will now reliably load the manifest and content files.
      loadSiteAction(siteId);
    }
  }, [siteId, loadSiteAction]);

  return <>{children}</>;
}

================================================================================

File: app/sites/page.tsx
// src/app/page.tsx
'use client';

import Link from 'next/link';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { PlusCircle, Edit3, Eye, Trash2, FilePlus2, Leaf } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { toast } from "sonner";

export default function HomePageDashboard() {
  const sites = useAppStore((state) => state.sites);
  const deleteSiteAndState = useAppStore((state) => state.deleteSiteAndState);

  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

  const validSites = sites.filter(site => site && site.manifest);

  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-8 gap-4">
        <h1 className="text-3xl font-bold text-foreground">My Signum Sites</h1>
        <Button asChild size="lg">
          <Link href="/create-site">
            <FilePlus2 className="mr-2 h-5 w-5" /> Create New Site
          </Link>
        </Button>
      </div>

      {validSites.length === 0 ? (
        <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
          <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
          <p className="text-muted-foreground mb-4">Click &quot;Create New Site&quot; to get started.</p>
          <Button asChild>
            <Link href="/create-site">
                <PlusCircle className="mr-2 h-4 w-4" /> Start Creating
            </Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {validSites.map((site) => (
            <div key={site.siteId} className="bg-card border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between">
              <div>
                <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.manifest.title}>
                  {site.manifest.title || "Untitled Site"}
                </h2>
                <p className="text-sm text-muted-foreground mb-4 line-clamp-2" title={site.manifest.description}>
                  {site.manifest.description || 'No description provided.'}
                </p>
              </div>
              <div className="mt-4 flex flex-wrap justify-start gap-2">
                <Button variant="outline" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/`} target="_blank" rel="noopener noreferrer">
                    <Eye className="mr-2 h-4 w-4" /> View
                  </Link>
                </Button>
                <Button variant="default" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/edit`}>
                     <Edit3 className="mr-2 h-4 w-4" /> Edit
                  </Link>
                </Button>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" size="sm">
                      <Trash2 className="mr-2 h-4 w-4" /> Delete
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This will permanently delete &quot;{site.manifest.title || 'this site'}&quot; from local storage.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={() => handleDeleteSite(site.siteId, site.manifest.title || 'Untitled Site')}>
                        Yes, delete site
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
    </>
  );
}

================================================================================

File: app/sites/[siteId]/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import { useEffect, ReactNode } from 'react';
import { useParams, usePathname } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import Link from 'next/link';
import Image from 'next/image';
import { TbEdit, TbSettings } from "react-icons/tb";
import { cn } from '@/lib/utils';

/**
 * The root layout for a single site's backend.
 * This component serves a dual purpose:
 * 1. **Visual Layout:** It provides the persistent vertical toolbar for navigating
 *    between main sections like 'Edit' and 'Settings'.
 * 2. **Data Loader & Context Setter:** It uses a `useEffect` hook to trigger the
 *    loading of the active site's data and sets the `activeSiteId` in the
 *    global store, making it available to all child components.
 */
export default function SingleSiteLayout({ children }: { children: ReactNode }) {
  // --- Part 1: Get router and state management hooks ---
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;

  const loadSiteAction = useAppStore(state => state.loadSite);
  const setActiveSiteIdAction = useAppStore(state => state.setActiveSiteId);

  // --- Part 2: The Data Loading Logic (from the previous loader component) ---
  // This effect runs whenever the siteId from the URL changes.
  useEffect(() => {
    if (siteId) {
      // Trigger the loading of this site's data from storage.
      loadSiteAction(siteId);
      // Announce to the rest of the app which site is currently active.
      setActiveSiteIdAction(siteId);
    }
    
    // Cleanup function: When the user navigates away from this site's
    // section, clear the activeSiteId to prevent stale data display elsewhere.
    return () => {
      setActiveSiteIdAction(null);
    };
  }, [siteId, loadSiteAction, setActiveSiteIdAction]);

  // --- Part 3: The Visual Rendering Logic (from your provided code) ---

  // Determine which navigation link is currently active based on the URL path.
  const isEditorActive = pathname.startsWith(`/sites/${siteId}/edit`);
  const isSettingsActive = pathname.startsWith(`/sites/${siteId}/settings`);

  const navItems = [
    { href: `/sites/${siteId}/edit`, title: 'Edit', icon: TbEdit, isActive: isEditorActive },
    { href: `/sites/${siteId}/settings`, title: 'Settings', icon: TbSettings, isActive: isSettingsActive },
  ];

  return (
    <div className="flex h-screen flex-col lg:flex-row bg-muted/20">
      <aside className="fixed inset-x-0 bottom-0 z-30 flex h-16 w-full shrink-0 border-t bg-background lg:static lg:inset-y-0 lg:left-0 lg:h-full lg:w-[60px] lg:border-r lg:border-t-0">
        <nav className="flex w-full items-center justify-center gap-4 px-2 lg:flex-col lg:justify-start lg:pb-5">
          <Link
            href="/sites"
            title="Dashboard"
            className='lg:flex hidden flex-col items-center w-[60px] h-[60px] border-b'
          >
            <Image src="/signum.svg" width={34} height={34} alt="Signum Logo" className='m-auto'/>
          </Link>
          
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              title={item.title}
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-lg transition-colors',
                item.isActive
                  ? 'bg-accent text-accent-foreground'
                  : 'text-muted-foreground hover:bg-accent/50 hover:text-foreground'
              )}
            >
              <item.icon className="size-6" />
            </Link>
          ))}
        </nav>
      </aside>

      {/* The rest of the page (which will be another layout like ThreeColumnLayout) renders here. */}
      <main className="flex-1 overflow-auto pb-16 lg:pb-0">
        {children}
      </main>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/page.tsx
// src/app/sites/[siteId]/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page now acts as a smart entry point for a site.
// Its only job is to redirect the user to the editor.
export default function SiteRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid polluting the browser's history.
      // This sends the user directly to the site editor.
      router.replace(`/sites/${siteId}/edit`);
    }
  }, [siteId, router]);

  // Display a loading message while the redirect is processed.
  return (
    <div className="flex justify-center items-center h-full">
      <p>Redirecting to editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/layout.tsx
// src/app/sites/[siteId]/settings/layout.tsx
'use client';

import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import SettingsNav from '@/features/site-settings/components/SettingsNav';
import { ReactNode, useEffect } from 'react';
import { useUIStore } from '@/core/state/uiStore';

/**
 * The root layout for the entire settings section.
 * It provides the consistent ThreeColumnLayout structure and manages the
 * global UI state to ensure the left sidebar (with the settings menu) is

 * always visible and the right sidebar is always hidden.
 */
export default function SettingsSectionLayout({ children }: { children: ReactNode }) {
  // --- START: Get state and setters from the UI store ---
  const { 
    leftSidebarContent, 
    rightSidebarContent, 
    setLeftAvailable, 
    setRightAvailable, 
    setRightOpen,
    setLeftSidebarContent,
    setRightSidebarContent 
  } = useUIStore(state => state.sidebar);
  // --- END ---

  // This effect runs once to configure the sidebars for the entire settings section.
  useEffect(() => {
    // 1. Configure availability and state
    setLeftAvailable(true);
    setRightAvailable(false); // No right sidebar in settings
    setRightOpen(false);      // Ensure it's closed

    // 2. Set the static content for the left sidebar
    setLeftSidebarContent(<SettingsNav />);
    // 3. Ensure the right sidebar content is null
    setRightSidebarContent(null);

    // Cleanup when navigating away from the settings section
    return () => {
      setLeftAvailable(false);
      setLeftSidebarContent(null);
    };
  }, [setLeftAvailable, setRightAvailable, setRightOpen, setLeftSidebarContent, setRightSidebarContent]);

  // The final render now uses the ThreeColumnLayout, reading the sidebar
  // content from the store and passing it as props.
  return (
    <ThreeColumnLayout
      leftSidebar={leftSidebarContent}
      rightSidebar={rightSidebarContent} // This will be null, so nothing renders
    >
      {children}
    </ThreeColumnLayout>
  );
}

================================================================================

File: app/sites/[siteId]/settings/page.tsx
// src/app/sites/[siteId]/settings/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { Manifest, ImageRef } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import SiteSettingsForm from '@/features/site-settings/components/SiteSettingsForm'; // Import the main form

// --- FIX: Define the complete form data shape in one place ---
interface PageFormData {
  title: string;
  description: string;
  author: string;
  baseUrl: string;
  logo: ImageRef | undefined;
  favicon: ImageRef | undefined;
}

export default function SiteSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);

  // --- FIX: Manage the entire form's data in a single state object ---
  const [formData, setFormData] = useState<PageFormData | null>(null);

  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);

  // Load all settings from the manifest into the single formData state
  useEffect(() => {
    if (site?.manifest) {
      setIsLoading(true);
      setFormData({
        title: site.manifest.title,
        description: site.manifest.description,
        author: site.manifest.author || '',
        baseUrl: site.manifest.baseUrl || '',
        logo: site.manifest.logo,
        favicon: site.manifest.favicon,
      });
      setHasChanges(false);
      setIsLoading(false);
    }
  }, [site]);
  
  // This single handler receives the complete, updated form data from the child component.
  const handleFormChange = useCallback((newData: PageFormData) => {
    setFormData(newData);
    setHasChanges(true);
  }, []);

  const handleSave = async () => {
    if (!site?.manifest || !formData) {
        toast.error("Form data is not ready. Cannot save.");
        return;
    }
    setIsLoading(true);
    
    // Construct the new manifest directly from the single formData object.
    const newManifest: Manifest = {
      ...site.manifest,
      title: formData.title.trim(),
      description: formData.description.trim(),
      author: formData.author.trim(),
      baseUrl: formData.baseUrl.trim(),
      logo: formData.logo,
      favicon: formData.favicon,
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Site settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving site settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading || !formData) {
    return <div className="p-6">Loading settings...</div>;
  }

  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Site Settings</h1>
        <p className="text-muted-foreground">Manage the core details and identity of your website.</p>
      </div>

      <div className="border-t pt-6">
        {/* --- FIX: Render the single, encapsulated form component --- */}
        <SiteSettingsForm
          siteId={siteId}
          formData={formData}
          onFormChange={handleFormChange}
        />
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/images/page.tsx
// src/app/sites/[siteId]/settings/image/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { Manifest } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { SiteSecrets } from '@/core/services/siteSecrets.service';

type ImageServiceId = 'local' | 'cloudinary';

export default function ImageSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  // Get the site object and the actions from the Zustand store.
  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);
  const updateSiteSecretsAction = useAppStore(state => state.updateSiteSecrets);

  // State for public settings (from manifest)
  const [selectedService, setSelectedService] = useState<ImageServiceId>('local');
  const [cloudinaryCloudName, setCloudinaryCloudName] = useState('');

  // State for private settings (from secrets store)
  const [cloudinaryUploadPreset, setCloudinaryUploadPreset] = useState('');

  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);

  // This effect runs when the component mounts or the site data in the store changes.
  // It populates the form's local state with the authoritative data from the store.
  useEffect(() => {
    if (site?.manifest) {
      setIsLoading(true);

      // Load public settings from the site's manifest
      const { imageService, cloudinary } = site.manifest.settings || {};
      setSelectedService(imageService || 'local');
      setCloudinaryCloudName(cloudinary?.cloudName || '');
      
      // Load private settings from the site's secrets object
      setCloudinaryUploadPreset(site.secrets?.cloudinary?.uploadPreset || '');
      
      setHasChanges(false);
      setIsLoading(false);
    }
  }, [site]); // Re-run this effect if the `site` object in the store is updated
  
  // Generic handler to simplify state updates and track changes
  const handleStateChange = (setter: React.Dispatch<React.SetStateAction<string>>, value: string) => {
    setter(value);
    setHasChanges(true);
  };
  const handleServiceChange = (value: string) => {
    // The value from the Select is a string, which we cast to our specific type.
    setSelectedService(value as ImageServiceId);
    setHasChanges(true);
  };
  
  // This generic handler can still be used for simple text inputs.
  const handleInputChange = (setter: React.Dispatch<React.SetStateAction<string>>, value: string) => {
    setter(value);
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!site?.manifest) {
        toast.error("Site data not available. Cannot save settings.");
        return;
    }
    
    setIsLoading(true);

    // 1. Prepare the new public manifest data
    const newManifest: Manifest = {
      ...site.manifest,
      settings: {
        ...site.manifest.settings,
        imageService: selectedService,
        cloudinary: {
            cloudName: cloudinaryCloudName.trim(),
        },
      },
    };

    // 2. Prepare the new private secrets data
    const newSecrets: SiteSecrets = {
        cloudinary: {
            uploadPreset: cloudinaryUploadPreset.trim(),
        }
    };

    try {
      // 3. Call the store actions to save both data structures.
      // These actions will persist the data and update the global state.
      await updateManifestAction(siteId, newManifest);
      await updateSiteSecretsAction(siteId, newSecrets);
      
      setHasChanges(false);
      // The toast messages are now handled inside the store actions for consistency.
    } catch(error) {
      // The actions will throw on failure, allowing us to catch here if needed.
      console.error("An error occurred during save:", error);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading || !site) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Image Settings</h1>
        <p className="text-muted-foreground">Configure how images are stored and processed for your site.</p>
      </div>

      <div className="border-t pt-6 space-y-6">
        <div className="space-y-2">
            <Label htmlFor="service-select">Image Storage Backend</Label>
            <Select value={selectedService} onValueChange={handleServiceChange}>
                <SelectTrigger id="service-select" className="mt-1">
                    <SelectValue placeholder="Select a service..." />
                </SelectTrigger>
                <SelectContent>
                    <SelectItem value="local">Store in Site Bundle (Default)</SelectItem>
                    <SelectItem value="cloudinary">Upload to Cloudinary</SelectItem>
                </SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">&quot;Local&quot; is best for portability. &quot;Cloudinary&quot; is best for performance.</p>
        </div>
        
        {selectedService === 'cloudinary' && (
            <div className="p-4 border rounded-lg bg-card space-y-4">
                <h3 className="font-semibold text-card-foreground">Cloudinary Settings</h3>
                 <div className="space-y-2">
                    <Label htmlFor="cloud-name">Cloudinary Cloud Name (Public)</Label>
                    <Input
                        id="cloud-name"
                        value={cloudinaryCloudName}
                        onChange={(e) => handleInputChange(setCloudinaryCloudName, e.target.value)}
                        placeholder="e.g., your-cloud-name"
                    />
                     <p className="text-xs text-muted-foreground">This is public and stored in your site&apos;s manifest.</p>
                </div>
                 <div className="space-y-2">
                    <Label htmlFor="upload-preset">Cloudinary Upload Preset (Secret)</Label>
                        <Input
                        id="upload-preset"
                        type="password"
                        value={cloudinaryUploadPreset}
                        onChange={(e) => handleInputChange(setCloudinaryUploadPreset, e.target.value)}
                        placeholder="e.g., ml_default"
                    />
                     <p className="text-xs text-muted-foreground">This is a secret and is stored securely in your browser, not in your public site files.</p>
                </div>
            </div>
        )}
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Image Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/appearance/page.tsx
// src/app/sites/[siteId]/settings/appearance/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import AppearanceSettingsForm from '@/features/site-settings/components/AppearanceSettingsForm';
import { Button } from '@/core/components/ui/button';
import { Manifest, ThemeConfig, ThemeInfo } from '@/types';
import { useEffect, useState, useCallback, useMemo } from 'react';
import { toast } from "sonner";
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { getAvailableThemes } from '@/core/services/configHelpers.service';

export default function AppearanceSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);

  const [selectedThemePath, setSelectedThemePath] = useState<string>('');
  const [themeConfig, setThemeConfig] = useState<ThemeConfig['config']>({});
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  const availableThemes = useMemo(() => {
    return getAvailableThemes(site?.manifest);
  }, [site?.manifest]);

  useEffect(() => {
    if (site?.manifest.theme) {
      setSelectedThemePath(site.manifest.theme.name);
      setThemeConfig(site.manifest.theme.config);
      setHasChanges(false);
    }
  }, [site]);
  
  const handleConfigChange = useCallback((newConfig: ThemeConfig['config']) => {
    setThemeConfig(newConfig);
    setHasChanges(true);
  }, []);

  const handleThemeChange = (newThemePath: string) => {
    setSelectedThemePath(newThemePath);
    setThemeConfig({});
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!site || !site.manifest || !selectedThemePath) return;
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      theme: {
        name: selectedThemePath,
        config: themeConfig,
      },
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Appearance settings saved successfully!');
      setHasChanges(false);
    } catch {
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!site) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  // The component now only returns its content, not the layout.
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Appearance</h1>
        <p className="text-muted-foreground">Customize the visual style of your site.</p>
      </div>

      <div className="border-t pt-6 space-y-6">
        <div>
            <Label htmlFor="theme-select">Active Theme</Label>
            <Select value={selectedThemePath} onValueChange={handleThemeChange}>
                <SelectTrigger id="theme-select" className="mt-1">
                    <SelectValue placeholder="Select a theme..." />
                </SelectTrigger>
                <SelectContent>
                    {availableThemes.map((theme: ThemeInfo) => (
                        <SelectItem key={theme.path} value={theme.path}>
                            {theme.name}
                        </SelectItem>
                    ))}
                </SelectContent>
            </Select>
        </div>
        
        {selectedThemePath && (
            <AppearanceSettingsForm 
                site={site}
                themePath={selectedThemePath}
                themeConfig={themeConfig}
                onConfigChange={handleConfigChange}
            />
        )}
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Appearance'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/layout.tsx
// src/app/sites/[siteId]/edit/layout.tsx
'use client';

import { ReactNode } from 'react';

/**
 * The root layout for the /edit section.
 * In this refactored architecture, this layout has a minimal role.
 * It primarily serves as a container for the editor pages.
 * The context providers and specific layouts are now handled by the
 * page components themselves for better encapsulation.
 */
export default function EditSiteLayout({ children }: { children: ReactNode }) {
  // This layout simply renders the page that Next.js passes to it.
  return <>{children}</>;
}

================================================================================

File: app/sites/[siteId]/edit/page.tsx
// src/app/sites/[siteId]/edit/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { toast } from 'sonner';

/**
 * A smart entry point for the site editor.
 *
 * This component's logic is now simplified:
 * 1. It waits for the site data to be fully loaded.
 * 2. If the site has pages, it finds the designated homepage (the first page)
 *    and redirects to its specific editor URL.
 * 3. If the site has NO pages, it redirects to the generic content editor URL,
 *    which will then display the "Create Your Homepage" prompt.
 */
export default function SiteEditorRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(state => state.getSiteById(siteId));
  const loadingSites = useAppStore(state => state.loadingSites);

  useEffect(() => {
    // Guard Clause 1: Wait for the siteId to be available.
    if (!siteId) return;

    // Guard Clause 2: Wait for the asynchronous data loading from storage to complete.
    // The `SiteLoaderLayout` triggers this load; we just wait for it to finish.
    if (loadingSites.has(siteId) || !site) {
      return;
    }
    
    let redirectPath: string;

    // Check if the site's structure array has any pages.
    if (site.manifest.structure.length > 0) {
      // The site has pages. The homepage is always the first one.
      const homepageNode = site.manifest.structure[0];
      
      if (homepageNode) {
        // Derive the editor slug from the homepage node's actual path.
        const editorSlug = homepageNode.path.replace(/^content\//, '').replace(/\.md$/, '');
        redirectPath = `/sites/${siteId}/edit/content/${editorSlug}`;
      } else {
        // This is an edge case for a corrupted manifest.
        toast.error("Error: Site has a structure but no valid homepage found.");
        redirectPath = `/sites/${siteId}/settings`;
      }
    } else {
      // The site has NO pages. Redirect to the generic content editor,
      // which will display the "Create Your Homepage" UI.
      redirectPath = `/sites/${siteId}/edit/content`;
    }

    // Use `replace` to avoid polluting browser history with this redirect page.
    router.replace(redirectPath);

  }, [site, siteId, router, loadingSites]);

  // Display a consistent loading message while waiting for the logic to run.
  return (
    <div className="p-6 flex justify-center items-center h-full">
      <p>Loading Editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
// src/app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
'use client';

import { useMemo, useEffect, useRef } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';
import { EditorProvider } from '@/features/editor/contexts/EditorContext';
import type { LocalSiteData } from '@/types';

// Component Imports
import { Button } from '@/core/components/ui/button';
import { FilePlus, LayoutGrid } from 'lucide-react';
import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import LeftSidebar from '@/components/publishing/LeftSidebar';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
import CreateCollectionPageDialog from '@/features/editor/components/CreateCollectionPageDialog';
import BlocknoteEditor, { type BlocknoteEditorRef } from '@/features/editor/components/BlocknoteEditor';
import FrontmatterSidebar from '@/features/editor/components/FrontmatterSidebar';
import PrimaryContentFields from '@/features/editor/components/PrimaryContentFields';
import CollectionItemList from '@/features/editor/components/CollectionItemList';
import SaveButton from '@/features/editor/components/SaveButton';

// Modular Hooks
import { usePageIdentifier } from '@/features/editor/hooks/usePageIdentifier';
import { useFileContent } from '@/features/editor/hooks/useFileContent';
import { useFilePersistence } from '@/features/editor/hooks/useFilePersistence';

function EditContentPageInternal() {
  const editorRef = useRef<BlocknoteEditorRef>(null);

  // --- FIX: Use the new `activeSiteId` to get the correct site data ---
  const activeSiteId = useAppStore(state => state.activeSiteId);
  const site = useAppStore(state => activeSiteId ? state.getSiteById(activeSiteId) : undefined);
  
  const { siteId, isNewFileMode, filePath } = usePageIdentifier({ site });
  
  const { status, frontmatter, initialBlocks, slug, setSlug, handleFrontmatterChange, onContentModified } = useFileContent(siteId, filePath, isNewFileMode);
  const { handleDelete } = useFilePersistence({ siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent: () => editorRef.current?.getBlocks() ?? [] });
  const { leftSidebarContent, rightSidebarContent, setLeftAvailable, setRightAvailable, setLeftSidebarContent, setRightSidebarContent } = useUIStore(state => state.sidebar);

  const isCollectionPage = useMemo(() => !!frontmatter?.collection, [frontmatter]);

  const rightSidebarComponent = useMemo(() => {
    if (status !== 'ready' || !frontmatter || !site) return null;
    return <FrontmatterSidebar siteId={siteId} filePath={filePath} site={site as LocalSiteData} frontmatter={frontmatter} onFrontmatterChange={handleFrontmatterChange} isNewFileMode={isNewFileMode} slug={slug} onSlugChange={setSlug} onDelete={handleDelete} />;
  }, [status, site, frontmatter, siteId, filePath, isNewFileMode, slug, handleFrontmatterChange, setSlug, handleDelete]);

  useEffect(() => {
    setLeftAvailable(true);
    setLeftSidebarContent(<LeftSidebar />);
    return () => { setLeftAvailable(false); setLeftSidebarContent(null); };
  }, [setLeftAvailable, setLeftSidebarContent]);

  useEffect(() => {
    if (rightSidebarComponent) {
      setRightAvailable(true);
      setRightSidebarContent(rightSidebarComponent);
    } else {
      setRightAvailable(false);
      setRightSidebarContent(null);
    }
    return () => { setRightAvailable(false); setRightSidebarContent(null); };
  }, [rightSidebarComponent, setRightAvailable, setRightSidebarContent]);

  const isSiteEmpty = site && site.manifest.structure.length === 0 && !isNewFileMode;

  return (
    <ThreeColumnLayout
        leftSidebar={leftSidebarContent}
        rightSidebar={isSiteEmpty ? null : rightSidebarContent}
        headerActions={isSiteEmpty ? null : <SaveButton />}
    >
      {isSiteEmpty ? (
        <div className="flex flex-col items-center justify-center h-full text-center p-8 bg-background">
          <h2 className="text-2xl font-bold mb-2">Create Your Homepage</h2>
          <p className="text-muted-foreground mb-6 max-w-md">Your site is empty. The first page you create will become your site's permanent homepage.</p>
          <div className="flex gap-4">
            <NewPageDialog siteId={siteId}><Button size="lg"><FilePlus className="mr-2 h-5 w-5" /> Create Content Page</Button></NewPageDialog>
            <CreateCollectionPageDialog siteId={siteId}><Button size="lg" variant="outline"><LayoutGrid className="mr-2 h-5 w-5" /> Create Collection Page</Button></CreateCollectionPageDialog>
          </div>
        </div>
      ) : (
        (() => {
          if (status !== 'ready' || !frontmatter || !filePath) {
            return <div className="p-6 flex justify-center items-center h-full"><p>Loading Editor...</p></div>;
          }
          return (
            <div className='flex h-full w-full flex-col'>
              <div className='container mx-auto flex h-full max-w-[900px] flex-col p-6'>
                <div className="shrink-0"><PrimaryContentFields frontmatter={frontmatter} onFrontmatterChange={handleFrontmatterChange} /></div>
                <div className="mt-6 flex-grow min-h-0">
                  {isCollectionPage ? (
                    <CollectionItemList siteId={siteId} collectionPagePath={filePath} />
                  ) : (
                    <BlocknoteEditor ref={editorRef} key={filePath} initialContent={initialBlocks} onContentChange={onContentModified} />
                  )}
                </div>
              </div>
            </div>
          );
        })()
      )}
    </ThreeColumnLayout>
  );
}

export default function EditContentPage() {
    return (
        <EditorProvider>
            <EditContentPageInternal />
        </EditorProvider>
    );
}

================================================================================

File: app/sites/[siteId]/view/[[...slug]]/page.tsx
// src/app/sites/[siteId]/view/[[...slug]]/page.tsx
'use client';

import SitePreview from '@/features/viewer/components/SiteViewer';

export default function ViewSitePage() {
  // This page's only job is to render the master preview component.
  // The component itself will read the URL from the browser.
  return <SitePreview />;
}

================================================================================

File: app/create-site/page.tsx
// src/app/(publishing)/create-site/page.tsx
'use client';

import { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { LocalSiteData, ParsedMarkdownFile, MarkdownFrontmatter, StructureNode, ThemeInfo } from '@/types';
import { Button } from '@/core/components/ui/button';
import { generateSiteId } from '@/lib/utils';
import { toast } from "sonner";
import { getLayoutManifest } from '@/core/services/configHelpers.service';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { GENERATOR_VERSION, CORE_THEMES, DEFAULT_PAGE_LAYOUT_PATH, DEFAULT_HOMEPAGE_CONFIG } from '@/config/editorConfig';
import { slugify } from '@/lib/utils';

export default function CreateSitePage() {
  const router = useRouter();
  const addSite = useAppStore((state) => state.addSite);

  const [siteTitle, setSiteTitle] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  const availableThemes = useMemo(() => CORE_THEMES, []);
  const [selectedTheme, setSelectedTheme] = useState<ThemeInfo | null>(availableThemes[0] || null);

  const handleSubmit = async () => {
    if (!siteTitle.trim() || !selectedTheme) {
      toast.error('Site title and a theme are required.');
      return;
    }
    setIsLoading(true);

    const newSiteId = generateSiteId(siteTitle);
    const homepageLayoutPath = DEFAULT_PAGE_LAYOUT_PATH;

    // 1. Create a slug from the site's title for the first page.
    // This gives it a meaningful, non-special name.
    const firstPageTitle = DEFAULT_HOMEPAGE_CONFIG.TITLE;
    const firstPageSlug = slugify(firstPageTitle); // e.g., 'welcome-to-your-new-site'

    // 2. Define the frontmatter with the `homepage: true` flag.
    const defaultFrontmatter: MarkdownFrontmatter = {
        title: firstPageTitle,
        layout: DEFAULT_PAGE_LAYOUT_PATH,
        date: new Date().toISOString().split('T')[0],
        homepage: true, // This is the ONLY thing that makes it the homepage.
    };
    
    // 3. Create the ParsedMarkdownFile object using the normal slug and path.
    const defaultIndexFile: ParsedMarkdownFile = {
        slug: firstPageSlug,
        path: `content/${firstPageSlug}.md`, // e.g., content/welcome-to-your-new-site.md
        frontmatter: defaultFrontmatter,
        content: `## ${firstPageTitle}\n\nThis is your new site's homepage. You can start editing it now.`,
    };

    // 4. Create the corresponding StructureNode for the manifest.
    const indexStructureNode: StructureNode = {
        type: 'page',
        title: firstPageTitle,
        path: defaultIndexFile.path, // Path uses the real filename
        slug: firstPageSlug,          // Slug uses the real slug
        navOrder: 0,
    };


    const mockSiteData: LocalSiteData = { 
        siteId: 'mock-id', 
        contentFiles: [], 
        layoutFiles: [], 
        themeFiles: [], 
        manifest: { 
            siteId: 'mock-id',
            title: 'mock',
            description: 'mock',
            generatorVersion: GENERATOR_VERSION,
            structure: [],
            theme: { 
                name: selectedTheme.path, 
                config: {} 
            } 
        } 
    };
    
    const layoutManifest = await getLayoutManifest(mockSiteData, homepageLayoutPath);
    
    if (layoutManifest?.schema?.properties) {
    for (const [key, prop] of Object.entries(layoutManifest.schema.properties)) {
        // Check if the property in the schema has a 'default' value
        if (typeof prop === 'object' && prop !== null && 'default' in prop) {
            // And if we haven't already set this value in our frontmatter
            if (defaultFrontmatter[key] === undefined) {
                // Then apply the default value from the schema.
                defaultFrontmatter[key] = prop.default as unknown;
            }
        }
    }
}

    const newSiteData: LocalSiteData = {
      siteId: newSiteId,
      manifest: {
        siteId: newSiteId,
        generatorVersion: GENERATOR_VERSION,
        title: siteTitle.trim(),
        description: siteDescription.trim(),
        theme: { name: selectedTheme.path, config: {} },
        structure: [],
      },
      contentFiles: [],
      themeFiles: [],
      layoutFiles: [],
    };


    try {
      await addSite(newSiteData);
      toast.success(`Site "${siteTitle}" created successfully!`);
      router.push(`/sites/${newSiteId}/edit`);
    } catch (error) {
      toast.error(`Failed to create site: ${(error as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-2xl">
      <div className="space-y-6">
        <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Create a New Site</h1>
            <Button onClick={() => router.push('/')} variant="outline">Cancel</Button>
        </div>

        <div className="space-y-4 p-6 border rounded-lg">
            <h2 className="text-lg font-semibold">Site Details</h2>
            <div>
                <Label htmlFor="site-title">Site Title</Label>
                <Input
                    id="site-title"
                    value={siteTitle}
                    onChange={(e) => setSiteTitle(e.target.value)}
                    placeholder="My Awesome Project"
                    required
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="site-description">Site Description (Optional)</Label>
                <Textarea
                    id="site-description"
                    value={siteDescription}
                    onChange={(e) => setSiteDescription(e.target.value)}
                    placeholder="A short and catchy description of your new site."
                    rows={3}
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="theme-select">Theme</Label>
                <Select 
                    value={selectedTheme?.path || ''} 
                    onValueChange={(themePath) => {
                        const theme = availableThemes.find(t => t.path === themePath);
                        if (theme) setSelectedTheme(theme);
                    }} 
                >
                    <SelectTrigger id="theme-select" className="mt-1">
                        <SelectValue placeholder="Select a theme..." />
                    </SelectTrigger>
                    <SelectContent>
                        {availableThemes.map(theme => (
                            <SelectItem key={theme.path} value={theme.path}>
                                {theme.name}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                 <p className="text-xs text-muted-foreground mt-1">
                    Choose the overall design for your site. You can change this later.
                </p>
            </div>
        </div>

        <div className="flex justify-end">
            <Button onClick={handleSubmit} disabled={isLoading || !siteTitle.trim() || !selectedTheme} size="lg">
                {isLoading ? 'Creating...' : 'Create Site'}
            </Button>
        </div>
      </div>
    </div>
  );
}

================================================================================

File: config/editorConfig.ts
// src/config/editorConfig.ts
import type { ThemeInfo, LayoutInfo } from '@/types';
import { RJSFSchema, UiSchema } from '@rjsf/utils'; 

/**
 * The official version of the Signum generator client.
 * This is written to the manifest.json on site creation and can be used
 * by the theme engine or other tools to check for compatibility.
 */
export const GENERATOR_VERSION = 'SignumClient/1.3.0';

/**
 * The URL segment used to identify a new, unsaved content file.
 * This allows the editor to distinguish between editing an existing file
 * and creating a new one.
 * e.g., /edit/site-id/content/blog/_new
 */
export const NEW_FILE_SLUG_MARKER = '_new';

/**
 * The delay in milliseconds for the autosave functionality in the content editor.
 * A longer delay reduces server/storage load but increases risk of data loss on close.
 * A shorter delay saves more often but can be more "chatty".
 */
export const AUTOSAVE_DELAY = 2500;

/**
 * The default layout path used for any new single page.
 * The system will fall back to this if a more specific layout isn't defined.
 * The path is relative to '/public/layouts/'.
 * e.g., 'page'
 */
export const DEFAULT_PAGE_LAYOUT_PATH = 'page';

/**
 * The default layout path used for any new collection.
 * This ensures that when a user creates a new collection, it has a sensible
 * default appearance without requiring an immediate decision.
 * The path is relative to '/public/layouts/'.
 * e.g., 'listing'
 */
export const DEFAULT_VIEW_LAYOUT_PATH = 'listing';

export const CORE_LAYOUTS: LayoutInfo[] = [
  // Page Layouts
  { id: 'page', name: 'Standard Page', type: 'page', path: 'page', description: "A clean, single-column page layout." },
  // Add other page layouts like 'post' here if they exist

  // List Layouts
  { id: 'listing', name: 'Vertical List', type: 'list', path: 'listing', description: "A standard, top-to-bottom list of items." },
  // Add other list layouts like 'grid' here if they exist

  // Item Layouts
  { id: 'teaser', name: 'Teaser Card', type: 'item', path: 'teaser', description: "A compact card with a title and summary." },
];

export const CORE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', path: 'default' },
];

/**
 * Default configuration for a new site's homepage (index.md).
 * Centralizes the initial title and content.
 */
export const DEFAULT_HOMEPAGE_CONFIG = {
  TITLE: 'Welcome to your new site!',
  /**
   * Generates the default markdown content for the homepage.
   * @param {string} siteTitle - The title of the site to include in the welcome message.
   * @returns {string} The formatted markdown string.
   */
  getContent: (siteTitle: string): string => 
    `## Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`
};

/**
 * The universal base schema for all content frontmatter.
 * This object is imported directly, eliminating network requests.
 * Fields like 'title' and 'description' are not included here because they
 * are handled by dedicated UI components, not the generic form generator.
 */
export const BASE_SCHEMA: { schema: RJSFSchema; uiSchema: UiSchema } = {
  schema: {
    title: 'Base content fields',
    type: 'object',
    properties: {
      slug: {
        type: 'string',
        title: 'Slug (URL Path)',
        description: 'The URL-friendly version of the title. Auto-generated, but can be edited.',
      },
      image: {
        type: 'string',
        title: 'Image',
        description: 'URL or path to a featured image for this content.',
      },
      date: {
        type: 'string',
        title: 'Publication date',
        format: 'date',
      },
      status: {
        type: 'string',
        title: 'Status',
        enum: ['published', 'draft'],
        default: 'draft',
      },
      author: {
        type: 'string',
        title: 'Author',
      },
      tags: {
        type: 'array',
        title: 'Tags',
        items: {
          type: 'string',
        },
      },
    },
  },
  uiSchema: {
    slug: {
      'ui:widget': 'hidden',
    },
    tags: {
      'ui:options': {
        addable: true,
        removable: true,
      },
    },
  },
};

================================================================================

File: features/viewer/components/SiteViewer.tsx
// src/components/view/SiteViewer.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useEffect, useState, useCallback } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { resolvePageContent } from '@/core/services/pageResolver.service';
import { PageType } from '@/types';import { render as renderWithTheme } from '@/core/services/theme-engine/themeEngine.service';
import { AlertTriangle, Edit } from 'lucide-react';
import { Button } from '@/core/components/ui/button';
import Link from 'next/link';

/**
 * Renders a live, interactive preview of a Signum site within an iframe.
 * This component acts as a mini-SPA, controlling the browser's URL history
 * to allow for deep linking and back/forward button navigation within the preview.
 */
export default function SiteViewer() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;
  const viewRootPath = `/sites/${siteId}/view`;

  const [currentRelativePath, setCurrentRelativePath] = useState(
    pathname.replace(viewRootPath, '') || '/'
  );
  const [htmlContent, setHtmlContent] = useState<string>('<p>Loading Preview...</p>');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const site = useAppStore((state) => state.getSiteById(siteId));

  const sandboxAttributes = 
    process.env.NODE_ENV === 'development'
      ? 'allow-scripts allow-forms allow-same-origin'
      : 'allow-scripts allow-forms';


  const updateIframeContent = useCallback(async () => {
    if (!site) return;

    // This ensures we don't try to render before the site's content is loaded.
    if (!site.contentFiles) {
        console.log("SiteViewer is waiting for content files to load...");
        return;
    }

    const slugArray = currentRelativePath.split('/').filter(Boolean);
    const resolution = resolvePageContent(site, slugArray);
    
    if (resolution.type === PageType.NotFound) {
      setErrorMessage(resolution.errorMessage);
      return;
    }

    try {
      const pureHtml = await renderWithTheme(site, resolution, {
        siteRootPath: viewRootPath,
        isExport: false,
      });

      // --- START: NEW ROBUST COMMUNICATION SCRIPT ---
      const parentOrigin = typeof window !== 'undefined' ? window.location.origin : '';

      const communicationScript = `
        <script>
          // The parent component injects its own origin here. This is the key.
          const PARENT_ORIGIN = '${parentOrigin}'; 

          document.addEventListener('click', function(e) {
            const link = e.target.closest('a');

            // 1. If it's not a link, do nothing.
            if (!link || !link.href) return;
            
            // 2. If it's an in-page anchor link, let the browser handle it.
            if (link.hash && link.pathname === window.location.pathname) return;

            // 3. This is the crucial check: Does the link point to the same origin
            //    as the parent application? This works in ANY sandbox mode.
            if (link.origin === PARENT_ORIGIN) {
              e.preventDefault();
              const newPath = new URL(link.href).pathname;
              // Post the message back to the parent, specifying its own origin for security.
              window.parent.postMessage({ type: 'SIGNUM_NAVIGATE', path: newPath }, PARENT_ORIGIN);
            }
            // 4. If it's an external link (e.g., to google.com), the condition fails
            //    and the browser handles it normally (opening in a new tab if target="_blank").
          });
        <\/script>
      `;
      // --- END: NEW ROBUST COMMUNICATION SCRIPT ---

      const finalHtml = pureHtml.replace('</body>', `${communicationScript}</body>`);
      setHtmlContent(finalHtml);
      setErrorMessage(null);
    } catch (e) {
      const error = e as Error;
      console.error("Error during site rendering:", error);
      setErrorMessage(`Theme Error: ${error.message}`);
    }
  }, [site, viewRootPath, currentRelativePath]);

  // Re-render the iframe whenever the path or the site data itself changes.
  useEffect(() => {
    updateIframeContent();
  }, [updateIframeContent]);

  // This effect manages the browser history and remains unchanged.
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // Security: Only accept messages from our own origin.
      if (event.origin !== window.location.origin) return;
      
      const { type, path } = event.data;
      if (type === 'SIGNUM_NAVIGATE' && path !== window.location.pathname) {
        history.pushState({ path }, '', path);
        setCurrentRelativePath(path.replace(viewRootPath, '') || '/');
      }
    };

    const handlePopState = (event: PopStateEvent) => {
        const newPath = event.state?.path || pathname;
        setCurrentRelativePath(newPath.replace(viewRootPath, '') || '/');
    };

    window.addEventListener('message', handleMessage);
    window.addEventListener('popstate', handlePopState);

    return () => {
      window.removeEventListener('message', handleMessage);
      window.removeEventListener('popstate', handlePopState);
    };
  }, [viewRootPath, pathname]);

  if (errorMessage) {
    return (
      <div className="p-8 text-center">
        <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
        <h1 className="text-2xl font-bold mb-2">Could Not Render Preview</h1>
        <p className="text-muted-foreground">{errorMessage}</p>
        <Button asChild variant="default" className="mt-6">
          <Link href={`/sites/${siteId}/edit`}>
            <Edit className="mr-2 h-4 w-4" /> Go to Editor
          </Link>
        </Button>
      </div>
    );
  }

  return (
    <iframe
      srcDoc={htmlContent}
      title={site?.manifest.title || 'Site Preview'}
      className="w-full h-full border-0"
      sandbox={sandboxAttributes}
    />
  );
}

================================================================================

File: features/viewer/components/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; 

import { marked } from 'marked';
import { useMemo } from 'react';
import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {

    }
    const rawHtml = marked.parse(markdown) as string;
    if (typeof window !== 'undefined') { 
    return DOMPurify.sanitize(rawHtml);
     }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Signum, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: features/site-settings/components/AppearanceSettingsForm.tsx
// src/components/publishing/AppearanceSettingsForm.tsx
'use client';

import { useEffect, useState } from 'react';
import { RJSFSchema } from '@rjsf/utils';
import { getJsonAsset, type ThemeManifest } from '@/core/services/configHelpers.service';
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';
import { ThemeConfig, LocalSiteData } from '@/types';

interface AppearanceSettingsFormProps {
  site: LocalSiteData;
  themePath: string;
  themeConfig: ThemeConfig['config'];
  onConfigChange: (newConfig: ThemeConfig['config']) => void;
}

export default function AppearanceSettingsForm({ site, themePath, themeConfig, onConfigChange }: AppearanceSettingsFormProps) {
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function loadSchema() {
      if (!themePath) {
        setIsLoading(false);
        setSchema(null);
        return;
      }
      
      setIsLoading(true);

      // --- START OF CORRECTED LOGIC ---

      // 1. Fetch the entire theme.json file for the active theme.
      const themeManifest = await getJsonAsset<ThemeManifest>(
        site,
        'theme',
        themePath,
        'theme.json' // <-- Correct filename
      );

      // 2. Check if the manifest was found and if it contains the appearance schema.
      if (themeManifest && themeManifest.appearanceSchema) {
        setSchema(themeManifest.appearanceSchema);
      } else {
        // If not found, there are no settings, so set the schema to null.
        setSchema(null);
      }
      
      // --- END OF CORRECTED LOGIC ---

      setIsLoading(false);
    }

    loadSchema();
  }, [site, themePath]);
  
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onConfigChange(event.formData as ThemeConfig['config'] || {});
  };

  if (isLoading) {
    return (
        <div className="flex items-center justify-center p-4 text-muted-foreground">
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span>Loading appearance options...</span>
        </div>
    );
  }

  if (!schema) {
    return (
      <div className="text-center border-2 border-dashed p-6 rounded-lg">
        <p className="font-semibold">No Appearance Options</p>
        <p className="text-sm text-muted-foreground">The current theme &quot;{themePath}&quot; does not provide any customizable appearance settings.</p>
      </div>
    );
  }

  return (
    <SchemaDrivenForm
      schema={schema}
      formData={themeConfig}
      onFormChange={handleChange}
    />
  );
}

================================================================================

File: features/site-settings/components/SiteSettingsForm.tsx
// src/features/site-settings/components/SiteSettingsForm.tsx
'use client';

import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { ImageRef } from '@/types';
import SiteAssetUploader from './SiteAssetsUploader'; // Import the uploader

// --- FIX: The props now define the complete shape of the form's data ---
interface SiteSettingsFormProps {
  siteId: string;
  formData: {
    title: string;
    description: string;
    author: string;
    baseUrl: string;
    logo: ImageRef | undefined;
    favicon: ImageRef | undefined;
  };
  onFormChange: (newData: SiteSettingsFormProps['formData']) => void;
}

export default function SiteSettingsForm({ siteId, formData, onFormChange }: SiteSettingsFormProps) {
  
  // A generic handler to update any field in the formData object.
  const handleChange = (field: keyof typeof formData, value: any) => {
    onFormChange({ ...formData, [field]: value });
  };

  return (
    <div className="space-y-6">
      {/* --- NEW: Site Identity section is now part of the form --- */}
      <div className="space-y-4">
        <h2 className="text-lg font-semibold">Site Identity</h2>
        <SiteAssetUploader 
          siteId={siteId}
          label="Site Logo"
          value={formData.logo}
          onChange={(newRef) => handleChange('logo', newRef)}
          onRemove={() => handleChange('logo', undefined)}
        />
        <SiteAssetUploader
          siteId={siteId}
          label="Favicon"
          value={formData.favicon}
          onChange={(newRef) => handleChange('favicon', newRef)}
          onRemove={() => handleChange('favicon', undefined)}
        />
      </div>

      {/* --- NEW: Core Details section is now within the form --- */}
      <div className="border-t pt-6 space-y-4">
        <h2 className="text-lg font-semibold">Core Details</h2>
        <div className="space-y-2">
            <Label htmlFor="title">Site Title</Label>
            <Input
                id="title"
                value={formData.title}
                onChange={(e) => handleChange('title', e.target.value)}
                placeholder="My Awesome Site"
            />
            <p className="text-sm text-muted-foreground">The main title for your website.</p>
        </div>
        <div className="space-y-2">
            <Label htmlFor="description">Site Description</Label>
            <Textarea
                id="description"
                value={formData.description}
                onChange={(e) => handleChange('description', e.target.value)}
                placeholder="A short, catchy description."
                rows={3}
            />
            <p className="text-sm text-muted-foreground">Used for search engines and social media previews.</p>
        </div>
        <div className="space-y-2">
            <Label htmlFor="author">Author (Optional)</Label>
            <Input
                id="author"
                value={formData.author}
                onChange={(e) => handleChange('author', e.target.value)}
                placeholder="Your Name or Organization"
            />
            <p className="text-sm text-muted-foreground">The default author for content on this site.</p>
        </div>
        <div className="space-y-2">
            <Label htmlFor="baseUrl">Base URL</Label>
            <Input
                id="baseUrl"
                type="url"
                value={formData.baseUrl}
                onChange={(e) => handleChange('baseUrl', e.target.value)}
                placeholder="https://www.my-awesome-site.com"
            />
            <p className="text-sm text-muted-foreground">
                The full public URL of your site. Required for generating correct RSS feeds and sitemaps.
            </p>
        </div>
      </div>
    </div>
  );
}

================================================================================

File: features/site-settings/components/SiteAssetsUploader.tsx
// src/features/site-settings/components/SiteAssetUploader.tsx
'use client';

import { useEffect, useState } from 'react';
import { ImageRef } from '@/types';
import { useAppStore } from '@/core/state/useAppStore';
import { getActiveImageService } from '@/core/services/images/images.service';
import { Button } from '@/core/components/ui/button';
import { UploadCloud, XCircle } from 'lucide-react';
import { toast } from 'sonner';

interface SiteAssetUploaderProps {
  siteId: string;
  label: string;
  value: ImageRef | undefined; // The current ImageRef from the manifest
  onChange: (newRef: ImageRef) => void;
  onRemove: () => void;
}

export default function SiteAssetUploader({ siteId, label, value, onChange, onRemove }: SiteAssetUploaderProps) {
  const site = useAppStore(state => state.getSiteById(siteId));
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);

  // Effect to generate a preview URL whenever the `value` prop changes
  useEffect(() => {
    let objectUrl: string | null = null;
    const generatePreview = async () => {
      if (value && site?.manifest) {
        try {
          const service = getActiveImageService(site.manifest);
             const url = await service.getDisplayUrl(site.manifest, value, { width: 128, height: 128, crop: 'fit' }, false);
          setPreviewUrl(url);
          objectUrl = url;
        } catch (error) {
          console.error(`Could not generate preview for ${label}:`, error);
          setPreviewUrl(null);
        }
      } else {
        setPreviewUrl(null);
      }
    };
    generatePreview();
    
    // Cleanup function to revoke blob URLs and prevent memory leaks
    return () => {
      if (objectUrl && objectUrl.startsWith('blob:')) {
        URL.revokeObjectURL(objectUrl);
      }
    };
  }, [value, site, label]);

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !site?.manifest) return;
    
    setIsUploading(true);
    try {
      const service = getActiveImageService(site.manifest);
      const newRef = await service.upload(file, siteId);
      onChange(newRef); // Pass the new ImageRef up to the parent form state
      toast.success(`${label} uploaded successfully.`);
    } catch (error) {
      toast.error(`Failed to upload ${label}: ${(error as Error).message}`);
    } finally {
      setIsUploading(false);
    }
    // Reset the input so the same file can be selected again
    event.target.value = '';
  };

  const inputId = `uploader-${label.toLowerCase().replace(' ', '-')}`;

  return (
    <div className="flex items-center gap-4">
      <div className="w-16 h-16 bg-muted rounded-md flex items-center justify-center overflow-hidden flex-shrink-0">
        {previewUrl ? (
          <img src={previewUrl} alt={`${label} preview`} className="max-w-full max-h-full object-contain" />
        ) : (
          <UploadCloud className="w-8 h-8 text-muted-foreground" />
        )}
      </div>
      <div className="flex-grow">
        <label htmlFor={inputId} className="font-medium text-sm">{label}</label>
        <div className="flex items-center gap-2 mt-1">
          <Button asChild size="sm" variant="outline" disabled={isUploading}>
            <label htmlFor={inputId}>
              {isUploading ? 'Uploading...' : (value ? 'Change...' : 'Upload...')}
            </label>
          </Button>
          <input type="file" id={inputId} className="hidden" onChange={handleFileSelect} accept="image/png, image/jpeg, image/svg+xml, image/x-icon" />

          {value && (
            <Button size="sm" variant="ghost" className="text-destructive" onClick={onRemove}>
              <XCircle className="w-4 h-4 mr-1" />
              Remove
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

================================================================================

File: features/site-settings/components/SettingsNav.tsx
'use-client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbUserCircle, TbPalette, TbPhoto } from 'react-icons/tb';
import { cn } from '@/lib/utils';

// This is the navigation component for the settings area.
export default function SettingsNav() {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const navItems = [
    { href: `/sites/${siteId}/settings`, title: 'Site Details', icon: TbUserCircle },
    { href: `/sites/${siteId}/settings/appearance`, title: 'Appearance', icon: TbPalette },
    { href: `/sites/${siteId}/settings/images`, title: 'Images', icon: TbPhoto },
    // Add more settings links here as needed
  ];

  return (
    <div className="flex h-full flex-col p-4">
      <h2 className="px-2 text-lg font-semibold tracking-tight">Settings</h2>
      <nav className="mt-4 flex flex-col gap-1">
        {navItems.map((item) => (
          <Link
            key={item.href}
            href={item.href}
            className={cn(
              'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
              pathname === item.href
                ? 'bg-primary text-primary-foreground'
                : 'text-muted-foreground hover:bg-muted/50 hover:text-foreground'
            )}
          >
            <item.icon className="h-5 w-5" />
            {item.title}
          </Link>
        ))}
      </nav>
    </div>
  );
}

================================================================================

File: features/editor/contexts/EditorContext.tsx
// src/contexts/EditorContext.tsx
'use client';
import { toast } from 'sonner';

import { createContext, useContext, useState, ReactNode, useMemo, useRef, useCallback } from 'react';

export type SaveState = 'idle' | 'saving' | 'saved' | 'no_changes';

interface EditorContextType {
  saveState: SaveState;
  setSaveState: (state: SaveState) => void;
  hasUnsavedChanges: boolean;
  setHasUnsavedChanges: (hasChanges: boolean) => void;
  triggerSave: () => Promise<void>;
  registerSaveAction: (saveFn: () => Promise<void>) => void;
}

export const EditorContext = createContext<EditorContextType | undefined>(undefined);

interface EditorProviderProps {
  children: ReactNode;
}

export function EditorProvider({ children }: EditorProviderProps) {
  const [saveState, setSaveState] = useState<SaveState>('no_changes');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const saveActionRef = useRef<(() => Promise<void>) | null>(null);

  const registerSaveAction = useCallback((saveFn: () => Promise<void>) => {
    saveActionRef.current = saveFn;
  }, []);

  const triggerSave = useCallback(async () => {
    if (saveActionRef.current) {
      setSaveState('saving');
      try {
        await saveActionRef.current();
        setSaveState('saved');
        setHasUnsavedChanges(false);
        setTimeout(() => setSaveState('no_changes'), 2000);
      } catch (error) {
        console.error("Save failed:", error);
        toast.error((error as Error).message || "Failed to save.");
        setSaveState('idle');
      }
    }
  }, []);

  const contextValue = useMemo(() => ({
    saveState,
    setSaveState,
    hasUnsavedChanges, 
    setHasUnsavedChanges, 
    triggerSave,
    registerSaveAction,
    // FIX: Add missing dependencies for correctness
  }), [saveState, hasUnsavedChanges, registerSaveAction, triggerSave, setSaveState, setHasUnsavedChanges]);

  return (
    <EditorContext.Provider value={contextValue}>
      {children}
    </EditorContext.Provider>
  );
}

export function useEditor() {
  const context = useContext(EditorContext);
  if (context === undefined) {
    throw new Error('useEditor must be used within an EditorProvider');
  }
  return context;
}

================================================================================

File: features/editor/components/ViewEditor.tsx
// src/features/editor/components/ViewEditor.tsx
'use client';

import { useEffect, useState, useCallback } from 'react';
import { MarkdownFrontmatter, CollectionConfig } from '@/types';
import { getAvailableLayouts, LayoutManifest } from '@/core/services/configHelpers.service';
import { useAppStore } from '@/core/state/useAppStore';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";

interface ViewEditorProps {
  siteId: string;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;
}

export default function ViewEditor({ siteId, frontmatter, onFrontmatterChange }: ViewEditorProps) {
  const site = useAppStore(state => state.getSiteById(siteId));

  // State for the dropdown options
  const [itemLayouts, setItemLayouts] = useState<LayoutManifest[]>([]);
  const [pageLayouts, setPageLayouts] = useState<LayoutManifest[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Fetch available layouts when the component mounts
  useEffect(() => {
    async function fetchData() {
      if (!site) return;
      setIsLoading(true);
      const allLayouts = await getAvailableLayouts(site);
      // Filter layouts by their new, specific types
      setItemLayouts(allLayouts.filter(l => l.layoutType === 'item'));
      setPageLayouts(allLayouts.filter(l => l.layoutType === 'page'));
      setIsLoading(false);
    }
    fetchData();
  }, [site]);

  // A generic handler to update a specific property within the 'collection' object
  const handleCollectionConfigChange = useCallback((key: keyof CollectionConfig, value: string | number) => {
    // We update the entire 'collection' object in the parent's frontmatter state
    const updatedCollectionConfig = { ...(frontmatter.collection!), [key]: value };
    onFrontmatterChange({
      collection: updatedCollectionConfig
    });
  }, [frontmatter.collection, onFrontmatterChange]);

  const collectionConfig = frontmatter.collection;

  if (isLoading) return <div className="p-6">Loading collection settings...</div>;

  // This component should not render if the page isn't a collection page.
  if (!collectionConfig) {
      return (
           <div className="p-6 text-center text-destructive-foreground bg-destructive/20 border border-destructive rounded-lg">
              <h3 className="font-semibold">Not a Collection Page</h3>
              <p className="text-sm">To enable collection settings, add a `collection` block to this page&apos;s frontmatter.</p>
          </div>
      );
  }

  return (
    <div className="p-4 border rounded-lg bg-background space-y-6">
      <h3 className="text-lg font-semibold">Collection Settings</h3>
      <p className="text-sm text-muted-foreground -mt-4">
        Configure how the list of child pages is displayed on this page.
      </p>

      {/* --- Layout Selection --- */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
       
        <div className="space-y-2">
            <Label htmlFor="item-layout">Item Layout (in list)</Label>
            <Select value={collectionConfig.item_layout} onValueChange={(v) => handleCollectionConfigChange('item_layout', v)}>
                <SelectTrigger id="item-layout"><SelectValue placeholder="Select..." /></SelectTrigger>
                <SelectContent>{itemLayouts.map(l => <SelectItem key={l.id} value={l.id}>{l.name}</SelectItem>)}</SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">Appearance of each item teaser.</p>
        </div>
      </div>
      <div className="space-y-2">
        <Label htmlFor="item-page-layout">Full Page Layout (for items)</Label>
        <Select value={collectionConfig.item_page_layout} onValueChange={(v) => handleCollectionConfigChange('item_page_layout', v)}>
            <SelectTrigger id="item-page-layout"><SelectValue placeholder="Select..." /></SelectTrigger>
            <SelectContent>{pageLayouts.map(l => <SelectItem key={l.id} value={l.id}>{l.name}</SelectItem>)}</SelectContent>
        </Select>
         <p className="text-xs text-muted-foreground">The default layout when a user clicks to view a single item from this collection.</p>
      </div>

      {/* --- Sorting & Pagination --- */}
       <Accordion type='single' collapsible className="w-full" defaultValue='item-1'>
          <AccordionItem value="item-1">
              <AccordionTrigger>Sorting & Pagination</AccordionTrigger>
              <AccordionContent className="pt-4 grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-6">
                  <div className="space-y-2">
                      <Label htmlFor="sort-by">Sort Items By</Label>
                      <Select value={collectionConfig.sort_by} onValueChange={(v) => handleCollectionConfigChange('sort_by', v)}>
                        <SelectTrigger id="sort-by"><SelectValue placeholder="Select..." /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="date">Date</SelectItem>
                            <SelectItem value="title">Title</SelectItem>
                        </SelectContent>
                      </Select>
                  </div>
                  <div className="space-y-2">
                      <Label htmlFor="sort-order">Sort Order</Label>
                       <Select value={collectionConfig.sort_order} onValueChange={(v) => handleCollectionConfigChange('sort_order', v)}>
                        <SelectTrigger id="sort-order"><SelectValue placeholder="Select..." /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="desc">Descending</SelectItem>
                            <SelectItem value="asc">Ascending</SelectItem>
                        </SelectContent>
                      </Select>
                  </div>
                   <div className="flex items-center space-x-2 pt-2">
                        <Label htmlFor="items-per-page">Items Per Page</Label>
                        <Input
                            id="items-per-page"
                            type="number"
                            value={collectionConfig.items_per_page || 10}
                            onChange={(e) => handleCollectionConfigChange('items_per_page', parseInt(e.target.value, 10) || 10)}
                            className="w-20"
                        />
                    </div>
              </AccordionContent>
          </AccordionItem>
        </Accordion>
    </div>
  );
}

================================================================================

File: features/editor/components/EditorHeader.tsx
// src/features/editor/components/EditorHeader.tsx
'use client';

import { ReactNode, useState } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { toast } from 'sonner';
import { exportSiteToZip } from '@/core/services/siteExporter.service';
import { slugify } from '@/lib/utils';
import { Eye, PanelLeft, UploadCloud, PanelRight } from 'lucide-react';

/**
 * Props for the generic EditorHeader component.
 */
interface EditorHeaderProps {
  /**
   * An optional React node containing action buttons or other components
   * to be displayed in the header. This allows for context-specific actions.
   */
  actions?: ReactNode;
}

export default function EditorHeader({ actions }: EditorHeaderProps) {
  const params = useParams();
  const siteId = params.siteId as string;
  const [isPublishing, setIsPublishing] = useState(false);

  // Get site and UI state from the global stores
  const site = useAppStore((state) => state.getSiteById(siteId));
  const { toggleLeftSidebar, toggleRightSidebar, isLeftAvailable, isRightAvailable } = useUIStore((state) => state.sidebar);

  const handlePublishSite = async () => {
    if (!site) {
      toast.error("Site data not found. Cannot publish.");
      return;
    }
    setIsPublishing(true);
    toast.info("Generating site bundle for download...");
    try {
      const blob = await exportSiteToZip(site);
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${slugify(site.manifest.title || 'signum-site')}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      toast.success("Site bundle downloaded!");
    } catch (error) {
      console.error("Error publishing site to Zip:", error);
      toast.error(`Failed to generate Zip: ${(error as Error).message}`);
    } finally {
      setIsPublishing(false);
    }
  };
  
  // Render a placeholder header if site data isn't loaded yet
  if (!site) {
    return (
        <header className="sticky top-0 z-20 flex h-[60px] items-center gap-4 border-b bg-background px-4 lg:h-[60px]"></header>
    );
  }

  return (
    <header className="sticky top-0 z-20 flex shrink-0 items-center gap-4 border-b bg-background lg:pl-4 pr-4 h-[60px]">
      <div className="flex items-center gap-2">
        <Link
            href="/sites"
            title="Dashboard"
            className='flex lg:hidden flex-col w-[60px] h-[60px] items-center border-r mr-2'
          >
            <Image src="/signum.svg" width={34} height={34} alt="Signum Logo" className='m-auto'/>
        </Link>
        {isLeftAvailable && (
            <Button 
                variant="outline" 
                size="icon" 
                className="shrink-0" 
                onClick={toggleLeftSidebar}
                aria-label="Toggle file tree"
            >
                <PanelLeft className="h-5 w-5" />
            </Button>
        )}
      </div>

      <div className="flex-1 text-lg text-muted-foreground truncate">
       <span className="font-bold text-foreground">{site.manifest.title}</span>
      </div>
      
      <div className="flex items-center justify-end gap-2">
        {/* Render the custom actions passed via props. This is where the SaveButton will appear on the editor page. */}
        {actions}

        <Button variant="outline" asChild>
            <Link href={`/sites/${siteId}/view`} target="_blank">
                <Eye className="h-4 w-4" />
                <span className='hidden md:block '>View</span>
            </Link>
        </Button>
        <Button variant="default" onClick={handlePublishSite} disabled={isPublishing}>
            <UploadCloud className="h-4 w-4" /> 
            <span className='hidden md:block '>{isPublishing ? 'Publishing...' : 'Publish'}</span>
        </Button>

        {isRightAvailable && (
            <Button 
                variant="outline" 
                size="icon" 
                className="shrink-0" 
                onClick={toggleRightSidebar}
                aria-label="Toggle settings sidebar"
            >
                <PanelRight className="h-5 w-5" />
            </Button>
        )}
      </div>
    </header>
  );
}

================================================================================

File: features/editor/components/ImageUploadWidget.tsx
'use client';

import { useState } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { getActiveImageService } from '@/core/services/images/images.service';
import { ImageRef } from '@/types';
import { Button } from '@/core/components/ui/button';

interface ImageUploadWidgetProps {
  siteId: string;
  value: string; // The current src value from frontmatter
  onImageSelect: (imageRef: ImageRef) => void;
}

export default function ImageUploadWidget({ siteId, value, onImageSelect }: ImageUploadWidgetProps) {
  const site = useAppStore(state => state.getSiteById(siteId));
  const [isLoading, setIsLoading] = useState(false);

  const handleUploadClick = async (event: React.ChangeEvent<HTMLInputElement>) => {
    if (!event.target.files || !site) return;
    const file = event.target.files[0];
    
    setIsLoading(true);
    try {
      const imageService = getActiveImageService(site.manifest);
      const imageRef = await imageService.upload(file, siteId);
      onImageSelect(imageRef); // Pass the full reference back to the parent form
    } catch (error) {
      console.error("Image upload failed:", error);
      // Show a toast message to the user
    } finally {
      setIsLoading(false);
    }
  };

  const imageService = site ? getActiveImageService(site.manifest) : null;
  // This logic would need to be expanded for the Cloudinary widget,
  // which brings its own button/UI.
  
  return (
    <div>
      {value && <img src={value} alt="Current image" className="w-full h-auto rounded-md mb-2" />}
      <input
        type="file"
        id="image-upload"
        className="hidden"
        onChange={handleUploadClick}
        accept="image/*"
      />
      <Button asChild>
        <label htmlFor="image-upload">{value ? 'Change Image' : 'Upload Image'}</label>
      </Button>
      {isLoading && <p>Uploading...</p>}
    </div>
  );
}

================================================================================

File: features/editor/components/PrimaryContentFields.tsx
// src/components/publishing/PrimaryContentFields.tsx
'use client';

import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { Label } from '@/core/components/ui/label';
import { MarkdownFrontmatter } from '@/types';

// FIXED: The interface is now much stricter and safer.
// It only defines the properties this component actually cares about.
interface PrimaryFieldsProps {
  frontmatter: {
    title?: string;
    description?: string;
  };
  // The callback expects a partial update to the main frontmatter state.
  onFrontmatterChange: (newData: Partial<MarkdownFrontmatter>) => void;
  showDescription?: boolean;
}

export default function PrimaryContentFields({
  frontmatter,
  onFrontmatterChange,
}: PrimaryFieldsProps) {

  // FIXED: The handler now only passes back the single field that changed.
  // This makes the component more reusable and decoupled from the parent's state shape.
  const handleChange = (field: 'title' | 'description', value: string) => {
    onFrontmatterChange({
      [field]: value,
    });
  };

  return (
    <div className="space-y-4 shrink-0">
      <div className="space-y-2 mb-6 border-b pb-3">
        <Label htmlFor="content-title" className="text-[10px] font-medium uppercase text-gray-400">
          Title
        </Label>
        <Input
          id="content-title"
          placeholder="Enter a title..."
          value={frontmatter.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          // These classes create the large, "invisible" input style
          className="text-2xl lg:text-3xl font-bold h-auto p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent"
        />
      </div>

        <div className="space-y-2 mb-6 border-b pb-3">
          <Label htmlFor="content-description" className="text-[10px] font-medium uppercase text-gray-400">
            Description
          </Label>
          <Textarea
            
            placeholder="Add a short description..."
            value={frontmatter.description || ''}
            onChange={(e) => handleChange('description', e.target.value)}
            // Style for a clean, borderless textarea
            className="p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent resize-none text-2xl text-black"
            rows={1}
          />
        </div>
    </div>
  );
}

================================================================================

File: features/editor/components/NewPageDialog.tsx
// src/features/editor/components/NewPageDialog.tsx
'use client';

import { useState, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// --- UI & Type Imports ---
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface NewPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function NewPageDialog({ siteId, children, onComplete }: NewPageDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [title, setTitle] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setTitle('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleCreatePage = async () => {
    if (!title.trim()) {
      toast.error("Page title cannot be empty.");
      return;
    }
    setIsSubmitting(true);
    const slug = slugify(title);
    const filePath = `content/${slug}.md`;

    const slugExists = site?.contentFiles?.some(f => f.slug === slug);
    if (slugExists) {
        toast.error(`A page with the slug "${slug}" already exists.`);
        setIsSubmitting(false);
        return;
    }
    
    const frontmatter: MarkdownFrontmatter = {
        title: title.trim(),
        layout: DEFAULT_PAGE_LAYOUT_PATH,
        date: new Date().toISOString().split('T')[0],
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\nStart writing your content here.\n`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);      if (success) {
        toast.success(`Page "${title}" created!`);
        handleOpenChange(false);
        onComplete?.();
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else { throw new Error("Failed to update manifest or save file."); }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New Content Page</DialogTitle>
          <DialogDescription>
            Give your new page a title. You can add content and change settings later.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="space-y-1">
            <Label htmlFor="title">Page Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., About Us" />
          </div>
        </div>
        <DialogFooter>
          <DialogClose asChild><Button variant="outline">Cancel</Button></DialogClose>
          <Button type="button" onClick={handleCreatePage} disabled={!title.trim() || isSubmitting}>
            {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Page</>}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/FileTree.tsx
// src/features/editor/components/FileTree.tsx
'use client';

import React, { useState, useMemo } from 'react';
import Link from 'next/link';
import { type ParsedMarkdownFile, type StructureNode } from '@/types';
import { GripVertical, ChevronRight, File as FileIcon, LayoutGrid, Home } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useSortable, SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { useDroppable } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { getDescendantIds } from '@/core/services/fileTree.service'; // <-- FIX: ADD THIS IMPORT

// --- Type Definitions ---
type DndIndicator = {
    path: string;
    intent: 'reorder-before' | 'reorder-after' | 'nest';
} | null;

interface FileTreeProps {
  nodes: StructureNode[];
  contentFiles: ParsedMarkdownFile[];
  baseEditPath: string;
  activePath: string | undefined;
  homepagePath: string | undefined;
  dndIndicator: DndIndicator;
  nestingLevel?: number;
}

interface FileTreeNodeProps extends Omit<FileTreeProps, 'nodes'> {
  node: StructureNode;
}

// --- Single Tree Node Component ---
const FileTreeNode: React.FC<FileTreeNodeProps> = ({ node, contentFiles, baseEditPath, activePath, homepagePath, dndIndicator, nestingLevel = 0 }) => {
  const [isOpen, setIsOpen] = useState(true);
  
  const isHomepage = node.path === homepagePath;
  const fileForNode = useMemo(() => contentFiles.find(f => f.path === node.path), [contentFiles, node.path]);
  const isCollection = !!fileForNode?.frontmatter.collection;
  const hasChildren = node.children && node.children.length > 0;

  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({
    id: node.path,
    disabled: isHomepage,
  });

  const { setNodeRef: setDroppableRef } = useDroppable({
    id: node.path,
    data: { type: 'container', isCollection },
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    marginLeft: `${nestingLevel * 1.25}rem`,
    opacity: isDragging ? 0.5 : 1,
  };

  const editorSlug = node.path.replace(/^content\//, '').replace(/\.md$/, '');
  const href = `${baseEditPath}/content/${editorSlug}`;

  const isDropTarget = dndIndicator?.path === node.path;
  const showDropLineBefore = isDropTarget && dndIndicator.intent === 'reorder-before';
  const showDropLineAfter = isDropTarget && dndIndicator.intent === 'reorder-after';
  const showNestingHighlight = isDropTarget && dndIndicator.intent === 'nest';

  return (
    <div ref={setNodeRef} style={style} className="relative">
      {showDropLineBefore && <div className="absolute -top-0.5 left-0 right-0 h-1 bg-blue-500 rounded-full z-20" />}
      
      <div
        ref={setDroppableRef}
        className={cn(
          "flex items-center group w-full my-0.5 rounded-md relative transition-colors",
          showNestingHighlight && "bg-blue-100 dark:bg-blue-900/40",
          activePath === node.path && !showNestingHighlight && "bg-accent text-accent-foreground"
        )}
      >
        <button {...listeners} {...attributes} disabled={isHomepage} className={cn("p-1 touch-none", isHomepage ? "cursor-default text-muted-foreground/30" : "cursor-grab text-muted-foreground/50 hover:text-muted-foreground")}>
          <GripVertical className="h-4 w-4" />
        </button>
        
        <div className="flex-grow flex items-center py-1 pl-1 pr-1">
          {hasChildren ? (<ChevronRight className={cn("h-4 w-4 mr-1 shrink-0 transition-transform duration-200 cursor-pointer", isOpen && "rotate-90")} onClick={() => setIsOpen(!isOpen)} />) : (<span className="w-4 h-4 mr-1 shrink-0" />)}

          {isHomepage ? <Home className="h-4 w-4 shrink-0 text-primary" /> : isCollection ? <LayoutGrid className="h-4 w-4 shrink-0 text-muted-foreground" /> : <FileIcon className="h-4 w-4 shrink-0 text-muted-foreground" />}
          
          <Link href={href} className="truncate flex-grow mx-1.5 text-sm hover:underline" title={node.title}>{node.menuTitle || node.title}</Link>
        </div>
      </div>
      
      {showDropLineAfter && <div className="absolute -bottom-0.5 left-0 right-0 h-1 bg-blue-500 rounded-full z-20" />}
      
      {hasChildren && isOpen && (
        <FileTree
          nodes={node.children!}
          {...{ contentFiles, baseEditPath, activePath, homepagePath, dndIndicator }}
          nestingLevel={nestingLevel + 1}
        />
      )}
    </div>
  );
};

// --- Main File Tree Container ---
export default function FileTree({ nodes, contentFiles, baseEditPath, activePath, homepagePath, dndIndicator }: FileTreeProps) {
  const nodeIds = useMemo(() => getDescendantIds(nodes), [nodes]);

  if (!nodes || nodes.length === 0) return null;

  return (
    <SortableContext items={nodeIds} strategy={verticalListSortingStrategy}>
      <div className="space-y-0.5">
        {nodes.map(node => (
          <FileTreeNode key={node.path} node={node} {...{ contentFiles, baseEditPath, activePath, homepagePath, dndIndicator }}/>
        ))}
      </div>
    </SortableContext>
  );
}

================================================================================

File: features/editor/components/DataSourceSelectWidget.tsx
// src/features/editor/components/DataSourceSelectWidget.tsx
'use client';

import { useEffect, useState, useMemo } from 'react';
import { getAvailableLayouts } from '@/core/services/configHelpers.service';
import { WidgetProps } from '@rjsf/utils';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Label } from '@/core/components/ui/label';
import type { LocalSiteData, StructureNode } from '@/types';
import type { LayoutManifest } from '@/core/services/configHelpers.service';

interface SelectOption {
  label: string;
  value: string;
}

interface DataSourceSelectWidgetProps extends WidgetProps {
    formContext?: {
        site?: LocalSiteData;
    };
}

const DataSourceSelectWidget = ({ id, label, options, value, onChange, required, formContext }: DataSourceSelectWidgetProps) => {
  const { uiSchema } = options;
  const site = formContext?.site;

  const dataSource = uiSchema?.['ui:dataSource'] as string;
  const layoutTypeFilter = uiSchema?.['ui:layoutType'] as string | undefined;

  const [items, setItems] = useState<SelectOption[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchItems = async () => {
      // Add a more robust guard clause
      if (!site || !site.manifest || !site.contentFiles) {
        setItems([]);
        setIsLoading(false);
        return;
      }
      setIsLoading(true);

      let fetchedItems: SelectOption[] = [];

      try {
        switch (dataSource) {
          case 'collections':
            // 1. Find all content files that ARE collection pages.
            const collectionFilePaths = new Set(
              site.contentFiles
                .filter(f => !!f.frontmatter.collection)
                .map(f => f.path)
            );
            // 2. Filter the structure nodes to only include those whose paths are in our set.
            fetchedItems = site.manifest.structure
              .filter((n: StructureNode) => collectionFilePaths.has(n.path))
              .map((c: StructureNode) => ({ label: c.title, value: c.slug }));
            break;

          case 'layouts':
            const allLayouts: LayoutManifest[] = await getAvailableLayouts(site);
            fetchedItems = allLayouts
              .filter(l => !layoutTypeFilter || l.layoutType === layoutTypeFilter)
              .map(l => ({ label: l.name, value: l.id })); // Use id for value
            break;

          default:
            fetchedItems = [];
        }
        setItems(fetchedItems);
      } catch (error) {
        console.error(`Failed to fetch data source "${dataSource}":`, error);
        setItems([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchItems();
  }, [site, dataSource, layoutTypeFilter]);

  const placeholder = useMemo(() => {
    if (isLoading) return `Loading ${dataSource || 'options'}...`;
    if (dataSource) return `Select a ${dataSource.replace(/s$/, '')}...`;
    return 'Select an option...';
  }, [isLoading, dataSource]);

  return (
    <div className="space-y-1">
      <Label htmlFor={id}>{label}{required ? '*' : ''}</Label>
      <Select value={value} onValueChange={onChange} disabled={isLoading}>
        <SelectTrigger id={id} className="mt-1">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {items.map(item => (
            <SelectItem key={item.value} value={item.value}>
              {item.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DataSourceSelectWidget;

================================================================================

File: features/editor/components/HomepageSwitch.tsx
// src/features/editor/components/HomepageSwitch.tsx
'use client';

import { useAppStore } from '@/core/state/useAppStore';
import { Label } from '@/core/components/ui/label';
import { Switch } from '@/core/components/ui/switch';
import { toast } from 'sonner';
import { useState } from 'react';

interface HomepageSwitchProps {
  siteId: string;
  pagePath: string;
  isHomepage: boolean;
}

export default function HomepageSwitch({ siteId, pagePath, isHomepage }: HomepageSwitchProps) {
  const { setHomepageAction } = useAppStore.getState();
  const [isLoading, setIsLoading] = useState(false);

  const handleCheckedChange = async (isChecked: boolean) => {
    if (!isChecked) {
      // It's not possible for the user to "uncheck" this switch.
      // Another page must be selected to become the homepage.
      toast.info("To change the homepage, set it on another page.");
      return;
    }
    
    setIsLoading(true);
    try {
      await setHomepageAction(siteId, pagePath);
    } catch (error) {
      console.error("Failed to set homepage:", error);
      toast.error("An error occurred while setting the homepage.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-between rounded-lg border p-3 shadow-sm">
      <div className="space-y-0.5">
        <Label htmlFor="homepage-switch" className="text-base">
          Set as Homepage
        </Label>
        <p className="text-sm text-muted-foreground">
          Make this the first page visitors see.
        </p>
      </div>
      <Switch
        id="homepage-switch"
        checked={isHomepage}
        onCheckedChange={handleCheckedChange}
        disabled={isLoading || isHomepage}
        aria-readonly
      />
    </div>
  );
}

================================================================================

File: features/editor/components/BlocknoteEditor.tsx
// src/features/editor/components/BlocknoteEditor.tsx
'use client';

import { forwardRef, useImperativeHandle } from 'react';
import { Block } from '@blocknote/core';
import { useCreateBlockNote } from '@blocknote/react';
import { BlockNoteView } from '@blocknote/mantine';
import '@blocknote/mantine/style.css';
import { Label } from '@/core/components/ui/label';

interface BlocknoteEditorProps {
  initialContent: Block[];
  onContentChange: () => void; // Only needs to signal a change, not pass content
}

// The ref will now expose a function to get the editor's block data.
export interface BlocknoteEditorRef {
  getBlocks: () => Block[];
}

const BlocknoteEditor = forwardRef<BlocknoteEditorRef, BlocknoteEditorProps>(
  ({ initialContent, onContentChange }, ref) => {
    // Creates a new editor instance.
    const editor = useCreateBlockNote({
        initialContent: initialContent.length > 0 ? initialContent : undefined,
    });

    // Expose a function for the parent component to get the current content.
    useImperativeHandle(ref, () => ({
      getBlocks: () => {
        return editor.document;
      },
    }));

    return (
      <div className="space-y-2 h-full flex flex-col">
        <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400 shrink-0">
          Content
        </Label>
        <div className="flex-grow min-h-0 overflow-y-auto rounded-md border p-2">
            <BlockNoteView
                editor={editor}
                theme="light" // Or use a theme provider to make it dynamic
                onChange={onContentChange}
            />
        </div>
      </div>
    );
  }
);

BlocknoteEditor.displayName = 'BlocknoteEditor';
export default BlocknoteEditor;

================================================================================

File: features/editor/components/CollectionItemList.tsx
// src/features/editor/components/CollectionItemList.tsx
'use client';

import Link from 'next/link';
import { useMemo } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { findChildNodes } from '@/core/services/fileTree.service';
import { Button } from '@/core/components/ui/button';
import { FileText, PlusCircle } from 'lucide-react';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';

interface CollectionItemListProps {
  siteId: string;
  collectionPagePath: string; // e.g., 'content/blog.md'
}

export default function CollectionItemList({ siteId, collectionPagePath }: CollectionItemListProps) {
  const site = useAppStore(state => state.getSiteById(siteId));

  const collectionItems = useMemo(() => {
    if (!site?.manifest) return [];
    return findChildNodes(site.manifest.structure, collectionPagePath);
  }, [site?.manifest, collectionPagePath]);

  const newItemPath = `/sites/${siteId}/edit/content/${collectionPagePath.replace('content/', '').replace('.md', '')}/${NEW_FILE_SLUG_MARKER}`;

  return (
    <div className="h-full flex flex-col p-6">
      <div className="flex shrink-0 items-center justify-between mb-4 pb-4 border-b">
        <h1 className="text-2xl font-bold">Collection Items</h1>
        <Button asChild>
          <Link href={newItemPath}>
            <PlusCircle className="mr-2 h-4 w-4" /> New Item
          </Link>
        </Button>
      </div>
      <div className="flex-grow rounded-lg bg-background p-1 overflow-y-auto">
        {collectionItems.length > 0 ? (
          <ul className="space-y-1">
            {collectionItems.map((item) => {
              // --- THIS IS THE FIX ---
              // Generate the link from the reliable `item.path` instead of `item.slug`.
              const editorSlug = item.path.replace(/^content\//, '').replace(/\.md$/, '');
              const itemEditorPath = `/sites/${siteId}/edit/content/${editorSlug}`;
              // --- END OF FIX ---

              return (
                <li key={item.path}>
                  <Link href={itemEditorPath} className="flex items-center rounded-md p-2 transition-colors hover:bg-muted">
                    <FileText className="mr-3 h-4 w-4 text-muted-foreground" />
                    <span className="font-medium">{item.title || item.slug}</span>
                  </Link>
                </li>
              );
            })}
          </ul>
        ) : (
          <div className="text-center text-muted-foreground py-10">
            <p>No items have been added to this collection yet.</p>
            <Button asChild variant="outline" className="mt-4">
               <Link href={newItemPath}>
                    <PlusCircle className="mr-2 h-4 w-4" /> Add your first item
                </Link>
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}

================================================================================

File: features/editor/components/CreateCollectionPageDialog.tsx
// src/features/editor/components/CreateCollectionPageDialog.tsx
'use client';

import { useState, useEffect, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// UI & Type Imports
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter } from '@/types';
//import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface CreateCollectionPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

// Default layouts for a new collection page
const DEFAULT_LIST_LAYOUT = 'listing';
const DEFAULT_ITEM_LAYOUT = 'teaser';
const DEFAULT_ITEM_PAGE_LAYOUT = 'page';

export default function CreateCollectionPageDialog({ siteId, children, onComplete }: CreateCollectionPageDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  useEffect(() => {
    setSlug(slugify(name));
  }, [name]);

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setName('');
        setSlug('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }

    const filePath = `content/${slug}.md`;
    if (site?.contentFiles?.some(f => f.path === filePath)) {
        toast.error(`A page with the folder name "${slug}" already exists.`);
        return;
    }

    setIsSubmitting(true);

    const frontmatter: MarkdownFrontmatter = {
        title: name.trim(),
        layout: DEFAULT_LIST_LAYOUT, // The layout for this page itself
        collection: { // The special block that makes this a Collection Page
            item_layout: DEFAULT_ITEM_LAYOUT,
            item_page_layout: DEFAULT_ITEM_PAGE_LAYOUT,
            sort_by: 'date',
            sort_order: 'desc',
            items_per_page: 10,
        }
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\n# Welcome to the ${name.trim()} collection!\n\nYou can write an introduction for this collection here.`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);
      if (success) {
        toast.success(`Collection page "${name}" created!`);
        handleOpenChange(false);
        onComplete?.();
        // Redirect to the editor for the new collection page itself
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else {
        throw new Error("Failed to update manifest or save file.");
      }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
    } finally {
        setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection Page</DialogTitle>
            <DialogDescription>
              Create a new page that will list other pages, like a blog or a portfolio.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name.trim() || isSubmitting}>
                {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Collection</>}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/RightSidebar.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';

interface RightSidebarProps {
  children: ReactNode;
}

export default function RightSidebar({ children }: RightSidebarProps) {
  const { isRightOpen } = useUIStore((state) => state.sidebar);

  return (
    <aside
      className={cn(
        // Base styles
        'h-full w-80 shrink-0 border-l bg-muted/20 transition-all duration-300 ease-in-out',
        
        // Hide/Show Logic
        isRightOpen ? 'ml-0' : '-mr-[320px] w-0 border-l-0 opacity-0'
      )}
    >
      <div className="h-full overflow-y-auto">
        {children}
      </div>
    </aside>
  );
}

================================================================================

File: features/editor/components/SaveButton.tsx
// src/features/editor/components/SaveButton.tsx
'use client';

import { useEditor } from '@/features/editor/contexts/EditorContext';
import { Button } from '@/core/components/ui/button';
import { Save, Check, Loader2 } from 'lucide-react';

/**
 * A context-aware button that displays the current save state
 * (e.g., Save, Saving..., Saved) and triggers the save action.
 *
 * This component MUST be rendered within a tree wrapped by an `<EditorProvider>`
 * as it relies on the `useEditor` hook for its state and actions.
 */
export default function SaveButton() {
  const { saveState, hasUnsavedChanges, triggerSave } = useEditor();

  // Define the visual states for the button
  const buttonStates = {
    idle: {
      icon: <Save className="h-4 w-4" />,
      text: 'Save',
    },
    saving: {
      icon: <Loader2 className="h-4 w-4 animate-spin" />,
      text: 'Saving...',
    },
    saved: {
      icon: <Check className="h-4 w-4" />,
      text: 'Saved',
    },
  };

  // Determine the current display state and if the button should be disabled
  let currentDisplayState: 'idle' | 'saving' | 'saved';
  let isDisabled = false;

  if (saveState === 'saving') {
    currentDisplayState = 'saving';
    isDisabled = true;
  } else if (hasUnsavedChanges) {
    currentDisplayState = 'idle';
    isDisabled = false;
  } else {
    // This covers both 'saved' and 'no_changes' states.
    // In both cases, the content is considered saved and there's nothing to do.
    currentDisplayState = 'saved';
    isDisabled = true;
  }

  const current = buttonStates[currentDisplayState];

  return (
    <Button variant='ghost' onClick={triggerSave} disabled={isDisabled}>
      {current.icon}
      <span className='hidden md:block'>{current.text}</span>
    </Button>
  );
}

================================================================================

File: features/editor/components/FrontmatterSidebar.tsx
// src/features/editor/components/FrontmatterSidebar.tsx
'use client';

import React, { useState, useEffect, useMemo } from 'react';
import type { LocalSiteData, MarkdownFrontmatter } from '@/types';
import { getAvailableLayouts, getLayoutManifest, LayoutManifest } from '@/core/services/configHelpers.service';
import { RJSFSchema } from '@rjsf/utils'; 
import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Button } from '@/core/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Trash2 } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";
import ViewEditor from '@/features/editor/components/ViewEditor'; 
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm'; 
import HomepageSwitch from './HomepageSwitch'; 

/**
 * Props for the FrontmatterSidebar component.
 */
interface FrontmatterSidebarProps {
  siteId: string;
  filePath: string; // The full path to the content file being edited
  site: Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles' | 'contentFiles'>;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: Partial<MarkdownFrontmatter>) => void;
  isNewFileMode: boolean;
  slug: string;
  onSlugChange: (newSlug: string) => void;
  onDelete: () => Promise<void>;
}

/**
 * Renders the right-hand sidebar in the editor, containing all metadata
 * and settings for the current page (frontmatter).
 */
export default function FrontmatterSidebar({
  siteId, site, frontmatter, filePath, onFrontmatterChange,
  isNewFileMode, slug, onSlugChange, onDelete,
}: FrontmatterSidebarProps) {

  const [availableLayouts, setAvailableLayouts] = useState<LayoutManifest[]>([]);
  const [layoutSchema, setLayoutSchema] = useState<RJSFSchema | null>(null);

  const isCollectionPage = useMemo(() => !!frontmatter.collection, [frontmatter]);

  // Effect to fetch the available layouts (e.g., page, list) for the dropdowns.
  useEffect(() => {
    async function fetchAndFilterLayouts() {
      if (!site) return;
      const requiredLayoutType = isCollectionPage ? 'list' : 'page';
      const filteredLayouts = await getAvailableLayouts(site, requiredLayoutType);
      setAvailableLayouts(filteredLayouts);
    }
    fetchAndFilterLayouts();
  }, [site, isCollectionPage]);

  // Effect to load the JSON schema for the currently selected layout.
  useEffect(() => {
    const loadSchema = async () => {
      if (!frontmatter.layout) {
        setLayoutSchema(null);
        return;
      }
      const manifest = await getLayoutManifest(site, frontmatter.layout);
      setLayoutSchema(manifest?.schema || null);
    };
    loadSchema();
  }, [site, frontmatter.layout]);

  const menuTitleValue = typeof frontmatter.menuTitle === 'string' ? frontmatter.menuTitle : '';
  const handleLayoutChange = (layoutId: string) => {
    onFrontmatterChange({ layout: layoutId });
  };

  return (
    <div className="p-4 space-y-6 h-full flex flex-col">
      <h2 className="text-lg font-semibold border-b pb-3">Page Settings</h2>
      
      {/* Settings are organized into accordions for clarity */}
      <Accordion type="multiple" defaultValue={['general', 'advanced']} className="w-full flex-grow overflow-y-auto">
        <AccordionItem value="general">
          <AccordionTrigger>General</AccordionTrigger>
          <AccordionContent className="space-y-6 pt-4">
            
            {/* The Homepage switch is only visible for existing pages */}
            {!isNewFileMode && (
              <HomepageSwitch
                siteId={siteId}
                pagePath={filePath}
                isHomepage={!!frontmatter.homepage}
              />
            )}

            <div className="space-y-2">
              <Label htmlFor="menu-title-input">Menu Title (Optional)</Label>
              <Input
                id="menu-title-input"
                placeholder="e.g., Home, About Us"
                value={menuTitleValue}
                onChange={(e) => onFrontmatterChange({ menuTitle: e.target.value })}
              />
              <p className="text-xs text-muted-foreground">A short label for navigation menus. If left blank, the page title will be used.</p>
            </div>
           
            <div className="space-y-2">
              <Label htmlFor="page-layout-select">Layout</Label>
              <Select value={frontmatter.layout} onValueChange={handleLayoutChange}>
                  <SelectTrigger id="page-layout-select"><SelectValue placeholder="Select a layout..." /></SelectTrigger>
                  <SelectContent>{availableLayouts.map(layout => <SelectItem key={layout.id} value={layout.id}>{layout.name}</SelectItem>)}</SelectContent>
              </Select>
               <p className="text-xs text-muted-foreground">Controls the appearance of this page.</p>
            </div>

            {layoutSchema && (
                <div className="border-t pt-4">
                     <h4 className="text-sm font-medium mb-2">Layout Options</h4>
                    <SchemaDrivenForm schema={layoutSchema} formData={frontmatter} onFormChange={(data) => onFrontmatterChange(data as Partial<MarkdownFrontmatter>)} />
                </div>
            )}
          </AccordionContent>
        </AccordionItem>

        {isCollectionPage && (
          <AccordionItem value="collection">
            <AccordionTrigger>Collection Display</AccordionTrigger>
            <AccordionContent className="pt-2">
              <ViewEditor siteId={siteId} frontmatter={frontmatter} onFrontmatterChange={onFrontmatterChange} />
            </AccordionContent>
          </AccordionItem>
        )}

        <AccordionItem value="advanced">
          <AccordionTrigger>Advanced</AccordionTrigger>
          <AccordionContent className="space-y-4 pt-4">
              <div className="space-y-2">
                <Label htmlFor="slug-input">URL Slug</Label>
                <Input
                    id="slug-input"
                    value={slug}
                    onChange={(e) => onSlugChange(e.target.value)}
                    disabled={!isNewFileMode}
                    className={!isNewFileMode ? 'bg-muted/50 cursor-not-allowed' : ''}
                />
                <p className="text-xs text-muted-foreground">The unique filename for this page. Can only be set on creation.</p>
              </div>
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      {/* The Delete button is only available for existing pages */}
      {!isNewFileMode && (
        <div className="mt-auto pt-6 border-t shrink-0">
          <AlertDialog>
              <AlertDialogTrigger asChild>
                  <Button variant="outline" className="w-full text-destructive hover:bg-destructive/10 hover:text-destructive">
                      <Trash2 className="h-4 w-4 mr-2" /> Delete This Page
                  </Button>
              </AlertDialogTrigger>
              <AlertDialogContent>
                  <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This action will permanently delete the file for "{frontmatter?.title || 'this content'}" and cannot be undone.
                      </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={onDelete} className="bg-destructive hover:bg-destructive/90 text-destructive-foreground">
                          Yes, Delete Forever
                      </AlertDialogAction>
                  </AlertDialogFooter>
              </AlertDialogContent>
          </AlertDialog>
        </div>
      )}
    </div>
  );
}

================================================================================

File: features/editor/hooks/useUnloadPrompt.ts
// src/features/editor/hooks/useUnloadPrompt.ts
'use client';

import { useEffect } from 'react';

/**
 * A hook that shows the native browser confirmation dialog when the user
 * attempts to navigate away from the page.
 *
 * @param {boolean} shouldPrompt - A flag that determines whether the prompt should be shown.
 */
export function useUnloadPrompt(shouldPrompt: boolean) {
  useEffect(() => {
    const handleBeforeUnload = (event: BeforeUnloadEvent) => {
      if (shouldPrompt) {
        // Standard way to trigger the browser's native confirmation dialog
        event.preventDefault();
        // Required for some older browsers
        event.returnValue = '';
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    // Cleanup the event listener when the component unmounts
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [shouldPrompt]); // The effect re-runs whenever the `shouldPrompt` flag changes
}

================================================================================

File: features/editor/hooks/usePageIdentifier.ts
// src/features/editor/hooks/usePageIdentifier.ts
'use client';

import { useMemo } from 'react';
import { useParams } from 'next/navigation';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';
import { LocalSiteData } from '@/types'; // Import the site data type

/**
 * The hook now accepts the site data as an argument to make it smarter.
 */
interface PageIdentifierParams {
  site: LocalSiteData | undefined;
}

/**
 * Parses the URL to identify the site and the specific file being targeted for editing.
 * It is now data-aware and can correctly identify the homepage file from the root editor URL.
 */
export function usePageIdentifier({ site }: PageIdentifierParams) {
  const params = useParams();
  const siteId = params.siteId as string;
  const slugSegments = useMemo(() => (params.slug as string[]) || [], [params.slug]);

  const isNewFileMode = useMemo(() => slugSegments.includes(NEW_FILE_SLUG_MARKER), [slugSegments]);

  const filePath = useMemo(() => {
    // For creating a new file, the path is its intended parent directory.
    if (isNewFileMode) {
      const parentSlug = slugSegments.slice(0, slugSegments.indexOf(NEW_FILE_SLUG_MARKER)).join('/');
      return parentSlug ? `content/${parentSlug}` : 'content';
    }

    // --- NEW LOGIC FOR EXISTING FILES ---
    if (slugSegments.length > 0) {
      // If the URL has a slug, derive the path directly from it.
      const slug = slugSegments.join('/');
      return `content/${slug}.md`;
    } else {
      // If the URL has NO slug, it means we are at the editor root.
      // We must find the designated homepage file from the site data.
      if (site?.contentFiles) {
        const homepageFile = site.contentFiles.find(f => f.frontmatter.homepage === true);
        // Return the actual path of the homepage file.
        if (homepageFile) {
          return homepageFile.path;
        }
      }
      // Fallback while data is loading or if no homepage is set.
      return '';
    }
  }, [slugSegments, isNewFileMode, site]);

  return { siteId, slugSegments, isNewFileMode, filePath };
}

================================================================================

File: features/editor/hooks/useFileTreeDnd.ts
// src/features/editor/hooks/useFileTreeDnd.ts
'use client';

import { useState, useCallback } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import type { LocalSiteData, StructureNode } from '@/types';
import type { DragEndEvent, DragStartEvent } from '@dnd-kit/core';
import { arrayMove } from '@dnd-kit/sortable';
import { toast } from 'sonner';

// Helper functions can be co-located or moved to a service
function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) return node;
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) return found;
    }
  }
  return undefined;
}

function findParentOfNode(nodes: StructureNode[], path: string, parent: StructureNode | null = null): StructureNode | null {
    for (const node of nodes) {
        if (node.path === path) return parent;
        if (node.children) {
            const found = findParentOfNode(node.children, path, node);
            if (found) return found;
        }
    }
    return null;
}

function updateNodeInChildren(nodes: StructureNode[], parentPath: string, newChildren: StructureNode[]): StructureNode[] {
    return nodes.map(node => {
        if (node.path === parentPath) {
            return { ...node, children: newChildren };
        }
        if (node.children) {
            return { ...node, children: updateNodeInChildren(node.children, parentPath, newChildren) };
        }
        return node;
    });
}

/**
 * A custom hook to manage all drag-and-drop logic for the site's file tree.
 */
export function useFileTreeDnd(site: LocalSiteData | undefined) {
  const { updateManifest, moveNode } = useAppStore.getState();
  const [activeDragId, setActiveDragId] = useState<string | null>(null);

  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveDragId(event.active.id as string);
  }, []);

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    setActiveDragId(null);
    const { active, over, delta } = event;

    if (!site || !over || active.id === over.id) return;
    const siteId = site.siteId;
    const structure = site.manifest.structure;

    const activePath = active.id as string;
    const overPath = over.id as string;

    // --- SCENARIO 1: UN-NESTING ---
    // This is the most definite action, so we check it first.
    if (over.id === '__sidebar_root_droppable__') {
      const parent = findParentOfNode(structure, activePath);
      if (parent) { // Ensure it was actually nested
        moveNode(siteId, activePath, null);
      }
      return;
    }

    const parentOfActive = findParentOfNode(structure, activePath);
    const parentOfOver = findParentOfNode(structure, overPath);
    const targetNode = findNodeByPath(structure, overPath);

    // --- INTENT-BASED LOGIC ---
    // `delta.y` is the vertical distance the mouse moved.
    // `over.rect` is the bounding box of the target item.
    const isDroppingInTopHalf = delta.y < over.rect.height / 2;
    const isDroppingInBottomHalf = delta.y >= over.rect.height / 2;
    
    // --- SCENARIO 2: NESTING (User dropped squarely on a valid target) ---
    // A nesting action is now more explicit. We check if the dragged item is being
    // dropped somewhere in the middle of the target, not near the edges.
    const isNestingAttempt = over.rect.height > 30 && delta.y > 10 && delta.y < (over.rect.height - 10);

    if (isNestingAttempt) {
        if (!parentOfActive && targetNode && !parentOfOver) { // Dragging a root item onto another root item
            const isTargetCollection = !!site.contentFiles?.find(f => f.path === targetNode.path)?.frontmatter.collection;
            if (isTargetCollection) {
                toast.error("Cannot nest pages under a Collection Page.");
                return;
            }
            moveNode(siteId, activePath, overPath);
            return;
        }
    }
    
    // --- SCENARIO 3: REORDERING ---
    // This now covers all other cases. The user is dropping near the top or bottom
    // edge of an item, indicating they want to reorder.
    if (parentOfActive?.path === parentOfOver?.path) {
        const listToReorder = parentOfActive ? parentOfActive.children! : structure;
        const oldIndex = listToReorder.findIndex(n => n.path === activePath);
        let newIndex = listToReorder.findIndex(n => n.path === overPath);

        if (oldIndex === -1 || newIndex === -1) return;
        
        // Adjust index for dropping before/after
        if (isDroppingInBottomHalf && oldIndex < newIndex) {
            // No change needed when dragging down past an item
        } else if (isDroppingInTopHalf && oldIndex > newIndex) {
            // No change needed when dragging up past an item
        } else if (isDroppingInTopHalf) {
            newIndex = newIndex;
        } else if (isDroppingInBottomHalf) {
            newIndex = newIndex + 1;
        }

        const reorderedList = arrayMove(listToReorder, oldIndex, newIndex);
        let newStructure: StructureNode[];

        if (parentOfActive) {
            newStructure = updateNodeInChildren(structure, parentOfActive.path, reorderedList);
        } else {
            newStructure = reorderedList;
        }
        updateManifest(siteId, { ...site.manifest, structure: newStructure });
    } else {
        // This handles moving an item from nested to root, or root to another list (if we allowed it).
        // For un-nesting, the user must drop on the dedicated root zone.
        // This prevents accidental un-nesting when trying to reorder.
    }

  }, [site, moveNode, updateManifest]);

  return {
    activeDragId,
    handleDragStart,
    handleDragEnd,
  };
}

================================================================================

File: features/editor/hooks/useFileContent.ts
// src/features/editor/hooks/useFileContent.ts
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/EditorContext';
// REMOVED: No longer need to read directly from the file system here.
// import * as localSiteFs from '@/core/services/localFileSystem.service'; 
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import type { MarkdownFrontmatter } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';
import { Block } from '@blocknote/core';
import { markdownToBlocks } from '@/core/services/blocknote.service';

export type FileStatus = 'initializing' | 'loading' | 'ready' | 'not_found';
interface PageFrontmatter extends MarkdownFrontmatter { menuTitle?: string; }

export function useFileContent(siteId: string, filePath: string, isNewFileMode: boolean) {
  const router = useRouter();
  const site = useAppStore(state => state.getSiteById(siteId));
  const { setHasUnsavedChanges } = useEditor();

  const [status, setStatus] = useState<FileStatus>('initializing');
  const [frontmatter, setFrontmatter] = useState<PageFrontmatter | null>(null);
  const [slug, setSlug] = useState('');
  const [initialBlocks, setInitialBlocks] = useState<Block[]>([]);

  useEffect(() => {
    const loadData = async () => {
      // Guard clause: wait for the site data to be fully loaded into the store.
      if (!site?.manifest || !site?.contentFiles) {
        setStatus('loading');
        return;
      }

      let markdownContent = '';

      if (isNewFileMode) {
        // Setup for a brand new, unsaved file.
        setFrontmatter({
          title: '',
          layout: DEFAULT_PAGE_LAYOUT_PATH,
          date: new Date().toISOString().split('T')[0],
          status: 'draft',
        });
        markdownContent = '# Start Writing...';
        setSlug('');
      } else {
        // --- FIX: Read directly from the hydrated Zustand store, not IndexedDB ---
        // This eliminates the race condition.
        const fileData = site.contentFiles.find(f => f.path === filePath);

        if (!fileData) {
          setStatus('not_found');
          toast.error(`Content file not found at path: ${filePath}`);
          router.push(`/sites`);
          return;
        }
        
        // Use the data already in the store. No need to re-parse.
        setFrontmatter(fileData.frontmatter);
        markdownContent = fileData.content;
        setSlug(fileData.slug);
      }

      const blocks = await markdownToBlocks(markdownContent);
      setInitialBlocks(blocks);
      setStatus('ready');
      setHasUnsavedChanges(false);
    };

    // Only run if filePath is valid. For a new site, this waits until the redirect happens.
    if (filePath) {
        loadData();
    }
    
  }, [site, filePath, isNewFileMode, siteId, router, setHasUnsavedChanges]);

  const onContentModified = useCallback(() => setHasUnsavedChanges(true), [setHasUnsavedChanges]);

  const handleFrontmatterChange = useCallback((update: Partial<PageFrontmatter>) => {
    setFrontmatter(prev => {
      if (!prev) return null;
      const newFm = { ...prev, ...update };
      if (isNewFileMode && update.title !== undefined) {
        setSlug(slugify(update.title));
      }
      return newFm;
    });
    onContentModified();
  }, [isNewFileMode, onContentModified]);

  return { status, site, frontmatter, initialBlocks, slug, setSlug, handleFrontmatterChange, onContentModified };
}

================================================================================

File: features/editor/hooks/useFilePersistence.ts
// src/features/editor/hooks/useFilePersistence.ts
'use client';

import { useCallback, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/EditorContext';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';
import { toast } from 'sonner';
import type { MarkdownFrontmatter } from '@/types';
import { useUnloadPrompt } from './useUnloadPrompt';
import { Block } from '@blocknote/core';
import { blocksToMarkdown } from '@/core/services/blocknote.service';

interface PersistenceParams {
  siteId: string;
  filePath: string;
  isNewFileMode: boolean;
  frontmatter: MarkdownFrontmatter | null;
  slug: string;
  getEditorContent: () => Block[]; 
}

export function useFilePersistence({
  siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent,
}: PersistenceParams) {
  const router = useRouter();
  const { addOrUpdateContentFile, deleteContentFileAndState, getSiteById } = useAppStore.getState();
  const { hasUnsavedChanges, setHasUnsavedChanges, setSaveState, registerSaveAction } = useEditor();
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleSave = useCallback(async () => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);
    if (!frontmatter) throw new Error("Frontmatter not ready for saving.");
    if (!frontmatter.title.trim()) throw new Error("A title is required before saving.");

    const currentBlocks = getEditorContent();
    const markdownBody = await blocksToMarkdown(currentBlocks);
    
    // --- FIX: Logic is now split for Create vs. Update ---
    if (isNewFileMode) {
      // --- CREATION LOGIC (First Save) ---
      if (!slug.trim()) throw new Error("A URL slug is required for a new page.");
      
      const site = getSiteById(siteId);
      const finalPath = `${filePath}/${slug.trim()}.md`.replace('//', '/');

      // Check for path conflicts before saving
      if (site?.contentFiles?.some(f => f.path === finalPath)) {
        throw new Error(`A page with the path "${slug}" already exists.`);
      }

      const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);
      await addOrUpdateContentFile(siteId, finalPath, rawMarkdown);

      // Transition from "creation mode" to "editing mode" by updating the URL
      const newEditPath = finalPath.replace(/^content\//, '').replace(/\.md$/, '');
      router.replace(`/sites/${siteId}/edit/content/${newEditPath}`);

    } else {
      // --- UPDATE LOGIC (Subsequent Saves) ---
      const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);
      await addOrUpdateContentFile(siteId, filePath, rawMarkdown);
    }
  }, [siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent, addOrUpdateContentFile, getSiteById, router]);

  const handleDelete = useCallback(async () => {
    if (isNewFileMode || !frontmatter) return;
    try {
      await deleteContentFileAndState(siteId, filePath);
      toast.success(`Page "${frontmatter.title}" deleted.`);
      router.push(`/sites/${siteId}/edit`);
    } catch (error) {
      toast.error(`Failed to delete page: ${(error as Error).message}`);
    }
  }, [isNewFileMode, frontmatter, deleteContentFileAndState, siteId, filePath, router]);

  useEffect(() => {
    registerSaveAction(handleSave);
  }, [handleSave, registerSaveAction]);

  useEffect(() => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);
    // Autosave is disabled in new file mode until the first manual save.
    if (hasUnsavedChanges && !isNewFileMode) {
      autosaveTimeoutRef.current = setTimeout(async () => {
        setSaveState('saving');
        try {
          await handleSave();
          setHasUnsavedChanges(false);
          setSaveState('saved');
          setTimeout(() => setSaveState('no_changes'), 2000);
        } catch (error) { console.error("Autosave failed:", error); setSaveState('idle'); }
      }, AUTOSAVE_DELAY);
    }
    return () => { if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current); };
  }, [hasUnsavedChanges, isNewFileMode, handleSave, setSaveState, setHasUnsavedChanges]);

  useUnloadPrompt(hasUnsavedChanges);

  return { handleDelete };
}

================================================================================

File: components/publishing/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { Label } from '@/core/components/ui/label';

interface MarkdownEditorProps {
  initialValue: string;
  // onContentChange is now used primarily by the parent to trigger its own state updates
  onContentChange: (markdown: string) => void;
}

// The ref now needs to expose a method to get the current content
export interface MarkdownEditorRef {
  getMarkdown: () => string;
}

const MarkdownEditor = forwardRef<MarkdownEditorRef, MarkdownEditorProps>(
  ({ initialValue, onContentChange }, ref) => {
    // We'll manage the textarea's value with local state
    const [content, setContent] = useState(initialValue);

    // If the initialValue prop changes from the parent (e.g., loading a new file),
    // we update the local state.
    useEffect(() => {
      setContent(initialValue);
    }, [initialValue]);

    // Expose a function for the parent component to get the current content
    useImperativeHandle(ref, () => ({
      getMarkdown: () => {
        return content;
      },
    }));

    // This handler updates both local state and informs the parent of a change
    const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
      const newContent = event.target.value;
      setContent(newContent);
      onContentChange(newContent); // Let the parent know things have changed
    };

    return (
      <div className="space-y-2 h-full">
      <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400">
            Content
          </Label>
      <textarea
        id="content-body"
        value={content}
        onChange={handleChange}
        placeholder="Start writing your Markdown here..."
        className="w-full h-full bg-background 
                   text-base font-mono leading-relaxed resize-none 
                   focus:ring-2 focus:ring-ring focus:outline-none"
      />
      </div>
    );
  }
);

MarkdownEditor.displayName = 'MarkdownEditor';
export default MarkdownEditor;

================================================================================

File: components/publishing/LeftSidebar.tsx
// src/components/publishing/LeftSidebar.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useMemo, useCallback, useState } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { useUIStore } from '@/core/state/uiStore';
import { Button } from '@/core/components/ui/button';
import FileTree from '@/features/editor/components/FileTree';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
import CreateCollectionPageDialog from '@/features/editor/components/CreateCollectionPageDialog';
import type { StructureNode } from '@/types';
import { cn } from '@/lib/utils';
import { Home, FilePlus, LayoutGrid } from 'lucide-react';
import { toast } from 'sonner';
import { DndContext, DragEndEvent, DragOverlay, DragStartEvent, PointerSensor, useSensor, useSensors, DragOverEvent } from '@dnd-kit/core';
import { Link } from '@/core/components/ui/link';
import { getDescendantIds } from '@/core/services/fileTree.service';

type DndIndicator = {
    path: string;
    intent: 'reorder-before' | 'reorder-after' | 'nest';
} | null;

export default function LeftSidebar() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;

  const site = useAppStore((state) => state.getSiteById(siteId));
  // --- FIX: Use a single, powerful store action ---
  const { repositionNode } = useAppStore.getState(); 
  const { isLeftOpen, toggleLeftSidebar } = useUIStore((state) => state.sidebar);
  const isDesktop = useUIStore((state) => state.screen.isDesktop);

  const [activeId, setActiveId] = useState<string | null>(null);
  const [dndIndicator, setDndIndicator] = useState<DndIndicator>(null);
  
  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 8 } }));

  const handleDragStart = useCallback((event: DragStartEvent) => setActiveId(event.active.id as string), []);
  
  const handleDragOver = useCallback((event: DragOverEvent) => {
    const { over, delta } = event;
    if (!over) {
      setDndIndicator(null);
      return;
    }
    const overId = over.id as string;
    const overData = over.data?.current;

    const isNestingTarget = overData?.type === 'container' && !overData.isCollection;
    const nestingZoneHeight = over.rect.height * 0.6; // 60% of height is the nest zone
    const nestingZoneTop = over.rect.height * 0.2;
    
    // --- INTENT CALCULATION ---
    if (isNestingTarget && delta.y > nestingZoneTop && delta.y < (nestingZoneTop + nestingZoneHeight)) {
      setDndIndicator({ path: overId, intent: 'nest' });
    } else {
      const position = delta.y < over.rect.height / 2 ? 'reorder-before' : 'reorder-after';
      setDndIndicator({ path: overId, intent: position });
    }
  }, []);

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    const activePath = activeId;
    const overPath = event.over?.id as string | undefined;
    const finalIndicator = dndIndicator;

    setActiveId(null);
    setDndIndicator(null);

    if (!site || !activePath || !overPath || !finalIndicator || activePath === overPath) return;

    // --- DELEGATE ALL LOGIC TO THE STORE ACTION ---
    repositionNode(siteId, activePath, overPath, finalIndicator.intent);

  }, [siteId, activeId, dndIndicator, site, repositionNode]);

  const allNodeIds = useMemo(() => site ? getDescendantIds(site.manifest.structure) : [], [site]);
  const homepagePath = useMemo(() => site?.manifest.structure[0]?.path, [site]);

  const activePathForFileTree = useMemo(() => {
    if (!site?.manifest) return undefined;
    const editorRootPath = `/sites/${siteId}/edit/content`;
    if (pathname === editorRootPath || pathname.startsWith(`${editorRootPath}/`)) {
        const slug = pathname.replace(editorRootPath, '').replace(/^\//, '');
        return slug ? `content/${slug}.md` : homepagePath;
    }
    return undefined;
  }, [pathname, site, siteId, homepagePath]);

  if (!site) return null;

  return (
    <>
      {!isDesktop && (<div onClick={toggleLeftSidebar} className={cn('fixed inset-0 z-40 bg-black/60', isLeftOpen ? 'opacity-100' : 'pointer-events-none opacity-0')} /> )}
      <DndContext sensors={sensors} onDragStart={handleDragStart} onDragOver={handleDragOver} onDragEnd={handleDragEnd}>
        <div className="flex h-full flex-col">
          <div className="flex shrink-0 items-center justify-between border-b p-2">
            <h3 className="px-2 text-sm font-semibold uppercase tracking-wider text-muted-foreground">Site Content</h3>
            <div className="flex items-center gap-1">
              <CreateCollectionPageDialog siteId={siteId}><Button variant="ghost" className='size-7 p-1' title="New Collection"><LayoutGrid className="h-4 w-4" /></Button></CreateCollectionPageDialog>
              <NewPageDialog siteId={siteId}><Button variant="ghost" className='size-7 p-1' title="New Page"><FilePlus className="h-4 w-4" /></Button></NewPageDialog>
            </div>
          </div>
          <div className="flex-grow overflow-y-auto p-2">
            {site.manifest.structure.length > 0 ? (
                <FileTree 
                    nodes={site.manifest.structure} 
                    contentFiles={site.contentFiles || []}
                    baseEditPath={`/sites/${siteId}/edit`}
                    activePath={activePathForFileTree}
                    homepagePath={homepagePath}
                    dndIndicator={dndIndicator}
                />
            ) : (
              <div className="px-2 py-4 text-xs text-center text-muted-foreground italic"><p>No pages created yet.</p></div>
            )}
          </div>
          <div className="mt-auto shrink-0 border-t p-2">
            <Button variant="ghost" asChild className="w-full justify-start gap-2"><Link href="/sites"><Home className="h-4 w-4" /> App Dashboard</Link></Button>
          </div>
        </div>
        <DragOverlay>{activeId ? <div className="p-2 bg-background border rounded-md shadow-lg text-sm font-semibold">Moving page...</div> : null}</DragOverlay>
      </DndContext>
    </>
  );
}

================================================================================

File: components/publishing/SchemaDrivenForm.tsx
'use client';

import Form from '@rjsf/shadcn';
import validator from '@rjsf/validator-ajv8';
import { 
  RJSFSchema, 
  UiSchema, 
  FieldTemplateProps, 
  ObjectFieldTemplateProps, 
  RegistryWidgetsType,
  FormContextType
 } from '@rjsf/utils';
import { Label } from '@/core/components/ui/label';


// --- Props Definition ---
interface SchemaDrivenFormProps<T = unknown> {
  schema: RJSFSchema;
  uiSchema?: UiSchema;
  formData: object;
  onFormChange: (data: object) => void;
  liveValidate?: boolean;
  widgets?: RegistryWidgetsType<T>;
  formContext?: FormContextType & T; // <-- Use the official type and our generic
}



// --- Custom Field Template (for better layout and labels) ---
function CustomFieldTemplate(props: FieldTemplateProps) {
  const { id, classNames, label, help, required, description, errors, children, schema } = props;

  if (props.hidden) {
    return <div className="hidden">{children}</div>;
  }
  
  const isCheckbox = schema.type === 'boolean' && (props.uiSchema?.['ui:widget'] === 'checkbox' || props.uiSchema?.['ui:widget'] === undefined);

  if (isCheckbox) {
      return <div className={classNames}>{children}</div>
  }

  return (
    <div className={classNames}>
      {label && (
        <Label htmlFor={id} className="block text-sm font-medium mb-1">
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}
      
      {description}
      
      {children}
      
      {errors}
      
      {help}
    </div>
  );
}

// --- Custom Object Field Template (for overall form layout) ---
function CustomObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  return (
    <div>
        {props.description && <p className="text-sm text-muted-foreground">{props.description}</p>}
        <div className="mt-4">
            {props.properties.map(element => (
                <div key={element.name} className="mb-4">
                    {element.content}
                </div>
            ))}
        </div>
    </div>
  );
}

// --- Custom Submit Button Template (to hide it) ---
// FIXED: The 'props' parameter was defined but never used, so it has been removed.
function HideSubmitButton() {
    return null;
}

/**
 * A reusable component that dynamically generates a form from a given JSON Schema.
 * It uses react-jsonschema-form with a shadcn/ui theme for a consistent look and feel.
 */
export default function SchemaDrivenForm<T>({ 
  schema, 
  uiSchema, 
  formData, 
  onFormChange, 
  liveValidate = false,
  widgets,
  formContext 
}: SchemaDrivenFormProps<T>) {

  const safeFormData = formData || {};

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={safeFormData}
      validator={validator}
      onChange={(e) => onFormChange(e.formData)}
      liveValidate={liveValidate}
      showErrorList={false}
      widgets={widgets}
      formContext={formContext}
      
      templates={{
        FieldTemplate: CustomFieldTemplate,
        ObjectFieldTemplate: CustomObjectFieldTemplate,
        ButtonTemplates: {
            SubmitButton: HideSubmitButton,
        }
      }}
    />
  );
}

================================================================================

File: components/publishing/GroupedFrontmatterFields.tsx
// src/components/publishing/GroupedFrontmatterFields.tsx
'use client';

import { useMemo } from 'react';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import SchemaDrivenForm from './SchemaDrivenForm';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/core/components/ui/accordion";

interface Group {
  title: string;
  fields: string[];
}
type StrictUiSchema = UiSchema & { 'ui:groups'?: Group[] };

interface GroupedFrontmatterFormProps {
  schema: RJSFSchema;
  uiSchema?: StrictUiSchema;
  formData: Record<string, unknown>;
  onFormChange: (newData: Record<string, unknown>) => void;
}

function createSubSchema(originalSchema: RJSFSchema, fields: string[]): RJSFSchema {
  const subSchema: RJSFSchema = { ...originalSchema, properties: {}, required: originalSchema.required?.filter(field => fields.includes(field)) };
  if (!subSchema.properties) subSchema.properties = {};
  for (const field of fields) {
    if (originalSchema.properties && originalSchema.properties[field]) {
      subSchema.properties[field] = originalSchema.properties[field];
    }
  }
  return subSchema;
}

export default function GroupedFrontmatterForm({
  schema,
  uiSchema,
  formData,
  onFormChange,
}: GroupedFrontmatterFormProps) {
  
  const { groups, ungroupedFields } = useMemo(() => {
    const definedGroups = uiSchema?.['ui:groups'] || [];
    const allSchemaFields = Object.keys(schema.properties || {});
    const fieldsInGroups = new Set(definedGroups.flatMap(g => g.fields));
    const remainingFields = allSchemaFields.filter(f => !fieldsInGroups.has(f));
    return { groups: definedGroups, ungroupedFields: remainingFields };
  }, [schema, uiSchema]);

  // FIXED: The handler now accepts the event from rjsf and extracts the formData.
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onFormChange(event.formData || {});
  };

  if (!schema.properties || Object.keys(schema.properties).length === 0) {
    return <p className="text-sm text-muted-foreground">This layout has no configurable fields.</p>;
  }

  return (
    <div className="border-t">
      <Accordion type="multiple" defaultValue={groups.map(g => g.title)} className="w-full">
        {groups.map((group) => {
          if (group.fields.length === 0) return null;
          return (
            <AccordionItem value={group.title} key={group.title}>
              <AccordionTrigger>{group.title}</AccordionTrigger>
              <AccordionContent className="pt-4">
                <SchemaDrivenForm
                  schema={createSubSchema(schema, group.fields)}
                  formData={formData}
                  onFormChange={handleChange}
                />
              </AccordionContent>
            </AccordionItem>
          );
        })}
      </Accordion>

      {ungroupedFields.length > 0 && (
        <div className="">
            <Accordion type='single' collapsible>

<AccordionItem value="item-1">                <AccordionTrigger>
                  Fields
                </AccordionTrigger>
                <AccordionContent>
<SchemaDrivenForm
            schema={createSubSchema(schema, ungroupedFields)}
            formData={formData}
            onFormChange={handleChange}
          />
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </div>
      )}
    </div>
  );
}

================================================================================

File: components/layout/ThreeColumnLayout.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';
import EditorHeader from '@/features/editor/components/EditorHeader';

interface ThreeColumnLayoutProps {
  leftSidebar: ReactNode;
  rightSidebar: ReactNode;
  children: ReactNode;
  headerActions?: ReactNode;
}

export default function ThreeColumnLayout({ leftSidebar, rightSidebar, children, headerActions }: ThreeColumnLayoutProps) {
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const isRightOpen = useUIStore((state) => state.sidebar.isRightOpen);

  return (
    <div className="flex h-screen w-full flex-col bg-muted/20">
      <EditorHeader actions={headerActions} />
      
      {/* This is now the positioning context for all three columns */}
      <div className="relative flex-1 overflow-hidden">
        
        
        {/* Left Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 left-0 z-20 h-full w-72 border-r bg-background transition-transform duration-300 ease-in-out',
            isLeftOpen ? 'translate-x-0' : '-translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {leftSidebar}
          </div>
        </aside>

        {/* Main Content: The layout is now controlled by padding */}
        <main
          className={cn(
            'h-full overflow-y-auto transition-all duration-300 ease-in-out',
            // When left sidebar is open, add left padding
            isLeftOpen ? 'lg:pl-72' : 'lg:pl-0',
            // When right sidebar is open, add right padding
            isRightOpen ? 'lg:pr-80' : 'lg:pr-0'
          )}
        >
          {children}
        </main>

        {/* Right Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 right-0 z-10 h-full w-80 border-l bg-background transition-transform duration-300 ease-in-out',
            isRightOpen ? 'translate-x-0' : 'translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {rightSidebar}
          </div>
        </aside>
      </div>
    </div>
  );
}

================================================================================

File: lib/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { Input } from 'gray-matter'; // Import GrayMatterOption and Input
//import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { MarkdownFrontmatter, ParsedMarkdownFile } from '@/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Signum focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: lib/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: lib/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: lib/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { LocalSiteData, ParsedMarkdownFile, Manifest } from '@/types';
import { parseMarkdownString } from './markdownParser';
import { flattenStructureToPages } from '../core/services/fileTree.service';

async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const url = new URL(filePath, baseUrl).href;
  const response = await fetch(url, { cache: 'no-store' });
  if (!response.ok) {
    throw new Error(`Fetch failed for ${url}: ${response.statusText}`);
  }
  return response.text();
}

/**
 * Fetches and reconstructs an entire remote Signum site into the LocalSiteData format.
 * It fetches the manifest, then fetches all content files listed within it.
 * @param remoteSiteUrl The base URL of the remote Signum site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json, which is now the single source of truth.
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_signum/manifest.json');
    const manifest: Manifest = JSON.parse(manifestString);

    if (!manifest || !manifest.siteId || !manifest.structure) {
        throw new Error("Invalid manifest structure fetched from remote site.");
    }
    
    // 2. Collect all unique file paths from the manifest structure.
    const allPageNodes = flattenStructureToPages(manifest.structure);
    const contentFilePaths = [...new Set(allPageNodes.map(node => node.path))];

    // 3. Fetch all content files in parallel.
    const contentFilesPromises = contentFilePaths.map(async (path) => {
        try {
            const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, `_signum/${path}`);
            const { frontmatter, content } = parseMarkdownString(rawMarkdown);
            const slug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
            return { slug, path, frontmatter, content };
        } catch (error) {
            console.warn(`Could not fetch or parse content file: ${path}`, error);
            return null; // Return null on failure for this specific file
        }
    });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];

    // 4. Construct the final LocalSiteData object.
    const finalSiteData: LocalSiteData = {
      siteId: `remote-${manifest.siteId}`, // Prefix to distinguish in local state
      manifest: manifest,
      contentFiles: validContentFiles,
    };

    return finalSiteData;

  } catch (error) {
    console.error(`CRITICAL ERROR fetching remote site data for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

