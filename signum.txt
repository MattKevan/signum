FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: public, node_modules, ios
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html, *.json, *.hbs
================================================================================

File: types/index.ts
// src/types/index.ts

/**
 * Represents a node in the site's hierarchical structure, as defined in `manifest.json`.
 * Every node is a page, which can have child pages nested under it.
 * Whether a page acts as a "Collection Page" is determined by its frontmatter,
 * not by a property on this node.
 */
export interface StructureNode {
  type: 'page'; // The 'type' is now always 'page'.
  title: string;
  path: string; // The full path to the .md file (e.g., 'content/blog.md').
  slug: string; // The URL-friendly version of the path (e.g., 'blog').
  navOrder?: number;
  children?: StructureNode[];
  [key: string]: unknown;
}

/**
 * Represents the theme configuration saved in the manifest, including
 * the theme's name and any user-defined overrides.
 */
export interface ThemeConfig {
  name: string;
  config: {
    [key: string]: string | boolean | number;
  };
}

/**
 * Represents metadata for a layout asset, used for populating UI selectors.
 */
export interface LayoutInfo {
  id: string;
  name: string;
  type: 'page' | 'list' | 'item';
  path: string;
  description?: string;
}

/**
 * Represents metadata for a theme asset, used for populating UI selectors.
 */
export interface ThemeInfo {
  id: string;
  name: string;
  path: string;
}

/**
 * Defines the structure for a remote data source query (future feature).
 */
export interface DataSourceConfig {
  url: string;
  format: 'json' | 'csv';
  array_path?: string; // e.g., "results.items" for nested JSON
}



export interface CollectionConfig {
  item_layout: string;
  item_page_layout: string; 
  sort_by?: string;
  sort_order?: 'asc' | 'desc';
  items_per_page?: number;
  // Future: filter config
}


/**
 * Represents the fields within a content file's YAML frontmatter.
 */
export interface MarkdownFrontmatter {
  title: string;
  layout: string; // The layout for this specific page's content.
  collection?: CollectionConfig;
  [key: string]: unknown;
}

/**
 * Represents a raw markdown file that has been parsed from storage into its constituent parts.
 */
export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

/**
 * Represents a generic raw file (e.g., theme CSS, layout JSON) read from storage.
 */
export interface RawFile {
  path: string;
  content: string;
}

/**
 * Represents the data required for rendering pager controls.
 */
export interface PaginationData {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    hasPrevPage: boolean;
    hasNextPage: boolean;
    prevPageUrl?: string;
    nextPageUrl?: string;
}

/**
 * Represents the main `manifest.json` file for a single site. This is the
 * top-level configuration and site map.
 */
export interface Manifest {
  siteId: string;
  generatorVersion: string;
  title: string;
  description: string;
  author?: string;
  baseUrl?: string;
  theme: ThemeConfig;
  structure: StructureNode[];
  layouts?: LayoutInfo[];
  themes?: ThemeInfo[];
}

/**
 * Represents the complete data for a single site when held in the application's memory.
 */
export interface LocalSiteData {
  siteId: string;
  manifest: Manifest;
  contentFiles?: ParsedMarkdownFile[];
  layoutFiles?: RawFile[];
  themeFiles?: RawFile[];
  // Future: viewFiles?: RawFile[]
}

/**
 * Represents a link used for rendering navigation menus.
 * This is a derived type, not part of the core manifest data.
 */
export interface NavLinkItem {
  href: string;
  label: string;
  isActive?: boolean;
  children?: NavLinkItem[];
}

/**
 * An enum to clearly distinguish the outcome of a page resolution attempt.
 */
export enum PageType {
  SinglePage,
  NotFound,
}

/**
 * Represents the complete, resolved data package for a single page render.
 * This object is the output of the pageResolver and the input for the themeEngine.
 */
export type PageResolutionResult = {
  type: PageType.SinglePage;
  pageTitle: string;
  contentFile: ParsedMarkdownFile;
  layoutPath: string;
  collectionItems?: ParsedMarkdownFile[]; 
  pagination?: PaginationData;
} | {
  type: PageType.NotFound;
  errorMessage: string;
};

================================================================================

File: core/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/state/uiStore.ts
// src/core/state/uiStore.ts

import { create, StateCreator } from 'zustand';
import { ReactNode } from 'react';

// --- Helper for screen size ---
const isDesktopView = () => typeof window !== 'undefined' && window.innerWidth >= 1024;

// --- Type Definitions for the store structure ---

// Defines the shape of the data in the sidebar slice
interface SidebarState {
  isLeftOpen: boolean;
  isRightOpen: boolean;
  isLeftAvailable: boolean;
  isRightAvailable: boolean;
  leftSidebarContent: ReactNode | null;
  rightSidebarContent: ReactNode | null;
}

// Defines the actions available in the sidebar slice
interface SidebarActions {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  setLeftAvailable: (available: boolean) => void;
  setRightAvailable: (available: boolean) => void;
  setRightOpen: (isOpen: boolean) => void;
  setLeftSidebarContent: (content: ReactNode | null) => void;
  setRightSidebarContent: (content: ReactNode | null) => void;
}

// Defines the shape of the data in the screen slice
interface ScreenState {
  isDesktop: boolean;
  isInitialized: boolean;
}

// Defines the actions available in the screen slice
interface ScreenActions {
    initializeScreenSize: () => void;
}

// The full store shape, combining state and actions
type UIState = {
    sidebar: SidebarState & SidebarActions;
    screen: ScreenState & ScreenActions;
}

// --- Store Slice Implementations ---

// Creates the sidebar slice of the store
const createSidebarSlice: StateCreator<UIState, [], [], { sidebar: SidebarState & SidebarActions }> = (set, get) => ({
  sidebar: {
    isLeftOpen: isDesktopView(),
    isRightOpen: isDesktopView(),
    isLeftAvailable: false,
    isRightAvailable: false,
    leftSidebarContent: null,
    rightSidebarContent: null,
    toggleLeftSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isLeftOpen: !state.sidebar.isLeftOpen, 
            // On mobile, opening one sidebar closes the other
            isRightOpen: !get().screen.isDesktop && !state.sidebar.isLeftOpen ? false : state.sidebar.isRightOpen 
        }
    })),
    toggleRightSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isRightOpen: !state.sidebar.isRightOpen, 
            isLeftOpen: !get().screen.isDesktop && !state.sidebar.isRightOpen ? false : state.sidebar.isLeftOpen 
        }
    })),
    setLeftAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isLeftAvailable: available }})),
    setRightAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isRightAvailable: available }})),
    setRightOpen: (isOpen) => set(state => ({ sidebar: { ...state.sidebar, isRightOpen: isOpen }})),
    setLeftSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, leftSidebarContent: content }})),
    setRightSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, rightSidebarContent: content }})),

  }
});

// Creates the screen slice of the store
const createScreenSlice: StateCreator<UIState, [], [], { screen: ScreenState & ScreenActions }> = (set, get) => ({
    screen: {
        isDesktop: isDesktopView(),
        isInitialized: false, // Initialize the flag to false
        initializeScreenSize: () => {
          // Add a guard clause to prevent running more than once
          if (get().screen.isInitialized) return;

          // Set the flag to true immediately to block re-entry
          set(state => ({
            screen: { ...state.screen, isInitialized: true }
          }));

          if (typeof window === 'undefined') return;

          const handleResize = () => {
            const desktop = isDesktopView();
            if (desktop !== get().screen.isDesktop) {
              set({
                  screen: { ...get().screen, isDesktop: desktop },
                  sidebar: { ...get().sidebar, isLeftOpen: desktop, isRightOpen: desktop }
                });
            }
          };
          window.addEventListener('resize', handleResize);
          handleResize();
        },
    }
});


// Combine the slices to create the final store
export const useUIStore = create<UIState>()((...a) => ({
    ...createSidebarSlice(...a),
    ...createScreenSlice(...a),
}));

================================================================================

File: core/state/useAppStore.ts
// src/stores/useAppStore.ts
import { create } from 'zustand';
import {  enableMapSet } from 'immer';
import { SiteSlice, createSiteSlice } from './slices/siteSlice';
import { ContentSlice, createContentSlice } from './slices/contentSlice';

// Enable Immer for Map and Set support
enableMapSet();

// The full store type is an intersection of all slice types
type AppStore = SiteSlice & ContentSlice & {
  isInitialized: boolean;
  initialize: () => void;
};

export const useAppStore = create<AppStore>()((...a) => ({
  isInitialized: false,
  initialize: () => {
    const set = a[0]; // Zustand's `set` function
    if (a[1]().isInitialized) return;
    console.log('[AppStore] Initializing application state...');
    set({ isInitialized: true });
  },
  ...createSiteSlice(...a),
  ...createContentSlice(...a),
}));

================================================================================

File: core/state/slices/contentSlice.ts
// src/core/state/slices/contentSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { ParsedMarkdownFile, StructureNode } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { getParentPath, findNodeByPath, findAndRemoveNode, updatePathsRecursively } from '@/core/services/fileTree.service';
import { toast } from 'sonner';
import { SiteSlice } from '@/core/state/slices/siteSlice';
import { stringifyToMarkdown } from '@/lib/markdownParser';

// The ContentSlice now only focuses on page/file operations.
export interface ContentSlice {
  /**
   * Creates a new content file or updates an existing one, and updates the manifest structure.
   * @param siteId - The ID of the site.
   * @param filePath - The full path of the file to save (e.g., 'content/about.md').
   * @param rawMarkdownContent - The full string content of the file, including frontmatter.
   * @returns {Promise<boolean>} True if the operation was successful.
   */
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string) => Promise<boolean>;

  /**
   * Deletes a content file from storage and its node from the manifest structure.
   * @param {string} siteId - The ID of the site.
   * @param {string} filePath - The full path of the file to delete.
   * @returns {Promise<void>}
   */
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;

  /**
   * Moves a page node (and all its children) to a new parent in the site structure.
   * @param {string} siteId - The ID of the site.
   * @param {string} draggedNodePath - The path of the page being moved.
   * @param {string | null} targetNodePath - The path of the target page to nest under, or null to un-nest to the root.
   * @returns {Promise<void>}
   */
  moveNode: (siteId: string, draggedNodePath: string, targetNodePath: string | null) => Promise<void>;

  /**
   * Updates only the content of a file in storage and state. Used for fast autosaving.
   * @param siteId - The ID of the site.
   * @param savedFile - The parsed markdown file object to save.
   * @returns {Promise<void>}
   */
  updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile) => Promise<void>;
}

export const createContentSlice: StateCreator<SiteSlice & ContentSlice, [], [], ContentSlice> = (set, get) => ({

    updateContentFileOnly: async (siteId, savedFile) => {
        // This function now just calls the saveContentFile which handles parsing and slug generation
        await localSiteFs.saveContentFile(siteId, savedFile.path, stringifyToMarkdown(savedFile.frontmatter, savedFile.content));

        // The state update remains the same, but the data is now more consistent
        set(produce((draft: SiteSlice) => {
            const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
            if (siteToUpdate?.contentFiles) {
                const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
                if (fileIndex !== -1) {
                    siteToUpdate.contentFiles[fileIndex] = savedFile;
                } else {
                    siteToUpdate.contentFiles.push(savedFile);
                }
            }
        }));
    },

  addOrUpdateContentFile: async (siteId, filePath, rawMarkdownContent) => {
    // The file system service now handles parsing and slug generation, returning the complete object.
    const savedFile = await localSiteFs.saveContentFile(siteId, filePath, rawMarkdownContent);
    const site = get().getSiteById(siteId);
    if (!site || !site.contentFiles) return false;

    const isNewFile = !site.contentFiles.some(f => f.path === filePath);

    const newManifest = produce(site.manifest, draft => {
        let parentFound = false;
        const parentPath = getParentPath(filePath);

        const findAndUpdateParent = (nodes: StructureNode[]): StructureNode[] => {
            return nodes.map(node => {
                const nodeAsDir = node.path.replace(/\.md$/, '');
                if (isNewFile && parentPath === nodeAsDir) {
                    parentFound = true;
                    return {
                        ...node,
                        children: [
                            ...(node.children || []),
                            {
                                type: 'page',
                                title: savedFile.frontmatter.title,
                                path: filePath,
                                // This slug is now correct because it was generated by the file service
                                slug: savedFile.slug,
                            }
                        ]
                    };
                }

                if (!isNewFile && node.path === filePath && node.title !== savedFile.frontmatter.title) {
                    return { ...node, title: savedFile.frontmatter.title };
                }

                if (node.children) {
                    return { ...node, children: findAndUpdateParent(node.children) };
                }
                return node;
            });
        };

        draft.structure = findAndUpdateParent(draft.structure);

        if (isNewFile && !parentFound && parentPath === 'content') {
          draft.structure.push({
              type: 'page',
              title: savedFile.frontmatter.title,
              path: filePath,
              // This slug is also now correct
              slug: savedFile.slug,
              navOrder: draft.structure.length
          });
        }
    });

    await localSiteFs.saveManifest(siteId, newManifest);

    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
            siteToUpdate.manifest = newManifest;
            // The file was already updated in the store by saveContentFile, but this ensures consistency
            if (!siteToUpdate.contentFiles) siteToUpdate.contentFiles = [];
            const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === filePath);
            if (fileIndex !== -1) {
                siteToUpdate.contentFiles[fileIndex] = savedFile;
            } else {
                siteToUpdate.contentFiles.push(savedFile);
            }
        }
    }));
    return true;
  },

  deleteContentFileAndState: async (siteId, filePath) => {
    const site = get().getSiteById(siteId);
    if (!site) return;

    const newManifest = produce(site.manifest, draft => {
        const filterStructure = (nodes: StructureNode[]): StructureNode[] => {
            return nodes
                .filter(node => node.path !== filePath)
                .map(node => {
                    if (node.children) {
                        node.children = filterStructure(node.children);
                    }
                    return node;
                });
        };
        draft.structure = filterStructure(draft.structure);
    });

    await Promise.all([
      localSiteFs.deleteContentFile(siteId, filePath),
      get().updateManifest(siteId, newManifest)
    ]);

    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate?.contentFiles) {
            siteToUpdate.contentFiles = siteToUpdate.contentFiles.filter(f => f.path !== filePath);
        }
    }));
  },

 moveNode: async (siteId, draggedNodePath, targetNodePath) => {
    const site = get().getSiteById(siteId);
    if (!site) {
      toast.error("Site data not found.");
      return;
    }

    const draggedNodeInfo = findNodeByPath(site.manifest.structure, draggedNodePath);
    if (!draggedNodeInfo) {
      toast.error("The page to move could not be found.");
      return;
    }

    const targetNodeInfo = targetNodePath ? findNodeByPath(site.manifest.structure, targetNodePath) : null;
    if (targetNodePath && !targetNodeInfo) {
      toast.error("The target destination could not be found.");
      return;
    }

    const { found: draggedNode, tree: treeWithoutDraggedNode } = findAndRemoveNode([...site.manifest.structure], draggedNodePath);
    if (!draggedNode) {
      toast.error("An error occurred while moving the page.");
      return;
    }

    const newParentPath = targetNodePath ? targetNodePath.replace(/\.md$/, '') : 'content';
    const updatedNode = updatePathsRecursively(draggedNode, newParentPath);

    const pathsToMove: { oldPath: string, newPath: string }[] = [];
    const collectPaths = (newNode: StructureNode, oldNode: StructureNode) => {
        pathsToMove.push({ oldPath: oldNode.path, newPath: newNode.path });
        if (newNode.children && oldNode.children) {
            newNode.children.forEach((child, i) => collectPaths(child, oldNode.children![i]));
        }
    };
    collectPaths(updatedNode, draggedNode);

    await localSiteFs.moveContentFiles(siteId, pathsToMove);

    let finalTree: StructureNode[];
    if (targetNodePath) {
        const insertIntoTree = (nodes: StructureNode[]): StructureNode[] => nodes.map(node => {
            if (node.path === targetNodePath) return { ...node, children: [...(node.children || []), updatedNode] };
            if (node.children) return { ...node, children: insertIntoTree(node.children) };
            return node;
        });
        finalTree = insertIntoTree(treeWithoutDraggedNode);
    } else {
        finalTree = [...treeWithoutDraggedNode, updatedNode];
    }

    const newManifest = { ...site.manifest, structure: finalTree };
    await get().updateManifest(siteId, newManifest);

    await get().loadSite(siteId);
    toast.success(`Moved "${updatedNode.title}" successfully.`);
  },
});

================================================================================

File: core/state/slices/siteSlice.ts
// src/core/state/slices/siteSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { LocalSiteData, Manifest } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { toast } from 'sonner';

export interface SiteSlice {
  sites: LocalSiteData[];
  loadingSites: Set<string>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
  loadSite: (siteId: string) => Promise<void>;
  addSite: (siteData: LocalSiteData) => Promise<void>;
  updateManifest: (siteId: string, manifest: Manifest) => Promise<void>;
  deleteSiteAndState: (siteId: string) => Promise<void>;
}

export const createSiteSlice: StateCreator<SiteSlice, [], [], SiteSlice> = (set, get) => ({
  sites: [],
  loadingSites: new Set(),
  getSiteById: (siteId) => get().sites.find(s => s.siteId === siteId),

  loadSite: async (siteId) => {
    if (get().loadingSites.has(siteId)) return;
    const existingSite = get().getSiteById(siteId);
    if (existingSite && existingSite.contentFiles) return;
    
    set(produce(draft => { draft.loadingSites.add(siteId); }));

    try {
      const manifest = await localSiteFs.getManifestById(siteId);
      if (!manifest) throw new Error(`Failed to load manifest for siteId: ${siteId}`);
      
      const [contentFiles, layoutFiles, themeFiles] = await Promise.all([
        localSiteFs.getSiteContentFiles(siteId),
        localSiteFs.getSiteLayoutFiles(siteId),
        localSiteFs.getSiteThemeFiles(siteId)
      ]);

      const loadedSiteData: LocalSiteData = { siteId, manifest, contentFiles, layoutFiles, themeFiles };

      set(produce((draft: SiteSlice) => {
        const siteIndex = draft.sites.findIndex(s => s.siteId === siteId);
        if (siteIndex > -1) {
          draft.sites[siteIndex] = loadedSiteData;
        } else {
          draft.sites.push(loadedSiteData);
        }
      }));
    } catch (error) {
      toast.error(`Could not load site data for ID: ${siteId}`);
      console.error(`[AppStore.loadSite] Error during load for ${siteId}:`, error);
    } finally {
      set(produce(draft => { draft.loadingSites.delete(siteId); }));
    }
  },

  addSite: async (newSiteData) => {
    await localSiteFs.saveSite(newSiteData);
    set(produce((draft: SiteSlice) => {
      if (!draft.sites.some(s => s.siteId === newSiteData.siteId)) {
        draft.sites.push(newSiteData);
      }
    }));
  },

  updateManifest: async (siteId, newManifest) => {
    await localSiteFs.saveManifest(siteId, newManifest);
    set(produce((draft: SiteSlice) => {
      const site = draft.sites.find(s => s.siteId === siteId);
      if (site) site.manifest = newManifest;
    }));
  },

  deleteSiteAndState: async (siteId) => {
    await localSiteFs.deleteSite(siteId);
    set(produce((draft: SiteSlice) => {
      draft.sites = draft.sites.filter(s => s.siteId !== siteId);
    }));
  },
});

================================================================================

File: core/components/Navbar.tsx
// src/components/core/Navbar.tsx
'use client';

import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation'; // Import useRouter
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { Button } from '@/core/components/ui/button';
import { Input } from '@/core/components/ui/input'; // Import Input
import React, { useState } from 'react';

// ... (NavLink component remains the same) ...
const NavLink: React.FC<{ href: string; label: string; icon?: React.ReactNode; }> = ({ href, label, icon }) => {
  const pathname = usePathname();
  const isActive = pathname === href || (href !== '/' && pathname.startsWith(href));
  return (
    <Button  className={`justify-start ${isActive ? 'bg-accent text-accent-foreground' : ''}`}>
      <Link href={href} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};


export default function Navbar() {
  const router = useRouter();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim()); // Basic URL validation
        // We need a way to signify this is a remote URL to our browsing pages.
        // Option 1: Special prefix for siteId, e.g., "remote::http://localhost:8080"
        // Option 2: A different route, e.g., /browse/remote?url=...
        // Option 3: Pass state via router.push (can be complex with SSR/layouts)

        // Let's use Option 1: Prefix the siteId with "remote@" or similar marker
        // and encode the URL. The browsing page will then decode it.
        const encodedUrl = encodeURIComponent(url.origin); // Use origin (scheme + hostname + port)
        router.push(`/remote@${encodedUrl}`); // Navigate to /remote@http%3A%2F%2Flocalhost%3A8080
        setRemoteUrl(''); // Clear input
      } catch (error) {
        alert("Invalid URL entered.");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        <Link href="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
        </Link>
        
        {/* Remote Site URL Input */}
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Signum site URL (e.g., http://localhost:8080)"
              className="pl-9" // Padding for the icon
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          <NavLink href="/" label="Dashboard" icon={<Home className="h-4 w-4" />} />
          {/* ... other links ... */}
        </nav>

        <div className="md:hidden">
          <Button  >
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: core/components/HashLink.tsx
// src/core/components/ui/HashLink.tsx
'use client';

import { AnchorHTMLAttributes, FC, forwardRef } from 'react';
import { cn } from '@/lib/utils';

interface HashLinkProps extends AnchorHTMLAttributes<HTMLAnchorElement> {
  // 'to' will be the path without the hash, e.g., "/sites/123"
  to: string;
}

export const HashLink: FC<HashLinkProps> = forwardRef<HTMLAnchorElement, HashLinkProps>(
  ({ to, children, className, ...props }, ref) => {
    // The href is constructed with the required # prefix.
    // We remove a leading slash from 'to' if it exists, as the # acts as the root.
    const href = `#${to.startsWith('/') ? to : `/${to}`}`;
    return (
      <a href={href} className={cn(className)} ref={ref} {...props}>
        {children}
      </a>
    );
  }
);
HashLink.displayName = 'HashLink';

================================================================================

File: core/components/Footer.tsx
// src/components/core/Footer.tsx
import Link from 'next/link';
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p>© {currentYear} Signum Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: core/components/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: core/components/ErrorBoundary.tsx
// src/components/core/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/core/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    // Update state so the next render will show the fallback UI.
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // You can also log the error to an error reporting service
    console.error("Uncaught error:", error, errorInfo);
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: undefined });
    // Optionally, you could try to trigger a reload or navigate home
    // window.location.assign('/'); 
  }

  public render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center bg-destructive/10 border border-destructive rounded-lg">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h1 className="text-2xl font-bold text-destructive-foreground">Something went wrong.</h1>
          <p className="text-muted-foreground mt-2 mb-4">
            An unexpected error occurred. Please try refreshing the page.
          </p>
          {this.state.error && (
            <details className="w-full max-w-lg text-left bg-background p-2 rounded border mb-4">
                <summary className="cursor-pointer text-sm font-medium">Error Details</summary>
                <pre className="mt-2 text-xs text-muted-foreground whitespace-pre-wrap break-all">
                    {this.state.error.message}
                </pre>
            </details>
          )}
          <Button onClick={() => window.location.reload()} variant="destructive">
            Refresh Page
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

================================================================================

File: core/components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/components/ui/link.tsx
import * as Headless from '@headlessui/react'
import NextLink, { type LinkProps } from 'next/link'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: LinkProps & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <NextLink {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})

================================================================================

File: core/components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: core/components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: core/components/ui/accordion.tsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex border-b">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 text-xs font-semibold uppercase tracking-wider text-muted-foreground transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 py-2 px-2",
          className
        )}
        {...props}
      >
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0 transition-transform duration-200 mr-1" />
        {children}
        
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm py-4 px-3"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================

File: core/components/ui/switch.tsx
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


================================================================================

File: core/components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: core/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: core/components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: core/components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: core/components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: core/hooks/useAutosave.ts
// src/hooks/useAutosave.ts
'use client';

import { useEffect, useRef } from 'react';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';

interface AutosaveParams<TData> {
  /** The generic data to be saved. */
  dataToSave: TData;
  /** A flag indicating if there are pending changes. */
  hasUnsavedChanges: boolean;
  /** A flag to prevent saving if the content isn't in a saveable state. */
  isSaveable: boolean;
  /** The function that performs the save operation with the generic data. */
  onSave: (data: TData) => Promise<void>;
}

/**
 * A generic custom hook to handle autosaving content after a specified delay.
 * It encapsulates the timer logic and effect management for saving drafts.
 */
export function useAutosave<TData>({ dataToSave, hasUnsavedChanges, isSaveable, onSave }: AutosaveParams<TData>) {
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (autosaveTimeoutRef.current) {
      clearTimeout(autosaveTimeoutRef.current);
    }

    if (hasUnsavedChanges && isSaveable) {
      autosaveTimeoutRef.current = setTimeout(() => {
        onSave(dataToSave);
      }, AUTOSAVE_DELAY);
    }

    return () => {
      if (autosaveTimeoutRef.current) {
        clearTimeout(autosaveTimeoutRef.current);
      }
    };
  }, [dataToSave, hasUnsavedChanges, isSaveable, onSave]);
}

================================================================================

File: core/hooks/useInitialiseUIStore.ts
'use client';

import { useUIStore } from '@/core/state/uiStore';
import { useEffect } from 'react';

export function useInitialiseUIStore() {
  const initialize = useUIStore((state) => state.screen.initializeScreenSize);
  const isInitialized = useUIStore((state) => state.screen.isInitialized);

  useEffect(() => {
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);
}   

================================================================================

File: core/hooks/useHashNavigation.ts
// src/core/hooks/useHashNavigation.ts
'use client';

import { useState, useEffect } from 'react';

// A helper to safely get the hash and clean it up.
function getCleanHash() {
  if (typeof window === 'undefined') return '/';
  // Get the hash, remove the leading #, and ensure it starts with a /
  const hash = window.location.hash.substring(1);
  return hash.startsWith('/') ? hash : `/${hash}`;
}

export function useHashNavigation() {
  const [currentPath, setCurrentPath] = useState(getCleanHash());

  useEffect(() => {
    const handleHashChange = () => {
      setCurrentPath(getCleanHash());
    };

    // Listen for changes to the hash
    window.addEventListener('hashchange', handleHashChange);
    // Set the initial path when the component mounts
    handleHashChange();

    return () => {
      window.removeEventListener('hashchange', handleHashChange);
    };
  }, []);

  return currentPath;
}

================================================================================

File: core/services/configHelpers.service.ts
// src/core/services/configHelpers.service.ts

import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { CORE_LAYOUTS, CORE_THEMES, BASE_SCHEMA } from '@/config/editorConfig';
import {
    LocalSiteData,
    Manifest,
    LayoutInfo,
    ThemeInfo,
    RawFile,
} from '@/types';

// --- Type Definitions ---

export type StrictUiSchema = UiSchema & { 'ui:groups'?: { title: string; fields: string[] }[] };

export type AssetFileType =
  | 'manifest'
  | 'base'      // A theme's main HTML shell
  | 'template'  // A generic template (used by all Layouts)
  | 'partial'
  | 'stylesheet'
  | 'script'
  | 'asset';

export interface AssetFile {
  path: string;
  type: AssetFileType;
  name?: string; // User-friendly name for UI selectors
}

/** The base properties shared by all asset manifests. */
export interface BaseAssetManifest {
  name: string;
  version: string;
  description?: string;
  icon?: string;
  files: AssetFile[];
}

/** The structure of a theme.json file. */
export interface ThemeManifest extends BaseAssetManifest {
  appearanceSchema?: RJSFSchema;
}

/** The structure of a layout.json file. */
export interface LayoutManifest extends BaseAssetManifest {
  id: string;
  // Use the new, clearer layout types
  layoutType: 'page' | 'list' | 'item';
  schema?: RJSFSchema; // Optional schema for a layout's own settings.
  uiSchema?: StrictUiSchema;
}

// SiteDataForAssets no longer needs `viewFiles`
export type SiteDataForAssets = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;

// --- Helper Functions ---

const fileContentCache = new Map<string, Promise<string | null>>();

const isCoreTheme = (path: string) => CORE_THEMES.some((t: ThemeInfo) => t.path === path);
const isCoreLayout = (path: string) => CORE_LAYOUTS.some((l: LayoutInfo) => l.path === path);

/**
 * Provides a base schema for all content, ensuring common fields are available.
 * @returns An object containing the base RJSFSchema and UiSchema.
 */
function getBaseSchema(): { schema: RJSFSchema, uiSchema: UiSchema } {
    return BASE_SCHEMA;
}

/**
 * Fetches the raw string content of a theme or layout asset.
 * It intelligently fetches from either the `/public` directory (for core assets)
 * or the `LocalSiteData` object (for user-provided custom assets), with caching.
 */
export async function getAssetContent(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<string | null> {
    const isCore = assetType === 'theme' ? isCoreTheme(path) : isCoreLayout(path);
    const sourcePath = `/${assetType}s/${path}/${fileName}`;

    if (isCore) {
      if (fileContentCache.has(sourcePath)) {
        return fileContentCache.get(sourcePath)!;
      }
      const promise = fetch(sourcePath)
        .then(res => res.ok ? res.text() : null)
        .catch(() => null);
      fileContentCache.set(sourcePath, promise);
      return promise;
    } else {
      const fileStore: RawFile[] | undefined =
          assetType === 'theme' ? siteData.themeFiles
          : assetType === 'layout' ? siteData.layoutFiles
          : undefined;

      const fullPath = `${assetType}s/${path}/${fileName}`;
      return fileStore?.find(f => f.path === fullPath)?.content ?? null;
    }
}

/**
 * A generic function to fetch and parse any JSON asset manifest (theme, layout).
 */
export async function getJsonAsset<T>(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<T | null> {
    const content = await getAssetContent(siteData, assetType, path, fileName);
    if (!content) return null;
    try {
      return JSON.parse(content) as T;
    } catch (e) {
      console.error(`Failed to parse JSON from ${assetType}/${path}/${fileName}:`, e);
      return null;
    }
}

/**
 * Merges a layout's specific schema with the universal base schema.
 */
function mergeSchemas(base: RJSFSchema, specific?: RJSFSchema): RJSFSchema {
    if (!specific) return { ...base };
    return {
        ...base,
        ...specific,
        properties: { ...(base.properties || {}), ...(specific.properties || {}) },
        required: [...new Set([...(base.required || []), ...(specific.required || [])])]
    };
}

// --- Public API ---

/**
 * Gets a list of all available themes (core and custom).
 */
export function getAvailableThemes(manifest?: Manifest): ThemeInfo[] {
  const available = [...CORE_THEMES];
  if (manifest?.themes) {
    const customThemes = manifest.themes.filter(ct => !available.some(coreT => coreT.path === ct.path));
    available.push(...customThemes);
  }
  return available;
}

/**
 * Fetches and processes the manifest for a specific layout, merging its
 * schema with the base content schema.
 */
export async function getLayoutManifest(siteData: SiteDataForAssets, layoutPath: string): Promise<LayoutManifest | null> {
    const layoutManifest = await getJsonAsset<LayoutManifest>(siteData, 'layout', layoutPath, 'layout.json');
    const baseSchemaData = getBaseSchema();

    if (!layoutManifest) {
      // Fallback for a missing layout.json.
      return {
          id: layoutPath, // Satisfy the required 'id' property
          name: layoutPath,
          version: '1.0.0',
          layoutType: 'page', // Default to 'page' type
          files: [],
          schema: baseSchemaData.schema,
          uiSchema: baseSchemaData.uiSchema,
      }
    }

    // Merge the layout's schema and uiSchema with the base schemas.
    layoutManifest.schema = mergeSchemas(baseSchemaData.schema, layoutManifest.schema);
    layoutManifest.uiSchema = { ...baseSchemaData.uiSchema, ...(layoutManifest.uiSchema || {}) };

    // Clean up properties that are handled by dedicated UI fields, not the generic form.
    if (layoutManifest.schema?.properties) {
      delete layoutManifest.schema.properties.title;
      delete layoutManifest.schema.properties.description;
      delete layoutManifest.schema.properties.slug;
    }

    return { ...layoutManifest, id: layoutPath };
}

/**
 * Gets a list of the full manifest objects for all available layouts,
 * optionally filtered by a specific layout type.
 */
export async function getAvailableLayouts(
  siteData: SiteDataForAssets,
  type?: LayoutManifest['layoutType']
): Promise<LayoutManifest[]> {
  const coreLayoutIds = CORE_LAYOUTS.map(l => l.id);
  const customLayoutIds = siteData.manifest.layouts?.map(l => l.id) || [];
  const allLayoutIds = [...new Set([...coreLayoutIds, ...customLayoutIds])];

  const manifestPromises = allLayoutIds.map(layoutId =>
    getLayoutManifest(siteData, layoutId)
  );

  const allManifests = (await Promise.all(manifestPromises))
    .filter((m): m is LayoutManifest => m !== null);

  if (type) {
    return allManifests.filter(m => m.layoutType === type);
  }

  return allManifests;
}

================================================================================

File: core/services/siteExporter.service.ts
// src/core/services/siteExporter.service.ts
import JSZip from 'jszip';
import { LocalSiteData, ParsedMarkdownFile, StructureNode } from '@/types';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { flattenStructureToRenderableNodes } from './fileTree.service';
import { resolvePageContent } from './pageResolver.service';
import { PageType } from '@/types';
import { render } from './theme-engine/themeEngine.service';
import { getUrlForNode } from './urlUtils.service';
import { getAssetContent, getJsonAsset, ThemeManifest, LayoutManifest } from './configHelpers.service';

/**
 * Escapes special XML characters in a string to make it safe for RSS/Sitemap feeds.
 */
function escapeForXml(str: unknown): string {
    if (str === undefined || str === null) return '';
    return String(str)
        .replace(/&/g, '&')
        .replace(/</g, '<')
        .replace(/>/g, '>')
        .replace(/"/g, '"')
        .replace(/'/g, "'");
}

/**
 * A helper function to find all files for a given asset (theme or layout)
 * and add them to the ZIP archive.
 */
async function bundleAsset(zip: JSZip, siteData: LocalSiteData, assetType: 'theme' | 'layout', assetId: string) {
    // The asset folder path is now simpler, e.g., _signum/layouts/page/
    const assetFolder = zip.folder('_signum')?.folder(`${assetType}s`)?.folder(assetId);
    if (!assetFolder) return;

    // Use the asset's ID to fetch its manifest.
    const manifest = await getJsonAsset<ThemeManifest | LayoutManifest>(siteData, assetType, assetId, 'layout.json');

    if (!manifest || !manifest.files) {
        console.warn(`Asset manifest for ${assetType}/${assetId} is missing or has no 'files' array. Skipping bundle.`);
        return;
    }

    for (const file of manifest.files) {
        const content = await getAssetContent(siteData, assetType, assetId, file.path);
        if (content) {
            assetFolder.file(file.path, content);
        } else {
            console.warn(`Could not find content for declared file: ${assetType}s/${assetId}/${file.path}`);
        }
    }
}


/**
 * Compiles a full Signum site into a downloadable ZIP archive, ready for deployment.
 */
export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
    const zip = new JSZip();
    const { manifest, contentFiles } = siteData;
    if (!contentFiles) {
        throw new Error("Cannot export site: content files are not loaded.");
    }
    const allRenderableNodes = flattenStructureToRenderableNodes(manifest.structure);

    // --- 1. Generate All HTML Pages ---
    for (const node of allRenderableNodes) {
        const initialResolution = resolvePageContent(siteData, node.slug.split('/'));

        if (initialResolution.type === PageType.NotFound) continue;

        const isPaginated = !!(initialResolution.pagination && initialResolution.pagination.totalPages > 1);

        if (isPaginated) {
            const totalPages = initialResolution.pagination!.totalPages;
            for (let i = 1; i <= totalPages; i++) {
                const pageNumber = i;
                const resolutionForPage = resolvePageContent(siteData, node.slug.split('/'), pageNumber);

                if (resolutionForPage.type === PageType.NotFound) continue;

                const outputPath = getUrlForNode(node, true, pageNumber);
                const depth = (outputPath.match(/\//g) || []).length;
                const relativePrefix = '../'.repeat(depth > 0 ? depth - 1 : 0);

                const finalHtml = await render(siteData, resolutionForPage, {
                    siteRootPath: '/',
                    isExport: true,
                    relativeAssetPath: relativePrefix
                });
                zip.file(outputPath, finalHtml);
            }
        } else {
            const outputPath = getUrlForNode(node, true);
            const depth = (outputPath.match(/\//g) || []).length;
            const relativePrefix = '../'.repeat(depth > 0 ? depth - 1 : 0);

            const finalHtml = await render(siteData, initialResolution, {
                siteRootPath: '/',
                isExport: true,
                relativeAssetPath: relativePrefix
            });
            zip.file(outputPath, finalHtml);
        }
    }

    // --- 2. Add _signum Source Content and Asset Files ---
    const signumFolder = zip.folder('_signum');
    if (signumFolder) {
        signumFolder.file('manifest.json', JSON.stringify(manifest, null, 2));
        contentFiles.forEach(file => {
            signumFolder.file(file.path, stringifyToMarkdown(file.frontmatter, file.content));
        });
    }

    // --- THIS IS THE FIX: Gather ALL used layouts from frontmatter ---
    const layoutIds = new Set<string>();
    contentFiles.forEach(file => {
        // Add the main page layout
        if (file.frontmatter.layout) {
            layoutIds.add(file.frontmatter.layout);
        }
        // If it's a collection page, add its item layout
        if (file.frontmatter.collection) {
            // The line trying to access list_layout is REMOVED.
            layoutIds.add(file.frontmatter.collection.item_layout);
        }
    });

    const uniqueLayoutIds = [...layoutIds];
    // --- END OF FIX ---

    const activeThemeId = manifest.theme.name;
    await bundleAsset(zip, siteData, 'theme', activeThemeId);

    // Bundle all the unique layouts that were found
    for (const layoutId of uniqueLayoutIds) {
        await bundleAsset(zip, siteData, 'layout', layoutId);
    }

    // --- 3. Generate RSS Feed and Sitemap ---
    const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
    type RssItemData = { node: StructureNode, file: ParsedMarkdownFile };

    // Exclude collection pages from RSS items
    const rssItems = allRenderableNodes
        .map((node): RssItemData | null => {
            const file = contentFiles.find(f => f.path === node.path);
            return file ? { node, file } : null;
        })
        .filter((item): item is RssItemData =>
            item !== null &&
            !!item.file.frontmatter.date &&
            !item.file.frontmatter.collection // <-- This is the key filter
        )
        .sort((a, b) => new Date(b.file.frontmatter.date as string).getTime() - new Date(a.file.frontmatter.date as string).getTime())
        .slice(0, 20)
        .map((item) => {
            const relativeUrl = getUrlForNode(item.node, false); // Use non-export URL for feed
            const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
            const description = escapeForXml(item.file.frontmatter.description);
            const pubDate = new Date(item.file.frontmatter.date as string).toUTCString();
            return `<item><title>${escapeForXml(item.node.title)}</title><link>${escapeForXml(absoluteUrl)}</link><guid isPermaLink="true">${escapeForXml(absoluteUrl)}</guid><pubDate>${pubDate}</pubDate><description>${description}</description></item>`;
        }).join('');

    const rssFeed = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(manifest.title)}</title><link>${siteBaseUrl}</link><description>${escapeForXml(manifest.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrl).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;
    zip.file('rss.xml', rssFeed);

    const sitemapUrls = allRenderableNodes.map((node) => {
        const file = contentFiles.find(f => f.path === node.path);
        const relativeUrl = getUrlForNode(node, false); // Use non-export URL
        const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
        const lastMod = (file?.frontmatter.date as string || new Date().toISOString()).split('T')[0];
        return `<url><loc>${escapeForXml(absoluteUrl)}</loc><lastmod>${lastMod}</lastmod></url>`;
    }).join('');

    const sitemapXml = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
    zip.file('sitemap.xml', sitemapXml);

    // --- 4. Generate the Final ZIP file ---
    return zip.generateAsync({ type: 'blob' });
}

================================================================================

File: core/services/urlUtils.service.ts
// src/core/services/urlUtils.service.ts

/**
 * Generates a URL for a given site node, correctly handling index cases,
 * static export paths, and pagination routes.
 *
 * @param node - An object representing a node in the site structure.
 * @param isExport - A boolean indicating if the URL is for a static export.
 * @param pageNumber - Optional page number for generating paginated links.
 * @returns A string representing the URL segment or full filename.
 */
export function getUrlForNode(
  node: { slug: string; path: string },
  isExport: boolean,
  pageNumber?: number,
): string {
  // --- THIS IS THE KEY CHECK ---
  // A page is the true root index if its path is exactly 'content/index.md'.
  const isRootIndex = node.path === 'content/index.md';

  if (isExport) {
    // --- EXPORT PATHS ---

    // Handle the root index as a special case for export. It's the only file in the root.
    if (isRootIndex) {
      return 'index.html';
    }

    // For all other pages, use the full slug which represents the directory structure.
    const baseName = node.slug;

    if (pageNumber && pageNumber > 1) {
      // For paginated routes, e.g., /blog/page/2/index.html
      return `${baseName}/page/${pageNumber}/index.html`;
    }

    // All other pages go into a directory with an index.html file for clean URLs.
    // e.g., 'about-us' becomes '/about-us/index.html'
    // e.g., 'blog/my-post' becomes '/blog/my-post/index.html'
    return `${baseName}/index.html`;
  }

  // --- LIVE PREVIEW PATH SEGMENTS ---
  if (pageNumber && pageNumber > 1) {
    return `${node.slug}/page/${pageNumber}`;
  }

  // For the live preview, the root URL is just '/' (empty string)
  if (isRootIndex) {
    return '';
  }

  // For all other pages, the URL segment is simply its full slug.
  return node.slug;
}

================================================================================

File: core/services/relativePaths.service.ts
// src/lib/pathUtils.ts

/**
 * Calculates the relative path from one file to another.
 * This is essential for creating portable HTML that works on any server
 * or directly from the local file system.
 *
 * @example
 * // from 'index.html' to 'about.html' -> './about.html'
 * getRelativePath('index.html', 'about.html');
 *
 * @example
 * // from 'posts/post1.html' to 'index.html' -> '../index.html'
 * getRelativePath('posts/post1.html', 'index.html');
 *
 * @example
 * // from 'posts/post1.html' to 'tags/tech.html' -> '../tags/tech.html'
 * getRelativePath('posts/post1.html', 'tags/tech.html');
 *
 * @param {string} fromPath - The path of the file containing the link.
 * @param {string} toPath - The path of the file being linked to.
 * @returns {string} The calculated relative path.
 */
export function getRelativePath(fromPath: string, toPath: string): string {
  if (fromPath === toPath) {
    return toPath.split('/').pop() || '';
  }

  const fromParts = fromPath.split('/').slice(0, -1); // Path without filename
  const toParts = toPath.split('/');

  // Find the common path segment
  let commonLength = 0;
  while (
    commonLength < fromParts.length &&
    commonLength < toParts.length &&
    fromParts[commonLength] === toParts[commonLength]
  ) {
    commonLength++;
  }

  const upLevels = fromParts.length - commonLength;
  const upPath = '../'.repeat(upLevels) || './';

  const downPath = toParts.slice(commonLength).join('/');

  return upPath + downPath;
}

================================================================================

File: core/services/localFileSystem.service.ts
// src/lib/localSiteFs.ts
import { LocalSiteData, Manifest, ParsedMarkdownFile, RawFile } from '@/types'; // Ensure RawFile is imported
import localforage from 'localforage';
import { stringifyToMarkdown, parseMarkdownString } from '@/lib/markdownParser';

const DB_NAME = 'SignumDB';

const siteManifestsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteManifests',
});

const siteContentFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteContentFiles',
});

const siteLayoutFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteLayoutFiles',
});

const siteThemeFilesStore = localforage.createInstance({
    name: DB_NAME,
    storeName: 'siteThemeFiles',
});

// --- Function to load only manifests for a fast initial load ---
export async function loadAllSiteManifests(): Promise<Manifest[]> {
  const manifests: Manifest[] = [];
  await siteManifestsStore.iterate((value: Manifest) => {
    manifests.push(value);
  });
  return manifests;
}

/**
 * Fetches the manifest for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<Manifest | null>} A Promise that resolves to the Manifest object, or null if not found.
 */
export async function getManifestById(siteId: string): Promise<Manifest | null> {
  const manifest = await siteManifestsStore.getItem<Manifest>(siteId);
  return manifest ?? null;
}

/**
 * Fetches the content files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<ParsedMarkdownFile[]>} A Promise that resolves to an array of parsed markdown files.
 */
export async function getSiteContentFiles(siteId: string): Promise<ParsedMarkdownFile[]> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId);
    return contentFiles ?? [];
}

/**
 * Fetches the custom layout files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw layout files.
 */
export async function getSiteLayoutFiles(siteId: string): Promise<RawFile[]> {
    const layoutFiles = await siteLayoutFilesStore.getItem<RawFile[]>(siteId);
    return layoutFiles ?? [];
}

/**
 * Fetches the custom theme files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw theme files.
 */
export async function getSiteThemeFiles(siteId: string): Promise<RawFile[]> {
    const themeFiles = await siteThemeFilesStore.getItem<RawFile[]>(siteId);
    return themeFiles ?? [];
}

export async function saveSite(siteData: LocalSiteData): Promise<void> {
  await Promise.all([
    siteManifestsStore.setItem(siteData.siteId, siteData.manifest),
    siteContentFilesStore.setItem(siteData.siteId, siteData.contentFiles ?? []),
    siteLayoutFilesStore.setItem(siteData.siteId, siteData.layoutFiles ?? []),
    siteThemeFilesStore.setItem(siteData.siteId, siteData.themeFiles ?? []),
  ]);
}

export async function deleteSite(siteId: string): Promise<void> {
  await Promise.all([
    siteManifestsStore.removeItem(siteId),
    siteContentFilesStore.removeItem(siteId),
    siteLayoutFilesStore.removeItem(siteId),
    siteThemeFilesStore.removeItem(siteId),
  ]);
}

export async function saveManifest(siteId: string, manifest: Manifest): Promise<void> {
    await siteManifestsStore.setItem(siteId, manifest);
}

export async function saveContentFile(siteId: string, filePath: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];

    const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
    const fileSlug = filePath.replace(/^content\//, '').replace(/\.md$/, '');
    const savedFile: ParsedMarkdownFile = { slug: fileSlug, path: filePath, frontmatter, content };

    const fileIndex = contentFiles.findIndex(f => f.path === filePath);
    if (fileIndex > -1) {
      contentFiles[fileIndex] = savedFile;
    } else {
      contentFiles.push(savedFile);
    }

    await siteContentFilesStore.setItem(siteId, contentFiles);
    return savedFile;
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const updatedContentFiles = contentFiles.filter(f => f.path !== filePath);
    await siteContentFilesStore.setItem(siteId, updatedContentFiles);
}

export async function getContentFileRaw(siteId: string, filePath: string): Promise<string | null> {
    const allFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const fileData = allFiles.find(f => f.path === filePath);
    if (!fileData) return null;
    
    return stringifyToMarkdown(fileData.frontmatter, fileData.content);
}

/**
 * Moves a set of content files from old paths to new paths in a single transaction.
 * @param {string} siteId - The ID of the site.
 * @param {{oldPath: string, newPath: string}[]} pathsToMove - An array of path mapping objects.
 * @returns {Promise<void>}
 */
export async function moveContentFiles(siteId: string, pathsToMove: { oldPath: string, newPath: string }[]): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    
    const updatedFiles = contentFiles.map(file => {
        const moveInstruction = pathsToMove.find(p => p.oldPath === file.path);
        if (moveInstruction) {
            const newSlug = moveInstruction.newPath.split('/').pop()?.replace('.md', '') || '';
            return { ...file, path: moveInstruction.newPath, slug: newSlug };
        }
        return file;
    });
    
    await siteContentFilesStore.setItem(siteId, updatedFiles);
}

================================================================================

File: core/services/navigationStructure.service.ts
// src/core/services/navigationStructureService.ts

import { LocalSiteData, NavLinkItem, StructureNode } from '@/types';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { getRelativePath } from '@/core/services/relativePaths.service';
import { RenderOptions } from '@/core/services/theme-engine/themeEngine.service';

/**
 * Recursively builds a navigation link structure with context-aware paths.
 * @param nodes - The site structure nodes to build links from.
 * @param currentPagePath - The path of the page being currently rendered.
 * @param options - The render options, containing isExport and siteRootPath.
 * @returns An array of navigation link objects.
 */
function buildNavLinks(nodes: StructureNode[], currentPagePath: string, options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>): NavLinkItem[] {
  return nodes
    .filter(node => node.type === 'page' && node.navOrder !== undefined)
    .sort((a, b) => (a.navOrder || 0) - (b.navOrder || 0))
    .map(node => {
      let href: string;
      const urlSegment = getUrlForNode(node, options.isExport);

      if (options.isExport) {
        href = getRelativePath(currentPagePath, urlSegment);
      } else {
        href = `${options.siteRootPath}${urlSegment ? `/${urlSegment}` : ''}`.replace(/\/$/, '') || '/';
      }

      // --- NEW: Recursive call for children ---
      const children = (node.children && node.children.length > 0)
        ? buildNavLinks(node.children, currentPagePath, options)
        : [];

      return {
        href: href,
        label: node.title,
        children: children,
      };
    });
}

/**
 * Generates the complete navigation structure for a given page.
 */
export function generateNavLinks(
  siteData: LocalSiteData,
  currentPagePath: string,
  options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  const { structure } = siteData.manifest;
  return buildNavLinks(structure, currentPagePath, options);
}

================================================================================

File: core/services/pageResolver.service.ts
// src/core/services/pageResolver.service.ts

import {
    LocalSiteData,
    ParsedMarkdownFile,
    CollectionConfig,
    PaginationData,
    PageResolutionResult,
    PageType,
    StructureNode,
} from '@/types';
import { findNodeByPath, findChildNodes } from './fileTree.service';
import { getUrlForNode } from './urlUtils.service';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

/**
 * Executes a declarative query for a Collection Page.
 * This pure function takes the config and site data, finds all child pages
 * in the structure, fetches their content, and returns a fully sorted array.
 * Pagination is handled by the main resolver.
 *
 * @param {CollectionConfig} collectionConfig - The configuration object from the page's frontmatter.
 * @param {StructureNode} collectionNode - The structure node for the Collection Page itself.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @returns {ParsedMarkdownFile[]} A sorted array of all content files that are children of the collection page.
 */
function executeCollectionQuery(
    collectionConfig: CollectionConfig,
    collectionNode: StructureNode,
    siteData: LocalSiteData,
): ParsedMarkdownFile[] {
    if (!siteData.contentFiles) {
        return [];
    }

    // Find all direct child nodes of the collection page in the site's structure.
    const childNodes = findChildNodes(siteData.manifest.structure, collectionNode.path);
    const childPaths = new Set(childNodes.map(child => child.path));

    // Filter the site's content files to get only the ones that are children.
    const items = siteData.contentFiles.filter(file => childPaths.has(file.path));

    // --- Sorting Logic ---
    const sortBy = collectionConfig.sort_by || 'date';
    const sortOrder = collectionConfig.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    // Create a copy of the array before sorting to avoid mutating the original.
    return [...items].sort((a, b) => {
        const valA = a.frontmatter[sortBy];
        const valB = b.frontmatter[sortBy];

        if (sortBy === 'date' && valA && valB) {
            const dateA = new Date(valA as string).getTime();
            const dateB = new Date(valB as string).getTime();
            if (isNaN(dateA) || isNaN(dateB)) return 0;
            return (dateA - dateB) * orderModifier;
        }

        if (typeof valA === 'string' && typeof valB === 'string') {
            return valA.localeCompare(valB) * orderModifier;
        }

        if (typeof valA === 'number' && typeof valB === 'number') {
            return (valA - valB) * orderModifier;
        }
        return 0;
    });
}

/**
 * Finds the correct page to render based on a URL slug path.
 * If the page is a Collection Page, this function executes the query, handles pagination,
 * and attaches the results to the final resolution object.
 *
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {string[]} slugArray - The URL segments used for path matching.
 * @param {number} [pageNumber=1] - The current page number for pagination.
 * @returns {PageResolutionResult} An object containing all data needed to render the page or a not-found error.
 */
export function resolvePageContent(
    siteData: LocalSiteData,
    slugArray: string[],
    pageNumber: number = 1,
): PageResolutionResult {
    const pathSuffix = slugArray.length > 0 ? slugArray.join('/') : 'index';
    const potentialPagePath = `content/${pathSuffix}.md`;

    const targetNode = findNodeByPath(siteData.manifest.structure, potentialPagePath);

    if (!targetNode) {
        return {
            type: PageType.NotFound,
            errorMessage: `No page found at the path: /${slugArray.join('/')}`,
        };
    }

    const contentFile = siteData.contentFiles?.find(f => f.path === targetNode.path);
    if (!contentFile) {
        return {
            type: PageType.NotFound,
            errorMessage: `Manifest references "${targetNode.path}" but its content file is missing.`,
        };
    }

    let collectionItems: ParsedMarkdownFile[] | undefined = undefined;
    let pagination: PaginationData | undefined = undefined;

    const collectionConfig = contentFile.frontmatter.collection;
    if (collectionConfig) {
        const allItems = executeCollectionQuery(collectionConfig, targetNode, siteData);
        const itemsPerPage = collectionConfig.items_per_page;

        if (itemsPerPage && itemsPerPage > 0) {
            // Handle pagination if configured
            const totalItems = allItems.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const currentPage = Math.max(1, Math.min(pageNumber, totalPages));

            const startIndex = (currentPage - 1) * itemsPerPage;
            collectionItems = allItems.slice(startIndex, startIndex + itemsPerPage);

            const pageUrlSegment = getUrlForNode(targetNode, false);
            const baseUrl = pageUrlSegment ? `/${pageUrlSegment}` : '/';

            pagination = {
                currentPage,
                totalPages,
                totalItems,
                hasPrevPage: currentPage > 1,
                hasNextPage: currentPage < totalPages,
                prevPageUrl: currentPage > 1 ? `${baseUrl}?page=${currentPage - 1}` : undefined,
                nextPageUrl: currentPage < totalPages ? `${baseUrl}?page=${currentPage + 1}` : undefined,
            };
        } else {
            // If no pagination, just return all items
            collectionItems = allItems;
        }
    }

    // The result object has been renamed for clarity ('viewItems' -> 'collectionItems')
    return {
        type: PageType.SinglePage,
        pageTitle: contentFile.frontmatter.title,
        contentFile: contentFile,
        layoutPath: contentFile.frontmatter.layout || DEFAULT_PAGE_LAYOUT_PATH,
        collectionItems: collectionItems,
        pagination: pagination,
    };
}

================================================================================

File: core/services/fileTree.service.ts
// src/core/services/fileTree.service.ts

import { StructureNode } from '@/types';

/**
 * Finds a node in a structure tree by its exact `path`.
 * @param nodes The array of nodes to search within.
 * @param path The path of the node to find (e.g., "content/blog/first-post.md").
 * @returns The found StructureNode or undefined.
 */
export function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) {
      return node;
    }
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) {
        return found;
      }
    }
  }
  return undefined;
}

/**
 * Recursively traverses the structure tree and collects all nodes that are pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all page-type StructureNodes.
 */
export function flattenStructureToPages(nodes: StructureNode[]): StructureNode[] {
  let pages: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page') {
      pages.push(node);
    }
    if (node.children) {
      pages = pages.concat(flattenStructureToPages(node.children));
    }
  }
  return pages;
}

/**
 * Recursively traverses the structure tree and collects all nodes that can be rendered as a page.
 * This includes single pages AND collection listing pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all renderable StructureNodes.
 */
export function flattenStructureToRenderableNodes(nodes: StructureNode[]): StructureNode[] {
  let renderableNodes: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page' || node.type === 'collection') {
      renderableNodes.push(node);
    }
    if (node.children) {
      renderableNodes = renderableNodes.concat(flattenStructureToRenderableNodes(node.children));
    }
  }
  return renderableNodes;
}

/**
 * Gets the parent directory path for a given file path.
 * e.g., "content/blog/post.md" -> "content/blog"
 * @param path The full path of a file or folder.
 * @returns The path of the parent directory.
 */
export function getParentPath(path: string): string {
  if (!path.includes('/')) return 'content';
  return path.substring(0, path.lastIndexOf('/'));
}

/**
 * Finds a node by its path and removes it from a tree structure, returning both the found node and the modified tree.
 * This is a pure function; it does not mutate the original array.
 * @param {StructureNode[]} nodes - The array of nodes to search.
 * @param {string} path - The path of the node to remove.
 * @returns An object containing the found node and the updated tree.
 */
export function findAndRemoveNode(nodes: StructureNode[], path: string): { found: StructureNode | null, tree: StructureNode[] } {
  let found: StructureNode | null = null;
  
  const filterRecursively = (currentNodes: StructureNode[]): StructureNode[] => {
    const result: StructureNode[] = [];
    for (const node of currentNodes) {
      if (node.path === path) {
        found = node;
        continue; // Skip adding it to the result, effectively removing it
      }
      if (node.children) {
        const newChildren = filterRecursively(node.children);
        result.push({ ...node, children: newChildren });
      } else {
        result.push(node);
      }
    }
    return result;
  };

  const newTree = filterRecursively(nodes);
  return { found, tree: newTree };
}


/**
 * Recursively updates the path of a node and all of its descendants based on a new parent path.
 * @param {StructureNode} node - The node to start from.
 * @param {string} newParentPath - The new parent path segment (e.g., 'content/about').
 * @returns {StructureNode} The node with all paths and slugs updated.
 */
export function updatePathsRecursively(node: StructureNode, newParentPath: string): StructureNode {
  // Get the last part of the old path to append to the new parent path.
  const oldFileName = node.path.substring(node.path.lastIndexOf('/'));
  const newPath = `${newParentPath}${oldFileName}`;

  // The new slug is the new path, minus the 'content/' prefix and '.md' extension.
  const newSlug = newPath.replace(/^content\//, '').replace(/\.md$/, '');

  const updatedNode: StructureNode = { ...node, path: newPath, slug: newSlug };

  if (updatedNode.children) {
    // The new parent path for the children is the updated node's path, without the '.md' extension.
    const newChildsParentPath = newPath.replace(/\.md$/, '');
    updatedNode.children = updatedNode.children.map(child =>
      updatePathsRecursively(child, newChildsParentPath)
    );
  }

  return updatedNode;
}

/**
 * Finds all direct child nodes of a given parent node path.
 * @param nodes The entire site structure array.
 * @param parentPath The path of the parent node whose children are to be found.
 * @returns An array of StructureNodes that are children of the parent.
 */
export function findChildNodes(nodes: StructureNode[], parentPath: string): StructureNode[] {
    const parentNode = findNodeByPath(nodes, parentPath);
    return parentNode?.children || [];
}

================================================================================

File: core/services/images/images.service.ts
import { ImageService } from './types';
import { localImageService } from './localImages.service';
import { cloudinaryImageService } from './cloudinaryImages.service';

// A registry of all available image services.
const services: Record<string, ImageService> = {
  local: localImageService,
  cloudinary: cloudinaryImageService,
};

/**
 * Retrieves the currently active image service based on the site's configuration.
 * Defaults to the local service if no configuration is found.
 * @param siteManifest The site's manifest, which should contain the image service choice.
 * @returns The active ImageService instance.
 */
export function getActiveImageService(siteManifest: Manifest): ImageService {
  // In the future, the manifest will have a property like:
  // "imageService": "cloudinary"
  const serviceId = siteManifest.settings?.imageServiceId || 'local';
  return services[serviceId] || localImageService;
}

================================================================================

File: core/services/images/types.ts
export interface ImageRef {
  serviceId: 'local' | 'cloudinary';
  // The 'src' is ALWAYS the path to the single, high-resolution source image.
  // For local, it's 'assets/images/my-photo.jpg'.
  // For Cloudinary, it's 'https://.../my-photo.jpg'.
  src: string;
  alt?: string;
  width?: number; // Original width
  height?: number; // Original height
}

export interface ImageService {
  id: string;
  name: string;
  // Upload now only handles one file and returns a simple reference.
  upload(file: File, siteId: string): Promise<ImageRef>;
  // We need a way to get the raw data for the source image for local processing.
  getSourceData(src: string, siteId: string): Promise<string>; // Returns Base64/Blob URL
}

================================================================================

File: core/services/images/cloudinaryImages.service.ts
import { ImageService, ImageRef } from './types';

// This is a placeholder for the Cloudinary Upload Widget.
// You would import it from the library you choose.
declare const cloudinaryWidget: {
  open: (options: any, callback: (error: any, result: any) => void) => void;
};

class CloudinaryImageService implements ImageService {
  id = 'cloudinary';
  name = 'Upload to Cloudinary';

  upload(file: File, siteId: string): Promise<ImageRef> {
    // The Cloudinary widget handles the upload UI itself.
    // We wrap its callback in a Promise for a modern async/await workflow.
    return new Promise((resolve, reject) => {
      // This is a conceptual example. The actual options would depend on the widget.
      const options = {
        cloudName: 'YOUR_CLOUD_NAME', // These would come from user settings
        uploadPreset: 'YOUR_UNSIGNED_PRESET',
        sources: ['local', 'url'],
        multiple: false,
      };

      cloudinaryWidget.open(options, (error, result) => {
        if (error) {
          return reject(error);
        }
        // The widget returns a result object upon successful upload.
        if (result && result.event === 'success') {
          const info = result.info;
          resolve({
            // The src and previewUrl are the same secure URL from Cloudinary.
            src: info.secure_url,
            previewUrl: info.secure_url,
            alt: info.original_filename,
          });
        }
      });
    });
  }

  async getDisplayUrl(imageRef: ImageRef, siteId: string): Promise<string> {
    // For a CDN, the src is already a public URL. No extra work needed.
    return Promise.resolve(imageRef.src);
  }
}

export const cloudinaryImageService = new CloudinaryImageService();

================================================================================

File: core/services/images/imageCache.service.ts
// A simple in-memory cache for generated derivatives.
// Key: "path/to/image.jpg_w400_h300_cover"
// Value: "data:image/jpeg;base64,..."
const derivativeCache = new Map<string, string>();

export function getCachedDerivative(key: string): string | undefined {
  return derivativeCache.get(key);
}

export function setCachedDerivative(key: string, dataUrl: string) {
  derivativeCache.set(key, dataUrl);
}

================================================================================

File: core/services/images/localImages.service.ts
import { ImageService, ImageRef } from './types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { slugify } from '@/lib/utils';

// Helper to convert a File to a Base64 string
const toBase64 = (file: File): Promise<string> =>
  new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = (error) => reject(error);
  });

class LocalImageService implements ImageService {
  id = 'local';
  name = 'Store in Site Bundle';

  async upload(file: File, siteId: string): Promise<ImageRef> {
    const base64String = await toBase64(file);
    const fileName = `${Date.now()}-${slugify(file.name)}`;
    const relativePath = `assets/images/${fileName}`;

    // We need a new function in our file system service to save image assets.
    await localSiteFs.saveImageAsset(siteId, relativePath, base64String);

    return {
      src: relativePath, // The src stored in frontmatter is the relative path.
      previewUrl: base64String, // For immediate preview, we can use the base64 string.
      alt: file.name,
    };
  }

  async getDisplayUrl(imageRef: ImageRef, siteId: string): Promise<string> {
    // In the editor, we need to load the Base64 data from storage to show the preview.
    const base64String = await localSiteFs.getImageAsset(siteId, imageRef.src);
    return base64String || ''; // Return the data URL or an empty string.
  }
}

export const localImageService = new LocalImageService();

================================================================================

File: core/services/theme-engine/themeEngine.service.ts
// src/core/services/theme-engine/themeEngine.service.ts
import Handlebars from 'handlebars';
import {
    LocalSiteData,
    PageResolutionResult,
    PageType,
} from '@/types';
import {
    getJsonAsset,
    getAvailableLayouts,
    ThemeManifest,
    AssetFile,
    getAssetContent,
} from '@/core/services/configHelpers.service';
import { coreHelpers } from './helpers';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { generateNavLinks } from '@/core/services/navigationStructure.service';

// --- Type Definitions ---
export interface RenderOptions {
  siteRootPath: string;
  isExport: boolean;
  relativeAssetPath?: string;
}

// --- Helper Registration ---
function registerCoreHelpers(siteData: LocalSiteData) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((Handlebars as any)._helpersRegistered) return;

    for (const helperFactory of coreHelpers) {
        const helperMap = helperFactory(siteData);
        for (const helperName in helperMap) {
            Handlebars.registerHelper(helperName, helperMap[helperName]);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Handlebars as any)._helpersRegistered = true;
}

/**
 * Pre-compiles and caches all available layout templates and theme partials.
 * This is crucial for performance and allows helpers to synchronously access templates during rendering.
 * @param {LocalSiteData} siteData - The complete site data.
 */
async function cacheAllTemplates(siteData: LocalSiteData) {
    // Clear all existing partials to ensure a clean state
    for (const partial in Handlebars.partials) {
        if (Object.prototype.hasOwnProperty.call(Handlebars.partials, partial)) {
            Handlebars.unregisterPartial(partial);
        }
    }

    const { manifest } = siteData;

    // 1. Get ALL layouts of ALL types (page, list, item).
    const allLayouts = await getAvailableLayouts(siteData);

    // 2. Loop through every layout and register its main template as a partial using its ID.
    const layoutPromises = allLayouts.map(async (layoutManifest) => {
        if (!layoutManifest?.files) return;

        const templateFile = layoutManifest.files.find((f: AssetFile) => f.type === 'template');
        if (templateFile) {
            const templateSource = await getAssetContent(siteData, 'layout', layoutManifest.id, templateFile.path);
            if (templateSource) {
                // Register the partial using the layout's ID (e.g., 'page', 'listing', 'teaser').
                Handlebars.registerPartial(layoutManifest.id, templateSource);
            }
        }
    });

    // 3. Register the theme's global partials (header, footer, head).
    const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', manifest.theme.name, 'theme.json');
    const themePartialPromises = (themeManifest?.files || [])
        .filter((file: AssetFile) => file.type === 'partial' && file.name)
        .map(async (partial) => {
            const templateSource = await getAssetContent(siteData, 'theme', manifest.theme.name, partial.path);
            if (templateSource) {
                Handlebars.registerPartial(partial.name!, templateSource);
            }
        });

    await Promise.all([...layoutPromises, ...themePartialPromises]);
}

/**
 * Renders a resolved page into a full HTML string based on the active theme and assets.
 */
export async function render(siteData: LocalSiteData, resolution: PageResolutionResult, options: RenderOptions): Promise<string> {
  // 1. Setup, Helper Registration, and Template Caching
  registerCoreHelpers(siteData);
  await cacheAllTemplates(siteData);

  if (!siteData.contentFiles) {
    return 'Error: Site content has not been loaded. Cannot render page.';
  }
  if (resolution.type === PageType.NotFound) {
      return `<h1>404 - Not Found</h1><p>${resolution.errorMessage}</p>`;
  }

  const { manifest } = siteData;
  const themePath = manifest.theme.name;
  // This is the ID of the main PAGE layout (e.g., 'page-wide', 'post-full').
  const pageLayoutPath = resolution.layoutPath;

  // 2. Prepare Data for Rendering
  const currentPageExportPath = getUrlForNode(resolution.contentFile, true);
  const navLinks = generateNavLinks(siteData, currentPageExportPath, options);
  const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
  const canonicalUrl = new URL(currentPageExportPath, siteBaseUrl).href;
  const baseUrl = options.isExport ? (options.relativeAssetPath ?? '') : (typeof window !== 'undefined' ? window.location.origin : '');

  let styleOverrides = '';
  if (manifest.theme.config && Object.keys(manifest.theme.config).length > 0) {
      const cssVars = Object.entries(manifest.theme.config).map(([k, v]) => `--${k.replace(/_/g, '-')}: ${v};`).join(' ');
      if (cssVars) {
          styleOverrides = `<style id="signum-theme-overrides">:root { ${cssVars} }</style>`;
      }
  }

  // 3. Render Main Content Body using the specified PAGE layout
  const pageLayoutSource = Handlebars.partials[pageLayoutPath];
  if (!pageLayoutSource) {
      return `<h1>Rendering Error</h1><p>The page layout template with ID '<strong>${pageLayoutPath}</strong>' could not be found. Please check that the layout exists, its type is 'page', and its manifest is correct.</p>`;
  }

  const pageLayoutTemplate = Handlebars.compile(pageLayoutSource);
  // The 'resolution' object contains everything the page layout needs:
  // contentFile, collectionItems, pagination, etc.
  const bodyHtml = pageLayoutTemplate(resolution);

  // 4. Render Final Document Shell
  const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', themePath, 'theme.json');
  const baseTemplatePath = themeManifest?.files.find((f: AssetFile) => f.type === 'base')?.path;
  if (!baseTemplatePath) return 'Error: Active theme is missing a template with type "base".';

  const baseTemplateSource = await getAssetContent(siteData, 'theme', themePath, baseTemplatePath);
  if (!baseTemplateSource) return `Error: Could not load base template source at '${baseTemplatePath}'.`;
  const baseTemplate = Handlebars.compile(baseTemplateSource);

  const headContext = {
      pageTitle: resolution.pageTitle,
      manifest: manifest,
      contentFile: resolution.contentFile,
      canonicalUrl: canonicalUrl,
      baseUrl: baseUrl,
      styleOverrides: new Handlebars.SafeString(styleOverrides)
  };

  return baseTemplate({
      manifest,
      navLinks,
      year: new Date().getFullYear(),
      headContext: headContext,
      body: new Handlebars.SafeString(bodyHtml),
      ...resolution
  });
}

================================================================================

File: core/services/theme-engine/helpers/strUtil.helper.ts
// src/lib/theme-helpers/strUtil.helper.ts
import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const strUtilHelper: SignumHelper = () => ({
  /**
   * A generic string utility helper for common text manipulations.
   * @example {{str-util some.text op="truncate" len=100}}
   * @example {{str-util some.text op="uppercase"}}
   */
  'str-util': function(input: string, options: HelperOptions): string {
    if (!input || typeof input !== 'string') return '';
  
    const op = options.hash.op;
  
    switch (op) {
      case 'truncate':
        const len = options.hash.len || 140;
        if (input.length <= len) return input;
        return input.substring(0, len) + '…';
      case 'uppercase':
        return input.toUpperCase();
      case 'lowercase':
        return input.toLowerCase();
      default:
        return input;
    }
  }
});

================================================================================

File: core/services/theme-engine/helpers/query.helper.ts
// src/lib/theme-helpers/query.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { PageResolutionResult } from '@/types';

export const queryHelper: SignumHelper = (siteData) => ({
  /**
   * Fetches, filters, and sorts a list of content items from a collection.
   * The resulting array is made available to the inner block of the helper.
   * @param {HelperOptions} options - The Handlebars options object.
   * @returns The rendered block content.
   *
   * @example
   * {{#query source_collection="blog" limit=5 as |posts|}}
   *   {{#each posts}} ... {{/each}}
   * {{/query}}
   */
  query: function(this: PageResolutionResult, options: Handlebars.HelperOptions) {
    const config = options.hash;

    // 1. Validate that a source collection was provided.
    const sourceCollectionSlug = config.source_collection;
    if (!sourceCollectionSlug) {
      console.warn("Query helper called without a 'source_collection'.");
      return options.inverse(this); // Render the {{else}} block if it exists.
    }

    // 2. Find the source collection node in the site's structure.
    const collectionNode = siteData.manifest.structure.find(
        n => n.slug === sourceCollectionSlug
    );
    if (!collectionNode || !collectionNode.children) {
      console.warn(`Query could not find collection with slug: "${sourceCollectionSlug}"`);
      return options.inverse(this);
    }
    
    // 3. Get all content files associated with that collection.
    const childPaths = new Set(collectionNode.children.map(c => c.path));
    let items = (siteData.contentFiles ?? []).filter(f => childPaths.has(f.path));

    // 4. (Future) Apply any filters here.
    // e.g., if (config.filter_by_tag) { ... }

    // 5. Sort the resulting items.
    const sortBy = config.sort_by || 'date';
    const sortOrder = config.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    items.sort((a, b) => {
      const valA = a.frontmatter[sortBy];
      const valB = b.frontmatter[sortBy];

      if (sortBy === 'date') {
        const dateA = valA ? new Date(valA as string).getTime() : 0;
        const dateB = valB ? new Date(valB as string).getTime() : 0;
        if (isNaN(dateA) || isNaN(dateB)) return 0;
        return (dateA - dateB) * orderModifier;
      }
      if (typeof valA === 'string' && typeof valB === 'string') {
        return valA.localeCompare(valB) * orderModifier;
      }
      if (typeof valA === 'number' && typeof valB === 'number') {
        return (valA - valB) * orderModifier;
      }
      return 0;
    });

    // 6. Limit the number of results.
    if (config.limit) {
      const limit = parseInt(config.limit, 10);
      if (!isNaN(limit)) {
        items = items.slice(0, limit);
      }
    }

    // 7. Render the inner block, passing the queried items as a block parameter.
    // This makes the `as |posts|` syntax work.
    if (options.data && options.fn) {
        const data = Handlebars.createFrame(options.data);
        const blockParamName = options.data.blockParams?.[0];
        if (blockParamName) {
            data[blockParamName] = items;
        }
        return options.fn(items, { data });
    }
    
    // Fallback if no block parameter is used.
    return options.fn(items);
  }
});

================================================================================

File: core/services/theme-engine/helpers/markdown.helper.ts
// src/lib/theme-helpers/markdown.helper.ts
import { SignumHelper } from './types';
import Handlebars from 'handlebars';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

export const markdownHelper: SignumHelper = () => ({
  /**
   * Safely renders a string of Markdown into HTML.
   * @example {{{markdown some.body_content}}}
   */
  markdown: function(markdownString: string): Handlebars.SafeString {
    if (!markdownString) return new Handlebars.SafeString('');

    // Use marked to parse, then DOMPurify to sanitize against XSS attacks.
    const unsafeHtml = marked.parse(markdownString, { async: false }) as string;
    const safeHtml = DOMPurify.sanitize(unsafeHtml);

    return new Handlebars.SafeString(safeHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/comparison.helper.ts
// src/lib/theme-helpers/comparison.helper.ts
import { SignumHelper } from './types';

// This code is now valid because SignumHelperFunction accepts a boolean return.
export const comparisonHelpers: SignumHelper = () => ({
  eq: (a, b) => a === b,
  gt: (a, b) => a > b,
  lt: (a, b) => a < b,
});

================================================================================

File: core/services/theme-engine/helpers/getUrl.helper.ts
import { SignumHelper } from './types';
import { getUrlForNode as getUrlUtil } from '@/core/services/urlUtils.service';
import { StructureNode } from '@/types';

export const getUrlHelper: SignumHelper = () => ({
  /**
   * A Handlebars helper to expose the getUrlForNode utility to templates.
   */
  getUrlForNode: function(node: StructureNode, isExport: boolean): string {
    return getUrlUtil(node, isExport);
  }
});

================================================================================

File: core/services/theme-engine/helpers/types.ts
// src/lib/theme-helpers/types.ts
import { LocalSiteData } from '@/types'; // Use the correct path alias to the main types
import Handlebars from 'handlebars'; 

/**
 * Defines the function signature for a Handlebars helper function within Signum.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type SignumHelperFunction = (this: any, ...args: any[]) => string | Handlebars.SafeString | boolean;
/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 * This allows helpers to be data-aware if needed.
 */
export type SignumHelper = (siteData: LocalSiteData) => Record<string, SignumHelperFunction>;

================================================================================

File: core/services/theme-engine/helpers/pager.helper.ts
// src/core/services/theme-engine/helpers/pager.helper.ts

import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { PaginationData } from '@/types';

/**
 * Renders a complete pagination control component.
 * It generates 'Previous' and 'Next' links and a 'Page X of Y' indicator.
 * The links are disabled when not applicable (e.g., on the first or last page).
 * 
 * @param {PaginationData} pagination - The pagination data object from the page resolver.
 * @returns {Handlebars.SafeString} The full HTML for the pager component.
 *
 * @example
 * {{{pager pagination}}}
 */
export const pagerHelper: SignumHelper = () => ({
  pager: function(pagination: PaginationData | undefined): Handlebars.SafeString {
    if (!pagination || pagination.totalPages <= 1) {
      return new Handlebars.SafeString('');
    }

    const prevLink = pagination.hasPrevPage
      ? `<a href="${pagination.prevPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">‹ Previous</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50">‹ Previous</span>`;

    const nextLink = pagination.hasNextPage
      ? `<a href="${pagination.nextPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">Next ›</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50">Next ›</span>`;
    
    const pageIndicator = `<div class="f6 mid-gray">Page ${pagination.currentPage} of ${pagination.totalPages}</div>`;

    const pagerHtml = `
      <div class="flex items-center justify-between mt4 pt3 bt b--black-10">
        <div>${prevLink}</div>
        <div>${pageIndicator}</div>
        <div>${nextLink}</div>
      </div>
    `;

    return new Handlebars.SafeString(pagerHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/assign.helper.ts
import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const assignHelper: SignumHelper = () => ({
  /**
   * A Handlebars helper to add a new property to an object's context.
   * Useful for augmenting data inside a loop.
   * This version uses generics for full type safety.
   *
   * @template T The type of the `this` context.
   * @template K The type of the object being extended.
   * @template V The type of the value being added.
   */
  assign: function<T, K extends object, V>(
    this: T,
    object: K,
    key: string,
    value: V,
    options: HelperOptions,
  ): string {
    // Create a new object by spreading the original and adding the new key-value pair.
    const newContext = { ...object, [key]: value };

    // Execute the inner block of the helper with the new, augmented context.
    return options.fn(newContext);
  },
});

================================================================================

File: core/services/theme-engine/helpers/index.ts
// src/lib/theme-helpers/index.ts
// ... (other helper imports)
import { queryHelper } from './query.helper';
import { comparisonHelpers } from './comparison.helper';
import { renderLayoutForItemHelper } from './renderLayoutForItem.helper';
import { markdownHelper } from './markdown.helper';
import { strUtilHelper } from './strUtil.helper';
import { formatDateHelper } from './formatDate.helper';
import { pagerHelper } from './pager.helper';
import { SignumHelper } from './types';
import { getUrlHelper } from './getUrl.helper';
import { assignHelper } from './assign.helper';


export const coreHelpers: SignumHelper[] = [
  queryHelper,
  strUtilHelper,
  formatDateHelper,
  comparisonHelpers,
  markdownHelper,
  renderLayoutForItemHelper, 
  pagerHelper,
  getUrlHelper,
  assignHelper
];

================================================================================

File: core/services/theme-engine/helpers/formatDate.helper.ts
// src/lib/theme-helpers/formatDate.helper.ts
import { SignumHelper } from './types';

export const formatDateHelper: SignumHelper = () => ({
  /**
   * Formats a date string into a more readable format.
   * @example {{formatDate some.date_string}}
   */
  formatDate: function(dateString: string | Date): string {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    if (isNaN(date.getTime())) {
      return ''; // Return empty for invalid dates
    }

    return date.toLocaleDateString('en-GB', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  }
});

================================================================================

File: core/services/theme-engine/helpers/renderLayoutForItem.helper.ts
// src/core/services/theme-engine/helpers/renderLayoutForItem.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';
// Import the specific types we need
import { ParsedMarkdownFile, PageResolutionResult } from '@/types';
import { HelperOptions } from 'handlebars';

export const renderLayoutForItemHelper: SignumHelper = () => ({
  /**
   * Renders a specific layout for a single content item.
   * This is used inside a view template's `each` loop.
   * @example {{{render_layout_for_item this layout=../contentFile.frontmatter.collection.item_layout}}}
   */
  render_layout_for_item: function(
    // The 'this' context for a helper is typically the top-level data object
    // passed to the template that contains the helper call. PageResolutionResult is a good, safe type.
    this: PageResolutionResult,
    item: ParsedMarkdownFile,
    options: HelperOptions
  ) {
    const layoutId = options.hash.layout;
    if (!item || !layoutId) {
        return '';
    }

    const layoutTemplateSource = Handlebars.partials[layoutId];

    if (layoutTemplateSource) {
        const layoutTemplate = Handlebars.compile(layoutTemplateSource);
        return new Handlebars.SafeString(layoutTemplate(item));
    }

    console.warn(`[render_layout_for_item] Item layout template "${layoutId}" not found.`);
    return `<!-- Item layout "${layoutId}" not found -->`;
  }
});

================================================================================

File: core/services/theme-engine/helpers/image.helper.ts
import { SignumHelper } from './types';
import { ImageRef } from '@/core/services/images/types';
import { getActiveImageService } from '@/core/services/images/images.service';
// You would also import your cache and canvas processing functions here.

export const imageHelper: SignumHelper = (siteData) => ({
  /**
   * Renders a responsive image, handling CDN transformations or on-the-fly
   * local derivative generation and caching.
   * @example {{{image src=frontmatter.image width=400 height=300 fit="cover" alt="Description"}}}
   */
  image: function(options: Handlebars.HelperOptions): string {
    const { src, width, height, fit, alt, lazy = true, class: className = '' } = options.hash;

    if (!src || !(src as ImageRef).serviceId) {
      return '<!-- ImageRef not provided or invalid -->';
    }

    const imageRef = src as ImageRef;
    const imageService = getActiveImageService(siteData.manifest);

    let finalSrc = '';

    if (imageService.id === 'cloudinary') {
      // Construct Cloudinary URL with transformations
      const transforms = `w_${width},h_${height},c_${fit || 'fill'}`;
      finalSrc = imageRef.src.replace('/upload/', `/upload/${transforms}/`);
    } else {
      // --- LOCAL JIT PROCESSING ---
      const cacheKey = `${imageRef.src}_w${width}_h${height}_c${fit}`;
      const cached = getCachedDerivative(cacheKey);

      if (cached) {
        finalSrc = cached;
      } else {
        // This is a placeholder for the actual processing logic.
        // In a real implementation, this would be an async operation.
        // Handlebars helpers are synchronous, which is a CHALLENGE.
        // See "The Synchronous Challenge" below.
        finalSrc = imageRef.src; // Fallback to original for now
        // performCanvasResize(imageRef, {width, height, fit}).then(dataUrl => {
        //   setCachedDerivative(cacheKey, dataUrl);
        //   // But we can't update the UI from here...
        // });
      }
    }

    const lazyAttr = lazy ? 'loading="lazy"' : '';
    return `<img src="${finalSrc}" width="${width}" height="${height}" alt="${alt || ''}" class="${className}" ${lazyAttr}>`;
  }
});

================================================================================

File: app/layout.tsx
// src/app/layout.tsx
'use client'; 

import { useEffect, useState, Suspense } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import './globals.css'; 
import { Toaster } from "@/core/components/ui/sonner"; 
import { ThemeProvider } from "@/core/components/ThemeProvider";
import { useInitialiseUIStore } from '@/core/hooks/useInitialiseUIStore';

function AppLoadingIndicator() {
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading Signum...</p>
      </div>
    </div>
  ); 
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  useInitialiseUIStore();
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true); 
    // Initialize the app state from storage only once
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]); 

  // Show the loading indicator only on the client and before initialization is complete
  const showLoading = clientMounted && !isInitialized;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Signum - Decentralized Publishing</title>
      </head>
      <body className="h-full">
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
          {showLoading ? (
            <AppLoadingIndicator />
          ) : (
         
                <Suspense fallback={<AppLoadingIndicator />}>
                  {children}
                </Suspense>
              
          )}
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================================================================================

File: app/page.tsx
// src/app/page.tsx
'use client';

import { Button } from '@/core/components/ui/button';
import { Link } from '@/core/components/ui/link';
import { ShieldCheck, Feather, Zap, Archive, Leaf } from 'lucide-react';

export default function MarketingHomePage() {
  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto px-4 py-16 sm:py-24 text-center">
      <header className="mb-12">
        <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold tracking-tight text-foreground">
          Signum: Own Your Content.
        </h1>
        <p className="mt-4 max-w-2xl mx-auto text-lg sm:text-xl text-muted-foreground">
          A simple, private, and portable publishing platform that puts you back in control.
        </p>
      </header>

      <div className="mb-16">
        <Button asChild size="lg">
          <Link href="/sites">
            Open Dashboard & Get Started
          </Link>
        </Button>
      </div>

      <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 max-w-5xl mx-auto">
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <ShieldCheck className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Private & Secure</h3>
          <p className="text-muted-foreground text-sm">
            No tracking or surveillance by default. Your data is yours.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Feather className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Simple & Focused</h3>
          <p className="text-muted-foreground text-sm">
            A minimal, content-first editor lets you focus on writing.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Zap className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Blazingly Fast</h3>
          <p className="text-muted-foreground text-sm">
            Static sites are fast, reliable, and efficient to host.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Archive className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Truly Portable</h3>
          <p className="text-muted-foreground text-sm">
            Export your entire site anytime. No vendor lock-in, ever.
          </p>
        </div>
      </section>
    </div>
    </>
  );
}

================================================================================

File: app/globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: app/sites/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';

export default function SiteLoaderLayout({ children }: { children: React.ReactNode }) {
  const params = useParams();
  const siteId = params.siteId as string;

  // --- USE THE NEW ACTION ---
  const loadSiteAction = useAppStore(state => state.loadSite);
  
  useEffect(() => {
    if (siteId) {
      // This will now reliably load the manifest and content files.
      loadSiteAction(siteId);
    }
  }, [siteId, loadSiteAction]);

  return <>{children}</>;
}

================================================================================

File: app/sites/page.tsx
// src/app/page.tsx
'use client';

import Link from 'next/link';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { PlusCircle, Edit3, Eye, Trash2, FilePlus2, Leaf } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { toast } from "sonner";

export default function HomePageDashboard() {
  const sites = useAppStore((state) => state.sites);
  const deleteSiteAndState = useAppStore((state) => state.deleteSiteAndState);

  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

  const validSites = sites.filter(site => site && site.manifest);

  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-8 gap-4">
        <h1 className="text-3xl font-bold text-foreground">My Signum Sites</h1>
        <Button asChild size="lg">
          <Link href="/create-site">
            <FilePlus2 className="mr-2 h-5 w-5" /> Create New Site
          </Link>
        </Button>
      </div>

      {validSites.length === 0 ? (
        <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
          <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
          <p className="text-muted-foreground mb-4">Click &quot;Create New Site&quot; to get started.</p>
          <Button asChild>
            <Link href="/create-site">
                <PlusCircle className="mr-2 h-4 w-4" /> Start Creating
            </Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {validSites.map((site) => (
            <div key={site.siteId} className="bg-card border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between">
              <div>
                <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.manifest.title}>
                  {site.manifest.title || "Untitled Site"}
                </h2>
                <p className="text-sm text-muted-foreground mb-4 line-clamp-2" title={site.manifest.description}>
                  {site.manifest.description || 'No description provided.'}
                </p>
              </div>
              <div className="mt-4 flex flex-wrap justify-start gap-2">
                <Button variant="outline" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/`} target="_blank" rel="noopener noreferrer">
                    <Eye className="mr-2 h-4 w-4" /> View
                  </Link>
                </Button>
                <Button variant="default" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/edit`}>
                     <Edit3 className="mr-2 h-4 w-4" /> Edit
                  </Link>
                </Button>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" size="sm">
                      <Trash2 className="mr-2 h-4 w-4" /> Delete
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This will permanently delete &quot;{site.manifest.title || 'this site'}&quot; from local storage.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={() => handleDeleteSite(site.siteId, site.manifest.title || 'Untitled Site')}>
                        Yes, delete site
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
    </>
  );
}

================================================================================

File: app/sites/[siteId]/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbEdit, TbSettings } from "react-icons/tb";
import { cn } from '@/lib/utils';
import Image from 'next/image';
import { ReactNode } from 'react';

/**
 * The root layout for a single site's backend.
 * This component provides the persistent vertical toolbar for navigating
 * between main sections like 'Edit' and 'Settings'.
 */
export default function SingleSiteLayout({ children }: { children: ReactNode }) {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const isEditorActive = pathname.startsWith(`/sites/${siteId}/edit`);
  const isSettingsActive = pathname.startsWith(`/sites/${siteId}/settings`);

  const navItems = [
    { href: `/sites/${siteId}/edit`, title: 'Edit', icon: TbEdit, isActive: isEditorActive },
    { href: `/sites/${siteId}/settings`, title: 'Settings', icon: TbSettings, isActive: isSettingsActive },
  ];

  return (
    <div className="flex h-screen flex-col lg:flex-row">
      <aside className="fixed inset-x-0 bottom-0 z-30 flex h-16 w-full shrink-0 border-t bg-background lg:static lg:inset-y-0 lg:left-0 lg:h-full lg:w-[60px] lg:border-r lg:border-t-0">
        <nav className="flex w-full items-center justify-center gap-4 px-2 lg:flex-col lg:justify-start lg:pb-5">
          <Link
            href="/sites"
            title="Dashboard"
            className='lg:flex hidden flex-col items-center w-[60px] h-[60px] border-b'
          >
            <Image src="/signum.svg" width={34} height={34} alt="Signum Logo" className='m-auto'/>
          </Link>
          
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              title={item.title}
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-lg transition-colors',
                item.isActive
                  ? 'bg-accent text-accent-foreground'
                  : 'text-muted-foreground hover:bg-accent/50 hover:text-foreground'
              )}
            >
              <item.icon className="size-6" />
            </Link>
          ))}
        </nav>
      </aside>

      {/* The rest of the page (which will be another layout like EditSiteLayout) renders here. */}
      <main className="flex-1 overflow-auto pb-16 lg:pb-0">
        {children}
      </main>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/page.tsx
// src/app/sites/[siteId]/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page now acts as a smart entry point for a site.
// Its only job is to redirect the user to the editor.
export default function SiteRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid polluting the browser's history.
      // This sends the user directly to the site editor.
      router.replace(`/sites/${siteId}/edit`);
    }
  }, [siteId, router]);

  // Display a loading message while the redirect is processed.
  return (
    <div className="flex justify-center items-center h-full">
      <p>Redirecting to editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/layout.tsx
// src/app/sites/[siteId]/settings/layout.tsx
'use client';

import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import SettingsNav from '@/features/site-settings/components/SettingsNav';
import { ReactNode, useEffect } from 'react';
import { useUIStore } from '@/core/state/uiStore';

/**
 * The root layout for the entire settings section.
 * It provides the consistent ThreeColumnLayout structure and manages the
 * global UI state to ensure the left sidebar (with the settings menu) is

 * always visible and the right sidebar is always hidden.
 */
export default function SettingsSectionLayout({ children }: { children: ReactNode }) {
  // --- START: Get state and setters from the UI store ---
  const { 
    leftSidebarContent, 
    rightSidebarContent, 
    setLeftAvailable, 
    setRightAvailable, 
    setRightOpen,
    setLeftSidebarContent,
    setRightSidebarContent 
  } = useUIStore(state => state.sidebar);
  // --- END ---

  // This effect runs once to configure the sidebars for the entire settings section.
  useEffect(() => {
    // 1. Configure availability and state
    setLeftAvailable(true);
    setRightAvailable(false); // No right sidebar in settings
    setRightOpen(false);      // Ensure it's closed

    // 2. Set the static content for the left sidebar
    setLeftSidebarContent(<SettingsNav />);
    // 3. Ensure the right sidebar content is null
    setRightSidebarContent(null);

    // Cleanup when navigating away from the settings section
    return () => {
      setLeftAvailable(false);
      setLeftSidebarContent(null);
    };
  }, [setLeftAvailable, setRightAvailable, setRightOpen, setLeftSidebarContent, setRightSidebarContent]);

  // The final render now uses the ThreeColumnLayout, reading the sidebar
  // content from the store and passing it as props.
  return (
    <ThreeColumnLayout
      leftSidebar={leftSidebarContent}
      rightSidebar={rightSidebarContent} // This will be null, so nothing renders
    >
      {children}
    </ThreeColumnLayout>
  );
}

================================================================================

File: app/sites/[siteId]/settings/page.tsx
// src/app/sites/[siteId]/settings/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import SiteSettingsForm from '@/features/site-settings/components/SiteSettingsForm';
import { Button } from '@/core/components/ui/button';
import { Manifest } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import Link from 'next/link';

export default function SiteSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);
  const isStoreInitialized = useAppStore(state => state.isInitialized);

  // Add baseUrl to the form state
  const [formData, setFormData] = useState({ title: '', description: '', author: '', baseUrl: '' });
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  useEffect(() => {
    if (site?.manifest) {
      setFormData({
        title: site.manifest.title,
        description: site.manifest.description,
        author: site.manifest.author || '',
        baseUrl: site.manifest.baseUrl || '',
      });
      setHasChanges(false);
    }
  }, [site]);
  
  const handleFormChange = useCallback((newData: typeof formData) => {
    setFormData(newData);
    setHasChanges(true);
  }, []);

  const handleSave = async () => {
    if (!site || !site.manifest) return;
    if (!formData.title.trim()) {
      toast.error("Site title cannot be empty.");
      return;
    }
    
    const trimmedBaseUrl = formData.baseUrl.trim();
    if (trimmedBaseUrl) {
      try {
        new URL(trimmedBaseUrl);
      } catch {
        toast.error("The Base URL you entered is not a valid URL. Please include https://");
        return;
      }
    }
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      title: formData.title.trim(),
      description: formData.description.trim(),
      author: formData.author.trim(),
      baseUrl: trimmedBaseUrl,
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Site settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving site settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!isStoreInitialized || (site && !formData.title && !site.manifest.title)) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  if (!site) {
    return (
      <div className="p-6 text-center">
        <h2 className="text-xl font-semibold">Site Not Found</h2>
        <Button asChild variant="outline" className="mt-4">
          <Link href="/">Go to Dashboard</Link>
        </Button>
      </div>
    );
  }

  // The component now only returns its content, not the layout.
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Site Settings</h1>
        <p className="text-muted-foreground">Manage the core details of your website.</p>
      </div>
      <div className="border-t pt-6">
        <SiteSettingsForm 
          formData={formData}
          onFormChange={handleFormChange} 
        />
      </div>
      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/appearance/page.tsx
// src/app/sites/[siteId]/settings/appearance/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import AppearanceSettingsForm from '@/features/site-settings/components/AppearanceSettingsForm';
import { Button } from '@/core/components/ui/button';
import { Manifest, ThemeConfig, ThemeInfo } from '@/types';
import { useEffect, useState, useCallback, useMemo } from 'react';
import { toast } from "sonner";
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { getAvailableThemes } from '@/core/services/configHelpers.service';

export default function AppearanceSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);

  const [selectedThemePath, setSelectedThemePath] = useState<string>('');
  const [themeConfig, setThemeConfig] = useState<ThemeConfig['config']>({});
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  const availableThemes = useMemo(() => {
    return getAvailableThemes(site?.manifest);
  }, [site?.manifest]);

  useEffect(() => {
    if (site?.manifest.theme) {
      setSelectedThemePath(site.manifest.theme.name);
      setThemeConfig(site.manifest.theme.config);
      setHasChanges(false);
    }
  }, [site]);
  
  const handleConfigChange = useCallback((newConfig: ThemeConfig['config']) => {
    setThemeConfig(newConfig);
    setHasChanges(true);
  }, []);

  const handleThemeChange = (newThemePath: string) => {
    setSelectedThemePath(newThemePath);
    setThemeConfig({});
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!site || !site.manifest || !selectedThemePath) return;
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      theme: {
        name: selectedThemePath,
        config: themeConfig,
      },
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Appearance settings saved successfully!');
      setHasChanges(false);
    } catch {
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!site) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  // The component now only returns its content, not the layout.
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Appearance</h1>
        <p className="text-muted-foreground">Customize the visual style of your site.</p>
      </div>

      <div className="border-t pt-6 space-y-6">
        <div>
            <Label htmlFor="theme-select">Active Theme</Label>
            <Select value={selectedThemePath} onValueChange={handleThemeChange}>
                <SelectTrigger id="theme-select" className="mt-1">
                    <SelectValue placeholder="Select a theme..." />
                </SelectTrigger>
                <SelectContent>
                    {availableThemes.map((theme: ThemeInfo) => (
                        <SelectItem key={theme.path} value={theme.path}>
                            {theme.name}
                        </SelectItem>
                    ))}
                </SelectContent>
            </Select>
        </div>
        
        {selectedThemePath && (
            <AppearanceSettingsForm 
                site={site}
                themePath={selectedThemePath}
                themeConfig={themeConfig}
                onConfigChange={handleConfigChange}
            />
        )}
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Appearance'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/layout.tsx
// src/app/sites/[siteId]/edit/layout.tsx
'use client';

import { ReactNode } from 'react';

/**
 * The root layout for the /edit section.
 * In this refactored architecture, this layout has a minimal role.
 * It primarily serves as a container for the editor pages.
 * The context providers and specific layouts are now handled by the
 * page components themselves for better encapsulation.
 */
export default function EditSiteLayout({ children }: { children: ReactNode }) {
  // This layout simply renders the page that Next.js passes to it.
  return <>{children}</>;
}

================================================================================

File: app/sites/[siteId]/edit/page.tsx
// src/app/sites/[siteId]/edit/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page acts as a default entry point for the editor.
// It immediately redirects to the editor for the site's homepage (index.md).
export default function SiteEditorRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid adding this redirect page to the browser history.
      // This will navigate to the content editor for the file at `content/index.md`.
      router.replace(`/sites/${siteId}/edit/content/`);
    }
  }, [siteId, router]);

  // Return a loading state while the redirect is happening.
  return (
    <div className="p-6 flex justify-center items-center h-full">
      <p>Loading editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
// src/app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
'use client';

import { useMemo, useEffect, useRef } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { EditorProvider } from '@/features/editor/contexts/EditorContext';
import { slugify } from '@/lib/utils';
import type { LocalSiteData } from '@/types';

// --- Component Imports ---
import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import MarkdownEditor, { type MarkdownEditorRef } from '@/components/publishing/MarkdownEditor';
import FrontmatterSidebar from '@/features/editor/components/FrontmatterSidebar';
import PrimaryContentFields from '@/features/editor/components/PrimaryContentFields';
import LeftSidebar from '@/components/publishing/LeftSidebar';
import CollectionItemList from '@/features/editor/components/CollectionItemList';

// --- Modular Hooks ---
import { usePageIdentifier } from '@/features/editor/hooks/usePageIdentifier';
import { useFileContent } from '@/features/editor/hooks/useFileContent';
import { useFilePersistence } from '@/features/editor/hooks/useFilePersistence';

function EditContentPageInternal() {
  const editorRef = useRef<MarkdownEditorRef>(null);

  // 1. Identify the page from the URL
  const { siteId, isNewFileMode, filePath } = usePageIdentifier();

  // 2. Manage the file's content state (this hook no longer provides hasUnsavedChanges)
  const {
    status,
    site,
    frontmatter,
    bodyContent,
    slug,
    setSlug,
    handleFrontmatterChange,
    onContentModified,
  } = useFileContent(siteId, filePath, isNewFileMode);


  // 3. Manage file persistence. It now gets its state from the context, so we pass fewer props.
  const { handleDelete } = useFilePersistence({
    siteId,
    filePath,
    isNewFileMode,
    frontmatter,
    slug,
    getEditorContent: () => editorRef.current?.getMarkdown() ?? '',
  });

  // 4. Manage UI state (sidebars)
  const {
    leftSidebarContent, rightSidebarContent,
    setLeftAvailable, setRightAvailable,
    setLeftSidebarContent, setRightSidebarContent
  } = useUIStore(state => state.sidebar);

  // Determine if the current page is a collection page
  const isCollectionPage = useMemo(() => !!frontmatter?.collection, [frontmatter]);

  // Effect to manage the Left Sidebar (File Tree)
  useEffect(() => {
    setLeftAvailable(true);
    setLeftSidebarContent(<LeftSidebar />);
    return () => {
        setLeftAvailable(false);
        setLeftSidebarContent(null);
    }
  }, [setLeftAvailable, setLeftSidebarContent]);

  // Effect to manage the Right Sidebar (Settings)
  useEffect(() => {
    if (status === 'ready' && frontmatter && site) {
      setRightAvailable(true);
      setRightSidebarContent(
        <FrontmatterSidebar
          siteId={siteId}
          site={site as LocalSiteData}
          frontmatter={frontmatter}
          onFrontmatterChange={handleFrontmatterChange}
          isNewFileMode={isNewFileMode}
          slug={slug}
          onSlugChange={(newSlug) => setSlug(slugify(newSlug))}
          onDelete={handleDelete}
        />
      );
    } else {
      setRightAvailable(false);
      setRightSidebarContent(null);
    }
    return () => { setRightAvailable(false); }
  }, [status, site, frontmatter, isNewFileMode, slug, siteId, handleFrontmatterChange, handleDelete, setSlug, setRightAvailable, setRightSidebarContent]);


  // --- Main Content Rendering Logic ---
  const pageContent = useMemo(() => {
    if (status !== 'ready' || !frontmatter) {
      return <div className="p-6 flex justify-center items-center h-full"><p>Loading Editor...</p></div>;
    }

    return (
      <div className='flex h-full w-full flex-col'>
        <div className='container mx-auto flex h-full max-w-[900px] flex-col p-6'>
            {/* Title and Description are ALWAYS shown */}
            <div className="shrink-0">
                <PrimaryContentFields
                    frontmatter={frontmatter}
                    onFrontmatterChange={handleFrontmatterChange}
                />
            </div>
            <div className="mt-6 flex-grow min-h-0">
              {isCollectionPage ? (
                // If it's a collection, show the item list table.
                <CollectionItemList
                  siteId={siteId}
                  collectionPagePath={filePath}
                />
              ) : (
                // Otherwise, show the Markdown editor for the body.
                <MarkdownEditor
                  ref={editorRef}
                  key={filePath}
                  initialValue={bodyContent}
                  onContentChange={onContentModified}
                />
              )}
            </div>
        </div>
      </div>
    );
  }, [status, frontmatter, bodyContent, filePath, editorRef, onContentModified, isCollectionPage, siteId, handleFrontmatterChange]);

  return (
    <ThreeColumnLayout
        leftSidebar={leftSidebarContent}
        rightSidebar={rightSidebarContent}
    >
        {pageContent}
    </ThreeColumnLayout>
  );
}

export default function EditContentPage() {
    return (
        <EditorProvider>
            <EditContentPageInternal />
        </EditorProvider>
    );
}

================================================================================

File: app/sites/[siteId]/view/[[...slug]]/page.tsx
// src/app/sites/[siteId]/view/[[...slug]]/page.tsx
'use client';

import SitePreview from '@/features/viewer/components/SiteViewer';

export default function ViewSitePage() {
  // This page's only job is to render the master preview component.
  // The component itself will read the URL from the browser.
  return <SitePreview />;
}

================================================================================

File: app/create-site/page.tsx
// src/app/(publishing)/create-site/page.tsx
'use client';

import { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { LocalSiteData, ParsedMarkdownFile, MarkdownFrontmatter, StructureNode, ThemeInfo } from '@/types';
import { Button } from '@/core/components/ui/button';
import { generateSiteId } from '@/lib/utils';
import { toast } from "sonner";
import { getLayoutManifest } from '@/core/services/configHelpers.service';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { GENERATOR_VERSION, CORE_THEMES, DEFAULT_PAGE_LAYOUT_PATH, DEFAULT_HOMEPAGE_CONFIG } from '@/config/editorConfig';
export default function CreateSitePage() {
  const router = useRouter();
  const addSite = useAppStore((state) => state.addSite);

  const [siteTitle, setSiteTitle] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  const availableThemes = useMemo(() => CORE_THEMES, []);
  const [selectedTheme, setSelectedTheme] = useState<ThemeInfo | null>(availableThemes[0] || null);

  const handleSubmit = async () => {
    if (!siteTitle.trim() || !selectedTheme) {
      toast.error('Site title and a theme are required.');
      return;
    }
    setIsLoading(true);

    const newSiteId = generateSiteId(siteTitle);
    const homepageLayoutPath = DEFAULT_PAGE_LAYOUT_PATH;

    const defaultFrontmatter: MarkdownFrontmatter = {
        title: DEFAULT_HOMEPAGE_CONFIG.TITLE,
        layout: homepageLayoutPath,
        date: new Date().toISOString().split('T')[0],
    };

    const mockSiteData: LocalSiteData = { 
        siteId: 'mock-id', 
        contentFiles: [], 
        layoutFiles: [], 
        themeFiles: [], 
        manifest: { 
            siteId: 'mock-id',
            title: 'mock',
            description: 'mock',
            generatorVersion: GENERATOR_VERSION,
            structure: [],
            theme: { 
                name: selectedTheme.path, 
                config: {} 
            } 
        } 
    };
    
    const layoutManifest = await getLayoutManifest(mockSiteData, homepageLayoutPath);
    
    if (layoutManifest?.schema?.properties) {
    for (const [key, prop] of Object.entries(layoutManifest.schema.properties)) {
        // Check if the property in the schema has a 'default' value
        if (typeof prop === 'object' && prop !== null && 'default' in prop) {
            // And if we haven't already set this value in our frontmatter
            if (defaultFrontmatter[key] === undefined) {
                // Then apply the default value from the schema.
                defaultFrontmatter[key] = prop.default as unknown;
            }
        }
    }
}

    const defaultIndexFile: ParsedMarkdownFile = {
        slug: 'index',
        path: 'content/index.md',
        frontmatter: defaultFrontmatter,
        content: `# Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`,
    };
    
    const indexStructureNode: StructureNode = {
        type: 'page',
        title: 'Home',
        path: 'content/index.md',
        slug: 'index',
        navOrder: 0,
        layout: homepageLayoutPath,
    };

    const newSiteData: LocalSiteData = {
      siteId: newSiteId,
      manifest: {
        siteId: newSiteId,
        generatorVersion: GENERATOR_VERSION,
        title: siteTitle.trim(),
        description: siteDescription.trim(),
        theme: {
          name: selectedTheme.path,
          config: {},
        },
        structure: [indexStructureNode],
      },
      contentFiles: [defaultIndexFile],
      themeFiles: [],
      layoutFiles: [],
    };

    try {
      await addSite(newSiteData);
      toast.success(`Site "${siteTitle}" created successfully!`);
      router.push(`/sites/${newSiteId}/edit/content/index`);
    } catch (error) {
      toast.error(`Failed to create site: ${(error as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-2xl">
      <div className="space-y-6">
        <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Create a New Site</h1>
            <Button onClick={() => router.push('/')} variant="outline">Cancel</Button>
        </div>

        <div className="space-y-4 p-6 border rounded-lg">
            <h2 className="text-lg font-semibold">Site Details</h2>
            <div>
                <Label htmlFor="site-title">Site Title</Label>
                <Input
                    id="site-title"
                    value={siteTitle}
                    onChange={(e) => setSiteTitle(e.target.value)}
                    placeholder="My Awesome Project"
                    required
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="site-description">Site Description (Optional)</Label>
                <Textarea
                    id="site-description"
                    value={siteDescription}
                    onChange={(e) => setSiteDescription(e.target.value)}
                    placeholder="A short and catchy description of your new site."
                    rows={3}
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="theme-select">Theme</Label>
                <Select 
                    value={selectedTheme?.path || ''} 
                    onValueChange={(themePath) => {
                        const theme = availableThemes.find(t => t.path === themePath);
                        if (theme) setSelectedTheme(theme);
                    }} 
                >
                    <SelectTrigger id="theme-select" className="mt-1">
                        <SelectValue placeholder="Select a theme..." />
                    </SelectTrigger>
                    <SelectContent>
                        {availableThemes.map(theme => (
                            <SelectItem key={theme.path} value={theme.path}>
                                {theme.name}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                 <p className="text-xs text-muted-foreground mt-1">
                    Choose the overall design for your site. You can change this later.
                </p>
            </div>
        </div>

        <div className="flex justify-end">
            <Button onClick={handleSubmit} disabled={isLoading || !siteTitle.trim() || !selectedTheme} size="lg">
                {isLoading ? 'Creating...' : 'Create Site'}
            </Button>
        </div>
      </div>
    </div>
  );
}

================================================================================

File: config/editorConfig.ts
// src/config/editorConfig.ts
import type { ThemeInfo, LayoutInfo } from '@/types';
import { RJSFSchema, UiSchema } from '@rjsf/utils'; 

/**
 * The official version of the Signum generator client.
 * This is written to the manifest.json on site creation and can be used
 * by the theme engine or other tools to check for compatibility.
 */
export const GENERATOR_VERSION = 'SignumClient/1.3.0';

/**
 * The URL segment used to identify a new, unsaved content file.
 * This allows the editor to distinguish between editing an existing file
 * and creating a new one.
 * e.g., /edit/site-id/content/blog/_new
 */
export const NEW_FILE_SLUG_MARKER = '_new';

/**
 * The delay in milliseconds for the autosave functionality in the content editor.
 * A longer delay reduces server/storage load but increases risk of data loss on close.
 * A shorter delay saves more often but can be more "chatty".
 */
export const AUTOSAVE_DELAY = 2500;

/**
 * The default layout path used for any new single page.
 * The system will fall back to this if a more specific layout isn't defined.
 * The path is relative to '/public/layouts/'.
 * e.g., 'page'
 */
export const DEFAULT_PAGE_LAYOUT_PATH = 'page';

/**
 * The default layout path used for any new collection.
 * This ensures that when a user creates a new collection, it has a sensible
 * default appearance without requiring an immediate decision.
 * The path is relative to '/public/layouts/'.
 * e.g., 'listing'
 */
export const DEFAULT_VIEW_LAYOUT_PATH = 'listing';

export const CORE_LAYOUTS: LayoutInfo[] = [
  // Page Layouts
  { id: 'page', name: 'Standard Page', type: 'page', path: 'page', description: "A clean, single-column page layout." },
  // Add other page layouts like 'post' here if they exist

  // List Layouts
  { id: 'listing', name: 'Vertical List', type: 'list', path: 'listing', description: "A standard, top-to-bottom list of items." },
  // Add other list layouts like 'grid' here if they exist

  // Item Layouts
  { id: 'teaser', name: 'Teaser Card', type: 'item', path: 'teaser', description: "A compact card with a title and summary." },
];

export const CORE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', path: 'default' },
];

/**
 * Default configuration for a new site's homepage (index.md).
 * Centralizes the initial title and content.
 */
export const DEFAULT_HOMEPAGE_CONFIG = {
  TITLE: 'Welcome to your new site!',
  /**
   * Generates the default markdown content for the homepage.
   * @param {string} siteTitle - The title of the site to include in the welcome message.
   * @returns {string} The formatted markdown string.
   */
  getContent: (siteTitle: string): string => 
    `## Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`
};

/**
 * The universal base schema for all content frontmatter.
 * This object is imported directly, eliminating network requests.
 * Fields like 'title' and 'description' are not included here because they
 * are handled by dedicated UI components, not the generic form generator.
 */
export const BASE_SCHEMA: { schema: RJSFSchema; uiSchema: UiSchema } = {
  schema: {
    title: 'Base content fields',
    type: 'object',
    properties: {
      slug: {
        type: 'string',
        title: 'Slug (URL Path)',
        description: 'The URL-friendly version of the title. Auto-generated, but can be edited.',
      },
      image: {
        type: 'string',
        title: 'Image',
        description: 'URL or path to a featured image for this content.',
      },
      date: {
        type: 'string',
        title: 'Publication date',
        format: 'date',
      },
      status: {
        type: 'string',
        title: 'Status',
        enum: ['published', 'draft'],
        default: 'draft',
      },
      author: {
        type: 'string',
        title: 'Author',
      },
      tags: {
        type: 'array',
        title: 'Tags',
        items: {
          type: 'string',
        },
      },
    },
  },
  uiSchema: {
    slug: {
      'ui:widget': 'hidden',
    },
    tags: {
      'ui:options': {
        addable: true,
        removable: true,
      },
    },
  },
};

================================================================================

File: features/viewer/components/SiteViewer.tsx
// src/components/view/SiteViewer.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useEffect, useState, useCallback } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { resolvePageContent } from '@/core/services/pageResolver.service';
import { PageType } from '@/types';import { render as renderWithTheme } from '@/core/services/theme-engine/themeEngine.service';
import { AlertTriangle, Edit } from 'lucide-react';
import { Button } from '@/core/components/ui/button';
import Link from 'next/link';

/**
 * Renders a live, interactive preview of a Signum site within an iframe.
 * This component acts as a mini-SPA, controlling the browser's URL history
 * to allow for deep linking and back/forward button navigation within the preview.
 */
export default function SiteViewer() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;
  const viewRootPath = `/sites/${siteId}/view`;

  const [currentRelativePath, setCurrentRelativePath] = useState(
    pathname.replace(viewRootPath, '') || '/'
  );
  const [htmlContent, setHtmlContent] = useState<string>('<p>Loading Preview...</p>');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const site = useAppStore((state) => state.getSiteById(siteId));

  const sandboxAttributes = 
    process.env.NODE_ENV === 'development'
      ? 'allow-scripts allow-forms allow-same-origin'
      : 'allow-scripts allow-forms';


  const updateIframeContent = useCallback(async () => {
    if (!site) return;

    // This ensures we don't try to render before the site's content is loaded.
    if (!site.contentFiles) {
        console.log("SiteViewer is waiting for content files to load...");
        return;
    }

    const slugArray = currentRelativePath.split('/').filter(Boolean);
    const resolution = resolvePageContent(site, slugArray);
    
    if (resolution.type === PageType.NotFound) {
      setErrorMessage(resolution.errorMessage);
      return;
    }

    try {
      const pureHtml = await renderWithTheme(site, resolution, {
        siteRootPath: viewRootPath,
        isExport: false,
      });

      // --- START: NEW ROBUST COMMUNICATION SCRIPT ---
      const parentOrigin = typeof window !== 'undefined' ? window.location.origin : '';

      const communicationScript = `
        <script>
          // The parent component injects its own origin here. This is the key.
          const PARENT_ORIGIN = '${parentOrigin}'; 

          document.addEventListener('click', function(e) {
            const link = e.target.closest('a');

            // 1. If it's not a link, do nothing.
            if (!link || !link.href) return;
            
            // 2. If it's an in-page anchor link, let the browser handle it.
            if (link.hash && link.pathname === window.location.pathname) return;

            // 3. This is the crucial check: Does the link point to the same origin
            //    as the parent application? This works in ANY sandbox mode.
            if (link.origin === PARENT_ORIGIN) {
              e.preventDefault();
              const newPath = new URL(link.href).pathname;
              // Post the message back to the parent, specifying its own origin for security.
              window.parent.postMessage({ type: 'SIGNUM_NAVIGATE', path: newPath }, PARENT_ORIGIN);
            }
            // 4. If it's an external link (e.g., to google.com), the condition fails
            //    and the browser handles it normally (opening in a new tab if target="_blank").
          });
        <\/script>
      `;
      // --- END: NEW ROBUST COMMUNICATION SCRIPT ---

      const finalHtml = pureHtml.replace('</body>', `${communicationScript}</body>`);
      setHtmlContent(finalHtml);
      setErrorMessage(null);
    } catch (e) {
      const error = e as Error;
      console.error("Error during site rendering:", error);
      setErrorMessage(`Theme Error: ${error.message}`);
    }
  }, [site, viewRootPath, currentRelativePath]);

  // Re-render the iframe whenever the path or the site data itself changes.
  useEffect(() => {
    updateIframeContent();
  }, [updateIframeContent]);

  // This effect manages the browser history and remains unchanged.
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // Security: Only accept messages from our own origin.
      if (event.origin !== window.location.origin) return;
      
      const { type, path } = event.data;
      if (type === 'SIGNUM_NAVIGATE' && path !== window.location.pathname) {
        history.pushState({ path }, '', path);
        setCurrentRelativePath(path.replace(viewRootPath, '') || '/');
      }
    };

    const handlePopState = (event: PopStateEvent) => {
        const newPath = event.state?.path || pathname;
        setCurrentRelativePath(newPath.replace(viewRootPath, '') || '/');
    };

    window.addEventListener('message', handleMessage);
    window.addEventListener('popstate', handlePopState);

    return () => {
      window.removeEventListener('message', handleMessage);
      window.removeEventListener('popstate', handlePopState);
    };
  }, [viewRootPath, pathname]);

  if (errorMessage) {
    return (
      <div className="p-8 text-center">
        <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
        <h1 className="text-2xl font-bold mb-2">Could Not Render Preview</h1>
        <p className="text-muted-foreground">{errorMessage}</p>
        <Button asChild variant="default" className="mt-6">
          <Link href={`/sites/${siteId}/edit`}>
            <Edit className="mr-2 h-4 w-4" /> Go to Editor
          </Link>
        </Button>
      </div>
    );
  }

  return (
    <iframe
      srcDoc={htmlContent}
      title={site?.manifest.title || 'Site Preview'}
      className="w-full h-full border-0"
      sandbox={sandboxAttributes}
    />
  );
}

================================================================================

File: features/viewer/components/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; 

import { marked } from 'marked';
import { useMemo } from 'react';
import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {

    }
    const rawHtml = marked.parse(markdown) as string;
    if (typeof window !== 'undefined') { 
    return DOMPurify.sanitize(rawHtml);
     }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Signum, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: features/site-settings/components/AppearanceSettingsForm.tsx
// src/components/publishing/AppearanceSettingsForm.tsx
'use client';

import { useEffect, useState } from 'react';
import { RJSFSchema } from '@rjsf/utils';
import { getJsonAsset, type ThemeManifest } from '@/core/services/configHelpers.service';
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';
import { ThemeConfig, LocalSiteData } from '@/types';

interface AppearanceSettingsFormProps {
  site: LocalSiteData;
  themePath: string;
  themeConfig: ThemeConfig['config'];
  onConfigChange: (newConfig: ThemeConfig['config']) => void;
}

export default function AppearanceSettingsForm({ site, themePath, themeConfig, onConfigChange }: AppearanceSettingsFormProps) {
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function loadSchema() {
      if (!themePath) {
        setIsLoading(false);
        setSchema(null);
        return;
      }
      
      setIsLoading(true);

      // --- START OF CORRECTED LOGIC ---

      // 1. Fetch the entire theme.json file for the active theme.
      const themeManifest = await getJsonAsset<ThemeManifest>(
        site,
        'theme',
        themePath,
        'theme.json' // <-- Correct filename
      );

      // 2. Check if the manifest was found and if it contains the appearance schema.
      if (themeManifest && themeManifest.appearanceSchema) {
        setSchema(themeManifest.appearanceSchema);
      } else {
        // If not found, there are no settings, so set the schema to null.
        setSchema(null);
      }
      
      // --- END OF CORRECTED LOGIC ---

      setIsLoading(false);
    }

    loadSchema();
  }, [site, themePath]);
  
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onConfigChange(event.formData as ThemeConfig['config'] || {});
  };

  if (isLoading) {
    return (
        <div className="flex items-center justify-center p-4 text-muted-foreground">
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span>Loading appearance options...</span>
        </div>
    );
  }

  if (!schema) {
    return (
      <div className="text-center border-2 border-dashed p-6 rounded-lg">
        <p className="font-semibold">No Appearance Options</p>
        <p className="text-sm text-muted-foreground">The current theme &quot;{themePath}&quot; does not provide any customizable appearance settings.</p>
      </div>
    );
  }

  return (
    <SchemaDrivenForm
      schema={schema}
      formData={themeConfig}
      onFormChange={handleChange}
    />
  );
}

================================================================================

File: features/site-settings/components/SiteSettingsForm.tsx
// src/components/publishing/SiteSettingsForm.tsx
'use client';

import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';

interface SiteSettingsFormProps {
  formData: {
    title: string;
    description: string;
    author: string;
    baseUrl: string; // <-- ADD THIS LINE
  };
  onFormChange: (newData: SiteSettingsFormProps['formData']) => void;
}

export default function SiteSettingsForm({ formData, onFormChange }: SiteSettingsFormProps) {
  const handleChange = (field: keyof typeof formData, value: string) => {
    onFormChange({ ...formData, [field]: value });
  };

  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Label htmlFor="title">Site Title</Label>
        <Input
          id="title"
          value={formData.title}
          onChange={(e) => handleChange('title', e.target.value)}
          placeholder="My Awesome Site"
        />
        <p className="text-sm text-muted-foreground">The main title for your website.</p>
      </div>
      <div className="space-y-2">
        <Label htmlFor="description">Site Description</Label>
        <Textarea
          id="description"
          value={formData.description}
          onChange={(e) => handleChange('description', e.target.value)}
          placeholder="A short, catchy description."
          rows={3}
        />
         <p className="text-sm text-muted-foreground">Used for search engines and social media previews.</p>
      </div>
       <div className="space-y-2">
        <Label htmlFor="author">Author (Optional)</Label>
        <Input
          id="author"
          value={formData.author}
          onChange={(e) => handleChange('author', e.target.value)}
          placeholder="Your Name or Organization"
        />
         <p className="text-sm text-muted-foreground">The default author for content on this site.</p>
      </div>
       {/* --- NEW BASE URL FIELD --- */}
       <div className="space-y-2 border-t pt-6">
        <Label htmlFor="baseUrl">Base URL</Label>
        <Input
          id="baseUrl"
          type="url"
          value={formData.baseUrl}
          onChange={(e) => handleChange('baseUrl', e.target.value)}
          placeholder="https://www.my-awesome-site.com"
        />
         <p className="text-sm text-muted-foreground">
            The full public URL of your site. Required for generating correct RSS feeds and sitemaps.
         </p>
      </div>
    </div>
  );
}

================================================================================

File: features/site-settings/components/SettingsNav.tsx
'use-client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbUserCircle, TbPalette } from 'react-icons/tb';
import { cn } from '@/lib/utils';

// This is the navigation component for the settings area.
export default function SettingsNav() {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const navItems = [
    { href: `/sites/${siteId}/settings`, title: 'Site Details', icon: TbUserCircle },
    { href: `/sites/${siteId}/settings/appearance`, title: 'Appearance', icon: TbPalette },
    // Add more settings links here as needed
  ];

  return (
    <div className="flex h-full flex-col p-4">
      <h2 className="px-2 text-lg font-semibold tracking-tight">Settings</h2>
      <nav className="mt-4 flex flex-col gap-1">
        {navItems.map((item) => (
          <Link
            key={item.href}
            href={item.href}
            className={cn(
              'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
              pathname === item.href
                ? 'bg-primary text-primary-foreground'
                : 'text-muted-foreground hover:bg-muted/50 hover:text-foreground'
            )}
          >
            <item.icon className="h-5 w-5" />
            {item.title}
          </Link>
        ))}
      </nav>
    </div>
  );
}

================================================================================

File: features/editor/contexts/EditorContext.tsx
// src/contexts/EditorContext.tsx
'use client';
import { toast } from 'sonner';

import { createContext, useContext, useState, ReactNode, useMemo, useRef, useCallback } from 'react';

export type SaveState = 'idle' | 'saving' | 'saved' | 'no_changes';

interface EditorContextType {
  saveState: SaveState;
  setSaveState: (state: SaveState) => void;
  hasUnsavedChanges: boolean;
  setHasUnsavedChanges: (hasChanges: boolean) => void;
  triggerSave: () => Promise<void>;
  registerSaveAction: (saveFn: () => Promise<void>) => void;
}

export const EditorContext = createContext<EditorContextType | undefined>(undefined);

interface EditorProviderProps {
  children: ReactNode;
}

export function EditorProvider({ children }: EditorProviderProps) {
  const [saveState, setSaveState] = useState<SaveState>('no_changes');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const saveActionRef = useRef<(() => Promise<void>) | null>(null);

  const registerSaveAction = useCallback((saveFn: () => Promise<void>) => {
    saveActionRef.current = saveFn;
  }, []);

  const triggerSave = useCallback(async () => {
    if (saveActionRef.current) {
      setSaveState('saving');
      try {
        await saveActionRef.current();
        setSaveState('saved');
        setHasUnsavedChanges(false);
        setTimeout(() => setSaveState('no_changes'), 2000);
      } catch (error) {
        console.error("Save failed:", error);
        toast.error((error as Error).message || "Failed to save.");
        setSaveState('idle');
      }
    }
  }, []);

  const contextValue = useMemo(() => ({
    saveState,
    setSaveState,
    hasUnsavedChanges, 
    setHasUnsavedChanges, 
    triggerSave,
    registerSaveAction,
    // FIX: Add missing dependencies for correctness
  }), [saveState, hasUnsavedChanges, registerSaveAction, triggerSave, setSaveState, setHasUnsavedChanges]);

  return (
    <EditorContext.Provider value={contextValue}>
      {children}
    </EditorContext.Provider>
  );
}

export function useEditor() {
  const context = useContext(EditorContext);
  if (context === undefined) {
    throw new Error('useEditor must be used within an EditorProvider');
  }
  return context;
}

================================================================================

File: features/editor/components/ViewEditor.tsx
// src/features/editor/components/ViewEditor.tsx
'use client';

import { useEffect, useState, useCallback } from 'react';
import { MarkdownFrontmatter, CollectionConfig } from '@/types';
import { getAvailableLayouts, LayoutManifest } from '@/core/services/configHelpers.service';
import { useAppStore } from '@/core/state/useAppStore';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";

interface ViewEditorProps {
  siteId: string;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;
}

export default function ViewEditor({ siteId, frontmatter, onFrontmatterChange }: ViewEditorProps) {
  const site = useAppStore(state => state.getSiteById(siteId));

  // State for the dropdown options
  const [itemLayouts, setItemLayouts] = useState<LayoutManifest[]>([]);
  const [pageLayouts, setPageLayouts] = useState<LayoutManifest[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Fetch available layouts when the component mounts
  useEffect(() => {
    async function fetchData() {
      if (!site) return;
      setIsLoading(true);
      const allLayouts = await getAvailableLayouts(site);
      // Filter layouts by their new, specific types
      setItemLayouts(allLayouts.filter(l => l.layoutType === 'item'));
      setPageLayouts(allLayouts.filter(l => l.layoutType === 'page'));
      setIsLoading(false);
    }
    fetchData();
  }, [site]);

  // A generic handler to update a specific property within the 'collection' object
  const handleCollectionConfigChange = useCallback((key: keyof CollectionConfig, value: string | number) => {
    // We update the entire 'collection' object in the parent's frontmatter state
    const updatedCollectionConfig = { ...(frontmatter.collection!), [key]: value };
    onFrontmatterChange({
      collection: updatedCollectionConfig
    });
  }, [frontmatter.collection, onFrontmatterChange]);

  const collectionConfig = frontmatter.collection;

  if (isLoading) return <div className="p-6">Loading collection settings...</div>;

  // This component should not render if the page isn't a collection page.
  if (!collectionConfig) {
      return (
           <div className="p-6 text-center text-destructive-foreground bg-destructive/20 border border-destructive rounded-lg">
              <h3 className="font-semibold">Not a Collection Page</h3>
              <p className="text-sm">To enable collection settings, add a `collection` block to this page&apos;s frontmatter.</p>
          </div>
      );
  }

  return (
    <div className="p-4 border rounded-lg bg-background space-y-6">
      <h3 className="text-lg font-semibold">Collection Settings</h3>
      <p className="text-sm text-muted-foreground -mt-4">
        Configure how the list of child pages is displayed on this page.
      </p>

      {/* --- Layout Selection --- */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
       
        <div className="space-y-2">
            <Label htmlFor="item-layout">Item Layout (in list)</Label>
            <Select value={collectionConfig.item_layout} onValueChange={(v) => handleCollectionConfigChange('item_layout', v)}>
                <SelectTrigger id="item-layout"><SelectValue placeholder="Select..." /></SelectTrigger>
                <SelectContent>{itemLayouts.map(l => <SelectItem key={l.id} value={l.id}>{l.name}</SelectItem>)}</SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">Appearance of each item teaser.</p>
        </div>
      </div>
      <div className="space-y-2">
        <Label htmlFor="item-page-layout">Full Page Layout (for items)</Label>
        <Select value={collectionConfig.item_page_layout} onValueChange={(v) => handleCollectionConfigChange('item_page_layout', v)}>
            <SelectTrigger id="item-page-layout"><SelectValue placeholder="Select..." /></SelectTrigger>
            <SelectContent>{pageLayouts.map(l => <SelectItem key={l.id} value={l.id}>{l.name}</SelectItem>)}</SelectContent>
        </Select>
         <p className="text-xs text-muted-foreground">The default layout when a user clicks to view a single item from this collection.</p>
      </div>

      {/* --- Sorting & Pagination --- */}
       <Accordion type='single' collapsible className="w-full" defaultValue='item-1'>
          <AccordionItem value="item-1">
              <AccordionTrigger>Sorting & Pagination</AccordionTrigger>
              <AccordionContent className="pt-4 grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-6">
                  <div className="space-y-2">
                      <Label htmlFor="sort-by">Sort Items By</Label>
                      <Select value={collectionConfig.sort_by} onValueChange={(v) => handleCollectionConfigChange('sort_by', v)}>
                        <SelectTrigger id="sort-by"><SelectValue placeholder="Select..." /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="date">Date</SelectItem>
                            <SelectItem value="title">Title</SelectItem>
                        </SelectContent>
                      </Select>
                  </div>
                  <div className="space-y-2">
                      <Label htmlFor="sort-order">Sort Order</Label>
                       <Select value={collectionConfig.sort_order} onValueChange={(v) => handleCollectionConfigChange('sort_order', v)}>
                        <SelectTrigger id="sort-order"><SelectValue placeholder="Select..." /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="desc">Descending</SelectItem>
                            <SelectItem value="asc">Ascending</SelectItem>
                        </SelectContent>
                      </Select>
                  </div>
                   <div className="flex items-center space-x-2 pt-2">
                        <Label htmlFor="items-per-page">Items Per Page</Label>
                        <Input
                            id="items-per-page"
                            type="number"
                            value={collectionConfig.items_per_page || 10}
                            onChange={(e) => handleCollectionConfigChange('items_per_page', parseInt(e.target.value, 10) || 10)}
                            className="w-20"
                        />
                    </div>
              </AccordionContent>
          </AccordionItem>
        </Accordion>
    </div>
  );
}

================================================================================

File: features/editor/components/EditorHeader.tsx
'use client';

import { useState } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { toast } from 'sonner';
import { exportSiteToZip } from '@/core/services/siteExporter.service';
import { useEditor } from '@/features/editor/contexts/EditorContext'; 
import { slugify } from '@/lib/utils';
import { Eye, PanelLeft, UploadCloud, PanelRight, Save, Check, Loader2 } from 'lucide-react';
import Image from 'next/image';

const SaveButton = () => {
  const editorContext = useEditor();

   if (!editorContext) {
    return null;
  }

  // --- FIX: Consume both raw state values ---
  const { saveState, hasUnsavedChanges, triggerSave } = editorContext;

  const buttonContent = {
    idle: { icon: <Save className="h-4 w-4" />, text: 'Save' },
    saving: { icon: <Loader2 className="h-4 w-4 animate-spin" />, text: 'Saving' },
    saved: { icon: <Check className="h-4 w-4" />, text: 'Saved' },
  };

  // --- FIX: New logic to determine the display state ---
  let displayState: 'idle' | 'saving' | 'saved';
  let isDisabled = false;

  if (saveState === 'saving') {
    displayState = 'saving';
    isDisabled = true;
  } else if (hasUnsavedChanges) {
    displayState = 'idle';
    isDisabled = false;
  } else {
    // This covers 'saved' and 'no_changes'
    displayState = 'saved';
    isDisabled = true;
  }

  const current = buttonContent[displayState];

  return (
    <Button variant='ghost' onClick={triggerSave} disabled={isDisabled}>
      {current.icon}
      <span className='hidden md:block'>{current.text}</span>
    </Button>
  );
};


export default function EditorHeader() {
  const params = useParams();
  const siteId = params.siteId as string;
  const [isPublishing, setIsPublishing] = useState(false);
  const site = useAppStore((state) => state.getSiteById(siteId));
  
  const toggleLeftSidebar = useUIStore((state) => state.sidebar.toggleLeftSidebar);
  const toggleRightSidebar = useUIStore((state) => state.sidebar.toggleRightSidebar);
  const isLeftAvailable = useUIStore((state) => state.sidebar.isLeftAvailable);
  const isRightAvailable = useUIStore((state) => state.sidebar.isRightAvailable);


  const handlePublishSite = async () => {
    if (!site) {
      toast.error("Site data not found. Cannot publish.");
      return;
    }
    setIsPublishing(true);
    toast.info("Generating site bundle for download...");
    try {
      const blob = await exportSiteToZip(site);
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${slugify(site.manifest.title || 'signum-site')}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      toast.success("Site bundle downloaded!");
    } catch (error) {
      console.error("Error publishing site to Zip:", error);
      toast.error(`Failed to generate Zip: ${(error as Error).message}`);
    } finally {
        setIsPublishing(false);
    }
  };
  
  if (!site) {
    return (
        <header className="sticky top-0 z-20 flex h-[60px] items-center gap-4 border-b bg-background px-4 lg:h-[60px]"></header>
    );
  }

  return (
    <header className="sticky top-0 z-20 flex shrink-0 items-center gap-4 border-b bg-background lg:pl-4 pr-4 h-[60px]">
      <div className="flex items-center gap-2">
        {/* Render button only if the left sidebar is available for the current page */}
        <Link
            href="/sites"
            title="Dashboard"
            className=' flex lg:hidden flex-col w-[60px] h-[60px] items-center border-r mr-2'
          >
            <Image src="/signum.svg" width={34} height={34} alt="" className='m-auto'/>
          </Link>
        {isLeftAvailable && (
            <Button 
                variant="outline" 
                size="icon" 
                className="shrink-0" 
                onClick={toggleLeftSidebar}
            >
                <PanelLeft className="h-5 w-5" />
                <span className="sr-only">Toggle file tree</span>
            </Button>
        )}
      </div>

      <div className="flex-1 text-lg text-muted-foreground">
       <span className="font-bold text-foreground">{site.manifest.title}</span>
      </div>
      
      <div className="flex items-center justify-end gap-2">
        <SaveButton />
        <Button variant="outline" asChild>
            <Link href={`/sites/${siteId}/view`} target="_blank">
                <Eye className="h-4 w-4" /> <span className='hidden md:block '>View</span>
            </Link>
        </Button>
        <Button variant="default" onClick={handlePublishSite} disabled={isPublishing}>
            <UploadCloud className="h-4 w-4" /> 
            <span className='hidden md:block '>{isPublishing ? 'Publishing...' : 'Publish'}</span>
        </Button>

        {/* Render button only if the right sidebar is available for the current page */}
        {isRightAvailable && (
            <Button variant="outline" size="icon" className="shrink-0" onClick={toggleRightSidebar}>
                <PanelRight className="h-5 w-5" />
                <span className="sr-only">Toggle settings sidebar</span>
            </Button>
        )}
      </div>
    </header>
  );
}

================================================================================

File: features/editor/components/ImageUploadWidget.tsx
'use client';

import { useState } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { getActiveImageService } from '@/core/services/images/images.service';
import { ImageRef } from '@/core/services/images/types';
import { Button } from '@/core/components/ui/button';

interface ImageUploadWidgetProps {
  siteId: string;
  value: string; // The current src value from frontmatter
  onImageSelect: (imageRef: ImageRef) => void;
}

export default function ImageUploadWidget({ siteId, value, onImageSelect }: ImageUploadWidgetProps) {
  const site = useAppStore(state => state.getSiteById(siteId));
  const [isLoading, setIsLoading] = useState(false);

  const handleUploadClick = async (event: React.ChangeEvent<HTMLInputElement>) => {
    if (!event.target.files || !site) return;
    const file = event.target.files[0];
    
    setIsLoading(true);
    try {
      const imageService = getActiveImageService(site.manifest);
      const imageRef = await imageService.upload(file, siteId);
      onImageSelect(imageRef); // Pass the full reference back to the parent form
    } catch (error) {
      console.error("Image upload failed:", error);
      // Show a toast message to the user
    } finally {
      setIsLoading(false);
    }
  };

  const imageService = site ? getActiveImageService(site.manifest) : null;
  // This logic would need to be expanded for the Cloudinary widget,
  // which brings its own button/UI.
  
  return (
    <div>
      {value && <img src={value} alt="Current image" className="w-full h-auto rounded-md mb-2" />}
      <input
        type="file"
        id="image-upload"
        className="hidden"
        onChange={handleUploadClick}
        accept="image/*"
      />
      <Button asChild>
        <label htmlFor="image-upload">{value ? 'Change Image' : 'Upload Image'}</label>
      </Button>
      {isLoading && <p>Uploading...</p>}
    </div>
  );
}

================================================================================

File: features/editor/components/PrimaryContentFields.tsx
// src/components/publishing/PrimaryContentFields.tsx
'use client';

import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { Label } from '@/core/components/ui/label';
import { MarkdownFrontmatter } from '@/types';

// FIXED: The interface is now much stricter and safer.
// It only defines the properties this component actually cares about.
interface PrimaryFieldsProps {
  frontmatter: {
    title?: string;
    description?: string;
  };
  // The callback expects a partial update to the main frontmatter state.
  onFrontmatterChange: (newData: Partial<MarkdownFrontmatter>) => void;
  showDescription?: boolean;
}

export default function PrimaryContentFields({
  frontmatter,
  onFrontmatterChange,
}: PrimaryFieldsProps) {

  // FIXED: The handler now only passes back the single field that changed.
  // This makes the component more reusable and decoupled from the parent's state shape.
  const handleChange = (field: 'title' | 'description', value: string) => {
    onFrontmatterChange({
      [field]: value,
    });
  };

  return (
    <div className="space-y-4 shrink-0">
      <div className="space-y-2 mb-6 border-b pb-3">
        <Label htmlFor="content-title" className="text-[10px] font-medium uppercase text-gray-400">
          Title
        </Label>
        <Input
          id="content-title"
          placeholder="Enter a title..."
          value={frontmatter.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          // These classes create the large, "invisible" input style
          className="text-2xl lg:text-3xl font-bold h-auto p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent"
        />
      </div>

        <div className="space-y-2 mb-6 border-b pb-3">
          <Label htmlFor="content-description" className="text-[10px] font-medium uppercase text-gray-400">
            Description
          </Label>
          <Textarea
            
            placeholder="Add a short description..."
            value={frontmatter.description || ''}
            onChange={(e) => handleChange('description', e.target.value)}
            // Style for a clean, borderless textarea
            className="p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent resize-none text-2xl text-black"
            rows={1}
          />
        </div>
    </div>
  );
}

================================================================================

File: features/editor/components/NewPageDialog.tsx
// src/features/editor/components/NewPageDialog.tsx
'use client';

import { useState, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// --- UI & Type Imports ---
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface NewPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function NewPageDialog({ siteId, children, onComplete }: NewPageDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [title, setTitle] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setTitle('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleCreatePage = async () => {
    if (!title.trim()) {
      toast.error("Page title cannot be empty.");
      return;
    }
    setIsSubmitting(true);
    const slug = slugify(title);
    const filePath = `content/${slug}.md`;

    const slugExists = site?.contentFiles?.some(f => f.slug === slug);
    if (slugExists) {
        toast.error(`A page with the slug "${slug}" already exists.`);
        setIsSubmitting(false);
        return;
    }
    
    const frontmatter: MarkdownFrontmatter = {
        title: title.trim(),
        layout: DEFAULT_PAGE_LAYOUT_PATH,
        date: new Date().toISOString().split('T')[0],
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\nStart writing your content here.\n`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);      if (success) {
        toast.success(`Page "${title}" created!`);
        handleOpenChange(false);
        onComplete?.();
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else { throw new Error("Failed to update manifest or save file."); }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New Content Page</DialogTitle>
          <DialogDescription>
            Give your new page a title. You can add content and change settings later.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="space-y-1">
            <Label htmlFor="title">Page Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., About Us" />
          </div>
        </div>
        <DialogFooter>
          <DialogClose asChild><Button variant="outline">Cancel</Button></DialogClose>
          <Button type="button" onClick={handleCreatePage} disabled={!title.trim() || isSubmitting}>
            {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Page</>}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/FileTree.tsx
// src/features/editor/components/FileTree.tsx
'use client';

import React, { useState, useMemo } from 'react';
import Link from 'next/link';
import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { type ParsedMarkdownFile, type StructureNode } from '@/types';
import { toast } from 'sonner';
import { GripVertical, ChevronRight, File as FileIcon, LayoutGrid, Plus } from 'lucide-react';
import { cn } from '@/lib/utils';
import { DndContext, closestCenter, DragEndEvent, DragStartEvent, useDroppable, DragOverlay } from '@dnd-kit/core';
import { SortableContext, useSortable, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';
import { Button } from '@/core/components/ui/button';

// --- Type Definitions ---
interface FileTreeProps {
  nodes: StructureNode[];
  contentFiles: ParsedMarkdownFile[];
  baseEditPath: string;
  activePath?: string;
  onStructureChange: (nodes: StructureNode[]) => void;
  className?: string;
}

interface FileTreeNodeProps extends Omit<FileTreeProps, 'nodes' | 'onStructureChange' | 'className'> {
  node: StructureNode;
  activeDragId: string | null;
  onStructureChange: (reorderedChildren: StructureNode[]) => void;
}

// --- Draggable & Droppable Node Component ---
const DndNode: React.FC<FileTreeNodeProps> = ({ node, contentFiles, baseEditPath, activePath, activeDragId, onStructureChange }) => {
    const { attributes, listeners, setNodeRef: setSortableNodeRef, transform, transition } = useSortable({
        id: node.path,
    });
    
    const [isOpen, setIsOpen] = useState(true);

    // --- NEW: Determine if this node represents a Collection Page ---
    const isCollectionPage = useMemo(() => {
        const file = contentFiles.find(f => f.path === node.path);
        return !!file?.frontmatter.collection;
    }, [contentFiles, node.path]);

    // A page is a valid drop target if it's NOT a collection page.
    const isNestableTarget = !isCollectionPage && !!activeDragId;

    const { isOver, setNodeRef: setDroppableNodeRef } = useDroppable({
        id: node.path,
        disabled: !isNestableTarget,
    });
    
    const setNodeRef = (el: HTMLElement | null) => {
        setSortableNodeRef(el);
        setDroppableNodeRef(el);
    };

    const style = { transform: CSS.Transform.toString(transform), transition };
    const dropIndicatorStyle = isOver && isNestableTarget ? 'bg-blue-100 dark:bg-blue-900/50 outline outline-1 outline-blue-500' : '';
    const hasChildren = node.children && node.children.length > 0;

    // The editor link is the same for both page types
    const href = `${baseEditPath}/content/${node.slug}`;
    const newItemHref = `${href}/${NEW_FILE_SLUG_MARKER}`;

    const handleChildrenStructureChange = (reorderedChildren: StructureNode[]) => {
        const newParentNode = { ...node, children: reorderedChildren };
        onStructureChange([newParentNode]);
    };

    return (
        <div ref={setNodeRef} style={style} className="flex flex-col">
            <div className={cn("flex items-center group w-full my-0.5 rounded-md transition-colors", dropIndicatorStyle)}>
                <div {...attributes} {...listeners} className="p-1 cursor-grab touch-none text-muted-foreground/50">
                    <GripVertical className="h-4 w-4" />
                </div>
                <div className={cn("flex-grow flex items-center py-1 pl-1 pr-1 rounded-md hover:bg-muted", activePath === node.path && "bg-accent text-accent-foreground")}>
                    <ChevronRight 
                        className={cn("h-4 w-4 mr-1 shrink-0 transition-transform duration-200", hasChildren && !isCollectionPage ? 'cursor-pointer' : 'invisible', isOpen && "rotate-90")} 
                        onClick={() => hasChildren && setIsOpen(!isOpen)}
                    />
                    {isCollectionPage ? <LayoutGrid className="h-4 w-4 shrink-0 text-muted-foreground" /> : <FileIcon className="h-4 w-4 shrink-0 text-muted-foreground" />}
                    <Link href={href} className="truncate flex-grow mx-1.5 text-sm" title={node.title}>{node.title}</Link>

                    {/* NEW: Show "New Item" button for collections */}
                    {isCollectionPage && (
                        <Button asChild variant="ghost" size="icon" className="h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Link href={newItemHref} title={`New item in ${node.title}`}>
                                <Plus className="h-4 w-4" />
                            </Link>
                        </Button>
                    )}
                </div>
            </div>
            {/* NEW: Conditionally render children only for standard pages */}
            {hasChildren && !isCollectionPage && isOpen && (
                <div className="pl-6 border-l ml-4">
                    <FileTree
                        nodes={node.children!}
                        contentFiles={contentFiles}
                        baseEditPath={baseEditPath}
                        activePath={activePath}
                        onStructureChange={handleChildrenStructureChange}
                        className="py-1"
                    />
                </div>
            )}
        </div>
    );
};

// --- Main FileTree Component ---
export default function FileTree({ nodes, contentFiles, baseEditPath, activePath, onStructureChange, className }: FileTreeProps) {
  const { moveNode } = useAppStore.getState();
  const siteId = useParams().siteId as string;
  const [activeDragId, setActiveDragId] = useState<string | null>(null);
  const nodeIds = useMemo(() => nodes.map(n => n.path), [nodes]);

  const handleDragStart = (event: DragStartEvent) => {
      setActiveDragId(event.active.id as string);
  };

  const handleDragEnd = (event: DragEndEvent) => {
    setActiveDragId(null);
    const { active, over } = event;

    if (!over || active.id === over.id) return;

    // --- NEW: Find if the target is a collection page ---
    const overNodeFile = contentFiles.find(f => f.path === over.id);
    const isOverNodeCollection = !!overNodeFile?.frontmatter.collection;

    if (isOverNodeCollection) {
        toast.error("Cannot nest pages under a Collection Page.");
        return;
    }
    
    // If over.id exists, it's a nesting attempt.
    if (nodes.some(n => n.path === over.id)) {
        moveNode(siteId, active.id as string, over.id as string);
    } else {
        // Otherwise, it's a reordering attempt.
        const oldIndex = nodeIds.indexOf(active.id as string);
        const newIndex = nodeIds.indexOf(over.id as string);
        if (oldIndex !== -1 && newIndex !== -1) {
            onStructureChange(arrayMove(nodes, oldIndex, newIndex));
        }
    }
  };

  return (
    <div className={cn("w-full", className)}>
        <DndContext onDragStart={handleDragStart} onDragEnd={handleDragEnd} collisionDetection={closestCenter}>
            <SortableContext items={nodeIds} strategy={verticalListSortingStrategy}>
                <div className="space-y-0.5">
                    {nodes.map(node => (
                        <DndNode 
                            key={node.path} 
                            node={node} 
                            contentFiles={contentFiles}
                            baseEditPath={baseEditPath} 
                            activePath={activePath} 
                            onStructureChange={(updatedChildList) => {
                                const newNodes = nodes.map(n => 
                                    n.path === updatedChildList[0].path ? updatedChildList[0] : n
                                );
                                onStructureChange(newNodes);
                            }}
                            activeDragId={activeDragId}
                        />
                    ))}
                </div>
            </SortableContext>
            <DragOverlay>
                {activeDragId ? <div className="p-2 bg-blue-100 dark:bg-blue-900 rounded-md shadow-lg text-sm">Moving page...</div> : null}
            </DragOverlay>
        </DndContext>
    </div>
  );
}

================================================================================

File: features/editor/components/DataSourceSelectWidget.tsx
// src/features/editor/components/DataSourceSelectWidget.tsx
'use client';

import { useEffect, useState, useMemo } from 'react';
import { getAvailableLayouts } from '@/core/services/configHelpers.service';
import { WidgetProps } from '@rjsf/utils';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Label } from '@/core/components/ui/label';
import type { LocalSiteData, StructureNode } from '@/types';
import type { LayoutManifest } from '@/core/services/configHelpers.service';

interface SelectOption {
  label: string;
  value: string;
}

interface DataSourceSelectWidgetProps extends WidgetProps {
    formContext?: {
        site?: LocalSiteData;
    };
}

const DataSourceSelectWidget = ({ id, label, options, value, onChange, required, formContext }: DataSourceSelectWidgetProps) => {
  const { uiSchema } = options;
  const site = formContext?.site;

  const dataSource = uiSchema?.['ui:dataSource'] as string;
  const layoutTypeFilter = uiSchema?.['ui:layoutType'] as string | undefined;

  const [items, setItems] = useState<SelectOption[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchItems = async () => {
      // Add a more robust guard clause
      if (!site || !site.manifest || !site.contentFiles) {
        setItems([]);
        setIsLoading(false);
        return;
      }
      setIsLoading(true);

      let fetchedItems: SelectOption[] = [];

      try {
        switch (dataSource) {
          case 'collections':
            // 1. Find all content files that ARE collection pages.
            const collectionFilePaths = new Set(
              site.contentFiles
                .filter(f => !!f.frontmatter.collection)
                .map(f => f.path)
            );
            // 2. Filter the structure nodes to only include those whose paths are in our set.
            fetchedItems = site.manifest.structure
              .filter((n: StructureNode) => collectionFilePaths.has(n.path))
              .map((c: StructureNode) => ({ label: c.title, value: c.slug }));
            break;

          case 'layouts':
            const allLayouts: LayoutManifest[] = await getAvailableLayouts(site);
            fetchedItems = allLayouts
              .filter(l => !layoutTypeFilter || l.layoutType === layoutTypeFilter)
              .map(l => ({ label: l.name, value: l.id })); // Use id for value
            break;

          default:
            fetchedItems = [];
        }
        setItems(fetchedItems);
      } catch (error) {
        console.error(`Failed to fetch data source "${dataSource}":`, error);
        setItems([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchItems();
  }, [site, dataSource, layoutTypeFilter]);

  const placeholder = useMemo(() => {
    if (isLoading) return `Loading ${dataSource || 'options'}...`;
    if (dataSource) return `Select a ${dataSource.replace(/s$/, '')}...`;
    return 'Select an option...';
  }, [isLoading, dataSource]);

  return (
    <div className="space-y-1">
      <Label htmlFor={id}>{label}{required ? '*' : ''}</Label>
      <Select value={value} onValueChange={onChange} disabled={isLoading}>
        <SelectTrigger id={id} className="mt-1">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {items.map(item => (
            <SelectItem key={item.value} value={item.value}>
              {item.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DataSourceSelectWidget;

================================================================================

File: features/editor/components/CollectionItemList.tsx
// src/features/editor/components/CollectionItemList.tsx
'use client';

import Link from 'next/link';
import { useMemo } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { findChildNodes } from '@/core/services/fileTree.service';
import { Button } from '@/core/components/ui/button';
import { FileText, PlusCircle } from 'lucide-react';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';

interface CollectionItemListProps {
  siteId: string;
  collectionPagePath: string; // e.g., 'content/blog.md'
}

export default function CollectionItemList({ siteId, collectionPagePath }: CollectionItemListProps) {
  const site = useAppStore(state => state.getSiteById(siteId));

  const collectionItems = useMemo(() => {
    if (!site?.manifest) return [];
    return findChildNodes(site.manifest.structure, collectionPagePath);
  }, [site?.manifest, collectionPagePath]);

  const newItemPath = `/sites/${siteId}/edit/content/${collectionPagePath.replace('content/', '').replace('.md', '')}/${NEW_FILE_SLUG_MARKER}`;

  return (
    <div className="h-full flex flex-col p-6">
      <div className="flex shrink-0 items-center justify-between mb-4 pb-4 border-b">
        <h1 className="text-2xl font-bold">Collection Items</h1>
        <Button asChild>
          <Link href={newItemPath}>
            <PlusCircle className="mr-2 h-4 w-4" /> New Item
          </Link>
        </Button>
      </div>
      <div className="flex-grow rounded-lg bg-background p-1 overflow-y-auto">
        {collectionItems.length > 0 ? (
          <ul className="space-y-1">
            {collectionItems.map((item) => {
              // --- THIS IS THE FIX ---
              // Generate the link from the reliable `item.path` instead of `item.slug`.
              const editorSlug = item.path.replace(/^content\//, '').replace(/\.md$/, '');
              const itemEditorPath = `/sites/${siteId}/edit/content/${editorSlug}`;
              // --- END OF FIX ---

              return (
                <li key={item.path}>
                  <Link href={itemEditorPath} className="flex items-center rounded-md p-2 transition-colors hover:bg-muted">
                    <FileText className="mr-3 h-4 w-4 text-muted-foreground" />
                    <span className="font-medium">{item.title || item.slug}</span>
                  </Link>
                </li>
              );
            })}
          </ul>
        ) : (
          <div className="text-center text-muted-foreground py-10">
            <p>No items have been added to this collection yet.</p>
            <Button asChild variant="outline" className="mt-4">
               <Link href={newItemPath}>
                    <PlusCircle className="mr-2 h-4 w-4" /> Add your first item
                </Link>
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}

================================================================================

File: features/editor/components/CreateCollectionPageDialog.tsx
// src/features/editor/components/CreateCollectionPageDialog.tsx
'use client';

import { useState, useEffect, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// UI & Type Imports
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter } from '@/types';
//import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface CreateCollectionPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

// Default layouts for a new collection page
const DEFAULT_LIST_LAYOUT = 'listing';
const DEFAULT_ITEM_LAYOUT = 'teaser';
const DEFAULT_ITEM_PAGE_LAYOUT = 'page';

export default function CreateCollectionPageDialog({ siteId, children, onComplete }: CreateCollectionPageDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  useEffect(() => {
    setSlug(slugify(name));
  }, [name]);

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setName('');
        setSlug('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }

    const filePath = `content/${slug}.md`;
    if (site?.contentFiles?.some(f => f.path === filePath)) {
        toast.error(`A page with the folder name "${slug}" already exists.`);
        return;
    }

    setIsSubmitting(true);

    const frontmatter: MarkdownFrontmatter = {
        title: name.trim(),
        layout: DEFAULT_LIST_LAYOUT, // The layout for this page itself
        collection: { // The special block that makes this a Collection Page
            item_layout: DEFAULT_ITEM_LAYOUT,
            item_page_layout: DEFAULT_ITEM_PAGE_LAYOUT,
            sort_by: 'date',
            sort_order: 'desc',
            items_per_page: 10,
        }
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\n# Welcome to the ${name.trim()} collection!\n\nYou can write an introduction for this collection here.`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);
      if (success) {
        toast.success(`Collection page "${name}" created!`);
        handleOpenChange(false);
        onComplete?.();
        // Redirect to the editor for the new collection page itself
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else {
        throw new Error("Failed to update manifest or save file.");
      }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
    } finally {
        setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection Page</DialogTitle>
            <DialogDescription>
              Create a new page that will list other pages, like a blog or a portfolio.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name.trim() || isSubmitting}>
                {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Collection</>}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/RightSidebar.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';

interface RightSidebarProps {
  children: ReactNode;
}

export default function RightSidebar({ children }: RightSidebarProps) {
  const { isRightOpen } = useUIStore((state) => state.sidebar);

  return (
    <aside
      className={cn(
        // Base styles
        'h-full w-80 shrink-0 border-l bg-muted/20 transition-all duration-300 ease-in-out',
        
        // Hide/Show Logic
        isRightOpen ? 'ml-0' : '-mr-[320px] w-0 border-l-0 opacity-0'
      )}
    >
      <div className="h-full overflow-y-auto">
        {children}
      </div>
    </aside>
  );
}

================================================================================

File: features/editor/components/FrontmatterSidebar.tsx
// src/features/editor/components/FrontmatterSidebar.tsx
'use client';

import React, { useState, useEffect, useMemo } from 'react';
import type { LocalSiteData, MarkdownFrontmatter } from '@/types';
import { getAvailableLayouts, getLayoutManifest, LayoutManifest } from '@/core/services/configHelpers.service';
import { RJSFSchema } from '@rjsf/utils'; 
import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Button } from '@/core/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Trash2 } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";
import ViewEditor from '@/features/editor/components/ViewEditor'; 
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm'; 

interface FrontmatterSidebarProps {
  siteId: string;
  site: Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles' | 'contentFiles'>;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: Partial<MarkdownFrontmatter>) => void;
  isNewFileMode: boolean;
  slug: string;
  onSlugChange: (newSlug: string) => void;
  onDelete: () => Promise<void>;
}

export default function FrontmatterSidebar({
  siteId, site, frontmatter, onFrontmatterChange,
  isNewFileMode, slug, onSlugChange, onDelete,
}: FrontmatterSidebarProps) {

 const [availableLayouts, setAvailableLayouts] = useState<LayoutManifest[]>([]);
  const [layoutSchema, setLayoutSchema] = useState<RJSFSchema | null>(null);

  const isCollectionPage = useMemo(() => !!frontmatter.collection, [frontmatter]);

  useEffect(() => {
    async function fetchAndFilterLayouts() {
      if (!site) return;

      // Determine which type of layout we need to show in the dropdown.
      const requiredLayoutType = isCollectionPage ? 'list' : 'page';
      const filteredLayouts = await getAvailableLayouts(site, requiredLayoutType);
      setAvailableLayouts(filteredLayouts);
    }
    fetchAndFilterLayouts();
  }, [site, isCollectionPage]); // Re-runs when the page type changes

  // This effect loads the schema for the currently selected layout.
  useEffect(() => {
    const loadSchema = async () => {
      if (!frontmatter.layout) {
        setLayoutSchema(null);
        return;
      }
      const manifest = await getLayoutManifest(site, frontmatter.layout);
      setLayoutSchema(manifest?.schema || null);
    };
    loadSchema();
  }, [site, frontmatter.layout]);

  const handleLayoutChange = (layoutId: string) => {
    onFrontmatterChange({ layout: layoutId });
  };

  return (
    <div className="p-4 space-y-6 h-full flex flex-col">
      <h2 className="text-lg font-semibold border-b pb-3">Page Settings</h2>
      <Accordion type="multiple" defaultValue={['general', 'collection', 'advanced']} className="w-full">
        <AccordionItem value="general">
          <AccordionTrigger>General</AccordionTrigger>
          <AccordionContent className="space-y-4 pt-4">
          
            <div className="space-y-2">
              <Label htmlFor="page-layout-select">Layout</Label>
              <Select value={frontmatter.layout} onValueChange={handleLayoutChange}>
                  <SelectTrigger id="page-layout-select"><SelectValue placeholder="Select a layout..." /></SelectTrigger>
                  <SelectContent>
                      {availableLayouts.map(layout => (
                          <SelectItem key={layout.id} value={layout.id}>{layout.name}</SelectItem>
                      ))}
                  </SelectContent>
              </Select>
               <p className="text-xs text-muted-foreground">Controls the appearance of this page.</p>
            </div>

            {layoutSchema && (
                <div className="border-t pt-4">
                     <h4 className="text-sm font-medium mb-2">Layout Options</h4>
                    <SchemaDrivenForm
                        schema={layoutSchema}
                        formData={frontmatter}
                        onFormChange={(data) => onFrontmatterChange(data as Partial<MarkdownFrontmatter>)}
                    />
                </div>
            )}
          </AccordionContent>
        </AccordionItem>

        {isCollectionPage && (
          <AccordionItem value="collection">
            <AccordionTrigger>Collection Display</AccordionTrigger>
            <AccordionContent className="pt-2">
              <ViewEditor
                siteId={siteId}
                frontmatter={frontmatter}
                onFrontmatterChange={onFrontmatterChange}
              />
            </AccordionContent>
          </AccordionItem>
        )}

        <AccordionItem value="advanced">
          <AccordionTrigger>Advanced</AccordionTrigger>
          <AccordionContent className="space-y-4 pt-4">
              <div className="space-y-2">
                <Label htmlFor="slug-input">URL Slug</Label>
                <Input
                    id="slug-input"
                    value={slug}
                    onChange={(e) => onSlugChange(e.target.value)}
                    disabled={!isNewFileMode}
                    className={!isNewFileMode ? 'bg-muted/50' : ''}
                />
              </div>
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      {!isNewFileMode && (
        <div className="mt-auto pt-6 border-t">
          {/* ... Delete button dialog remains the same ... */}
          <AlertDialog>
              <AlertDialogTrigger asChild>
                  <Button variant="outline" className="w-full text-destructive hover:bg-destructive/10 hover:text-destructive">
                      <Trash2 className="h-4 w-4 mr-2" /> Delete This Page
                  </Button>
              </AlertDialogTrigger>
              <AlertDialogContent>
                  <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This action will permanently delete the file for &quot;{frontmatter?.title || 'this content'}&quot; and all its child items. This cannot be undone.
                      </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={onDelete} className="bg-destructive hover:bg-destructive/90 text-destructive-foreground">
                          Yes, Delete Forever
                      </AlertDialogAction>
                  </AlertDialogFooter>
              </AlertDialogContent>
          </AlertDialog>
        </div>
      )}
    </div>
  );
}

================================================================================

File: features/editor/hooks/useUnloadPrompt.ts
// src/features/editor/hooks/useUnloadPrompt.ts
'use client';

import { useEffect } from 'react';

/**
 * A hook that shows the native browser confirmation dialog when the user
 * attempts to navigate away from the page.
 *
 * @param {boolean} shouldPrompt - A flag that determines whether the prompt should be shown.
 */
export function useUnloadPrompt(shouldPrompt: boolean) {
  useEffect(() => {
    const handleBeforeUnload = (event: BeforeUnloadEvent) => {
      if (shouldPrompt) {
        // Standard way to trigger the browser's native confirmation dialog
        event.preventDefault();
        // Required for some older browsers
        event.returnValue = '';
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    // Cleanup the event listener when the component unmounts
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [shouldPrompt]); // The effect re-runs whenever the `shouldPrompt` flag changes
}

================================================================================

File: features/editor/hooks/usePageIdentifier.ts
// src/features/editor/hooks/usePageIdentifier.ts
'use client';

import { useMemo } from 'react';
import { useParams } from 'next/navigation';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';

/**
 * Parses the URL to identify the site and the specific file being targeted for editing.
 */
export function usePageIdentifier() {
  const params = useParams();
  const siteId = params.siteId as string;
  const slugSegments = useMemo(() => (params.slug as string[]) || [], [params.slug]);

  const isNewFileMode = useMemo(() => slugSegments.includes(NEW_FILE_SLUG_MARKER), [slugSegments]);

  const filePath = useMemo(() => {
    if (isNewFileMode) {
      // For a new file, the path is the parent directory.
      const parentSlug = slugSegments.slice(0, slugSegments.indexOf(NEW_FILE_SLUG_MARKER)).join('/');
      return parentSlug ? `content/${parentSlug}` : 'content';
    }
    // For an existing file, it's the full path.
    return `content/${(slugSegments.length > 0 ? slugSegments.join('/') : 'index')}.md`;
  }, [slugSegments, isNewFileMode]);

  return { siteId, slugSegments, isNewFileMode, filePath };
}

================================================================================

File: features/editor/hooks/useFileContent.ts
// src/features/editor/hooks/useFileContent.ts
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/EditorContext';
import * as localSiteFs from '@/core/services/localFileSystem.service'; // <-- This is now USED
import { parseMarkdownString } from '@/lib/markdownParser'; // <-- This is now USED
import { slugify } from '@/lib/utils';
import { toast } from 'sonner'; // <-- This is now USED
import type { MarkdownFrontmatter } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig'; // <-- This is now USED

export type FileStatus = 'initializing' | 'loading' | 'ready' | 'not_found';

/**
 * Manages the state of a single content file: loading it from storage
 * and handling in-memory state changes for its frontmatter and body.
 */
export function useFileContent(siteId: string, filePath: string, isNewFileMode: boolean) {
  const router = useRouter();
  const site = useAppStore(state => state.getSiteById(siteId));
  const { setHasUnsavedChanges } = useEditor();

  const [status, setStatus] = useState<FileStatus>('initializing');
  const [frontmatter, setFrontmatter] = useState<MarkdownFrontmatter | null>(null);
  const [bodyContent, setBodyContent] = useState<string>('');
  const [slug, setSlug] = useState('');

  useEffect(() => {
    const loadData = async () => {
      if (!site?.manifest) { // <-- Check for manifest to ensure site is at least partially loaded
        setStatus('loading');
        return;
      }

      if (isNewFileMode) {
        setFrontmatter({
          title: '',
          layout: DEFAULT_PAGE_LAYOUT_PATH, // <-- USED HERE
          date: new Date().toISOString().split('T')[0],
        });
        setBodyContent('# Start Writing...'); // <-- 'setBodyContent' IS USED HERE
        setSlug('');
      } else {
        const rawContent = await localSiteFs.getContentFileRaw(siteId, filePath); // <-- USED HERE
        if (rawContent === null) {
          setStatus('not_found');
          toast.error(`Content not found for this URL.`); // <-- USED HERE
          router.push(`/sites/${siteId}/edit`);
          return;
        }
        const { frontmatter: fm, content } = parseMarkdownString(rawContent); // <-- USED HERE
        setFrontmatter(fm);
        setBodyContent(content);
        setSlug(filePath.split('/').pop()?.replace('.md', '') || '');
      }
      setStatus('ready');
      setHasUnsavedChanges(false);
    };

    loadData();
  }, [site?.manifest, filePath, isNewFileMode, siteId, router, setHasUnsavedChanges]);

  const onContentModified = useCallback(() => {
    setHasUnsavedChanges(true);
  }, [setHasUnsavedChanges]);

  const handleFrontmatterChange = useCallback((update: Partial<MarkdownFrontmatter>) => {
    setFrontmatter(prev => {
      if (!prev) return null;
      const newFm = { ...prev, ...update };
      if (isNewFileMode && update.title !== undefined) {
        setSlug(slugify(update.title));
      }
      return newFm;
    });
    onContentModified();
  }, [isNewFileMode, onContentModified]);

  return {
    status,
    site,
    frontmatter,
    bodyContent,
    slug,
    setSlug,
    handleFrontmatterChange,
    onContentModified,
  };
}

================================================================================

File: features/editor/hooks/useFilePersistence.ts
// src/features/editor/hooks/useFilePersistence.ts
'use client';

import { useCallback, useEffect, useRef, useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/EditorContext';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';
import { toast } from 'sonner';
import type { MarkdownFrontmatter } from '@/types';
import { useUnloadPrompt } from './useUnloadPrompt';

interface PersistenceParams {
  siteId: string;
  filePath: string;
  isNewFileMode: boolean;
  frontmatter: MarkdownFrontmatter | null;
  slug: string;
  getEditorContent: () => string;
}

/**
 * Handles all "write" operations for a file: saving, autosaving, and deleting.
 */
export function useFilePersistence({
  siteId,
  filePath,
  isNewFileMode,
  frontmatter,
  slug,
  getEditorContent,
}: PersistenceParams) {
  const router = useRouter();
  const { addOrUpdateContentFile, deleteContentFileAndState } = useAppStore.getState();
  const { hasUnsavedChanges, setHasUnsavedChanges, setSaveState, registerSaveAction } = useEditor();
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [isInitialSaveCompleted, setInitialSaveCompleted] = useState(!isNewFileMode);
  
  const handleSave = useCallback(async () => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);

    if (!frontmatter) throw new Error("Frontmatter not ready for saving.");
    if (!frontmatter.title.trim()) {
        toast.error("A title is required before saving.");
        throw new Error("A title is required.");
    }

    const markdownBody = getEditorContent();
    const finalPath = isNewFileMode ? `${filePath}/${slug.trim()}.md`.replace('//', '/') : filePath;
    const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);

    await addOrUpdateContentFile(siteId, finalPath, rawMarkdown);

    if (isNewFileMode && !isInitialSaveCompleted) {
      setInitialSaveCompleted(true);
      const newEditPath = finalPath.replace(/^content\//, '').replace(/\.md$/, '');
      router.replace(`/sites/${siteId}/edit/content/${newEditPath}`);
    }
  }, [frontmatter, getEditorContent, isNewFileMode, filePath, slug, addOrUpdateContentFile, siteId, isInitialSaveCompleted, router]);

  const handleDelete = useCallback(async () => {
    if (isNewFileMode || !frontmatter) return;
    try {
      await deleteContentFileAndState(siteId, filePath);
      toast.success(`Page "${frontmatter.title}" deleted.`);
      router.push(`/sites/${siteId}/edit`);
    } catch (error) {
      toast.error(`Failed to delete page: ${(error as Error).message}`);
    }
    // --- FIX 2: Remove store action from dependency array ---
  }, [isNewFileMode, frontmatter, deleteContentFileAndState, siteId, filePath, router]);

  // Register the save action with the EditorContext
  useEffect(() => {
    registerSaveAction(handleSave);
  }, [handleSave, registerSaveAction]);

  // Autosave effect now correctly uses the hasUnsavedChanges from the context
  useEffect(() => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);
    const canAutosave = !isNewFileMode || isInitialSaveCompleted;
    if (hasUnsavedChanges && canAutosave) {
      autosaveTimeoutRef.current = setTimeout(async () => {
        setSaveState('saving');
        try {
          await handleSave();
          setHasUnsavedChanges(false);
          setSaveState('saved');
          setTimeout(() => setSaveState('no_changes'), 2000);
        } catch (error) {
          console.error("Autosave failed:", error);
          setSaveState('idle');
        }
      }, AUTOSAVE_DELAY);
    }
    return () => { if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current); };
  }, [hasUnsavedChanges, isNewFileMode, isInitialSaveCompleted, handleSave, setSaveState, setHasUnsavedChanges]);

  // Hook to prompt user before unload
  useUnloadPrompt(isNewFileMode && hasUnsavedChanges && !isInitialSaveCompleted);

  return { handleDelete };
}

================================================================================

File: components/publishing/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { Label } from '@/core/components/ui/label';

interface MarkdownEditorProps {
  initialValue: string;
  // onContentChange is now used primarily by the parent to trigger its own state updates
  onContentChange: (markdown: string) => void;
}

// The ref now needs to expose a method to get the current content
export interface MarkdownEditorRef {
  getMarkdown: () => string;
}

const MarkdownEditor = forwardRef<MarkdownEditorRef, MarkdownEditorProps>(
  ({ initialValue, onContentChange }, ref) => {
    // We'll manage the textarea's value with local state
    const [content, setContent] = useState(initialValue);

    // If the initialValue prop changes from the parent (e.g., loading a new file),
    // we update the local state.
    useEffect(() => {
      setContent(initialValue);
    }, [initialValue]);

    // Expose a function for the parent component to get the current content
    useImperativeHandle(ref, () => ({
      getMarkdown: () => {
        return content;
      },
    }));

    // This handler updates both local state and informs the parent of a change
    const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
      const newContent = event.target.value;
      setContent(newContent);
      onContentChange(newContent); // Let the parent know things have changed
    };

    return (
      <div className="space-y-2 h-full">
      <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400">
            Content
          </Label>
      <textarea
        id="content-body"
        value={content}
        onChange={handleChange}
        placeholder="Start writing your Markdown here..."
        className="w-full h-full bg-background 
                   text-base font-mono leading-relaxed resize-none 
                   focus:ring-2 focus:ring-ring focus:outline-none"
      />
      </div>
    );
  }
);

MarkdownEditor.displayName = 'MarkdownEditor';
export default MarkdownEditor;

================================================================================

File: components/publishing/LeftSidebar.tsx
// src/components/publishing/LeftSidebar.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useMemo, useCallback, useEffect, useState } from 'react';

import { useAppStore } from '@/core/state/useAppStore';
import { useUIStore } from '@/core/state/uiStore';
import { Button } from '@/core/components/ui/button';
import FileTree from '@/features/editor/components/FileTree';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
// Import the renamed dialog for creating collection pages
import CreateCollectionPageDialog from '@/features/editor/components/CreateCollectionPageDialog';

import type { StructureNode } from '@/types';
import { cn } from '@/lib/utils';
import { Home, FilePlus, LayoutGrid } from 'lucide-react';
import { DndContext, DragEndEvent, useDroppable } from '@dnd-kit/core';
import { Link } from '@/core/components/ui/link';

export default function LeftSidebar() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;

  // --- UI State Hooks ---
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const toggleLeftSidebar = useUIStore((state) => state.sidebar.toggleLeftSidebar);
  const isDesktop = useUIStore((state) => state.screen.isDesktop);

  // --- App State Hooks ---
  const site = useAppStore((state) => state.getSiteById(siteId));
  const { updateManifest, moveNode } = useAppStore.getState();

  // --- Local State for Active Path ---
  const [activePath, setActivePath] = useState<string | undefined>();

  // This memoized value now gets ALL top-level pages. The old 'collection' filter is gone.
  const topLevelPages = useMemo(() => {
    return site?.manifest.structure.filter((node: StructureNode) => !node.path.includes('/', 'content/'.length)) || [];
  }, [site?.manifest.structure]);

  // Determine the currently active file path from the URL
  useEffect(() => {
    if (!site?.manifest) return;
    const contentSlug = pathname.substring(pathname.indexOf('/edit/content/') + 14).replace(/\/$/, '') || 'index';
    setActivePath(`content/${contentSlug}.md`);
  }, [pathname, site?.manifest]);

  // Callback for when the FileTree component reports a reordering
  const handleStructureChange = useCallback((reorderedPages: StructureNode[]) => {
      if (!site) return;
      // We rebuild the manifest from the reordered top-level pages.
      // This is simpler as we no longer need to merge back a separate collections array.
      const newManifest = { ...site.manifest, structure: reorderedPages };
      updateManifest(siteId, newManifest);
  }, [site, siteId, updateManifest]);

  // Callback for when a drag operation ends over the root droppable area (for un-nesting)
  const handleDragEndInSidebar = (event: DragEndEvent) => {
    const { over, active } = event;
    if (over && over.id === '__sidebar_root_droppable__') {
      const draggedNodePath = active.id as string;
      moveNode(siteId, draggedNodePath, null);
    }
  };

  const onCreationComplete = () => {
    if (!isDesktop) toggleLeftSidebar();
  };

  const { setNodeRef: setRootDroppableRef, isOver } = useDroppable({
    id: '__sidebar_root_droppable__',
  });

  const unnestDropZoneStyle = isOver ? 'bg-blue-50 dark:bg-blue-900/30 ring-2 ring-blue-500 ring-inset' : '';

  if (!site) return null;

  return (
    <>
      {/* Mobile overlay */}
      {!isDesktop && (
        <div
          onClick={toggleLeftSidebar}
          className={cn('fixed inset-0 z-40 bg-black/60 transition-opacity', isLeftOpen ? 'opacity-100' : 'pointer-events-none opacity-0')}
        />
      )}

      <DndContext onDragEnd={handleDragEndInSidebar}>
        <div className="flex h-full flex-col">
          {/* --- Header with Create Buttons --- */}
          <div className="flex shrink-0 items-center justify-between border-b p-2">
            <h3 className="px-2 text-sm font-semibold uppercase tracking-wider text-muted-foreground">
              Site Content
            </h3>
            <div className="flex items-center gap-1">
              {/* Button to create a new Collection Page */}
              <CreateCollectionPageDialog siteId={siteId} onComplete={onCreationComplete}>
                  <Button variant="ghost" className='size-7 p-1' title="New Collection Page">
                      <LayoutGrid className="h-4 w-4" />
                  </Button>
              </CreateCollectionPageDialog>
              {/* Button to create a new Standard Page */}
              <NewPageDialog siteId={siteId} onComplete={onCreationComplete}>
                  <Button variant="ghost" className='size-7 p-1' title="New Standard Page">
                      <FilePlus className="h-4 w-4" />
                  </Button>
              </NewPageDialog>
            </div>
          </div>

          {/* --- Main File Tree Area --- */}
          <div
            ref={setRootDroppableRef}
            className={cn("flex-grow overflow-y-auto p-2 transition-colors", unnestDropZoneStyle)}
          >
            {topLevelPages.length > 0 ? (
              <FileTree
                  nodes={topLevelPages}
                  contentFiles={site.contentFiles || []}
                  baseEditPath={`/sites/${siteId}/edit`}
                  activePath={activePath}
                  onStructureChange={handleStructureChange}
              />
            ) : (
              <div className="px-2 py-4 text-xs text-center text-muted-foreground italic">
                <p>No pages created yet.</p>
                <p className="mt-2">Drag a nested page here to make it top-level.</p>
              </div>
            )}
          </div>

          {/* --- Footer Link --- */}
          <div className="mt-auto shrink-0 border-t p-2">
              <Button variant="ghost" asChild className="w-full justify-start gap-2">
                  <Link href="/sites">
                      <Home className="h-4 w-4" /> App Dashboard
                  </Link>
              </Button>
          </div>
        </div>
      </DndContext>
    </>
  );
}

================================================================================

File: components/publishing/SchemaDrivenForm.tsx
'use client';

import Form from '@rjsf/shadcn';
import validator from '@rjsf/validator-ajv8';
import { 
  RJSFSchema, 
  UiSchema, 
  FieldTemplateProps, 
  ObjectFieldTemplateProps, 
  RegistryWidgetsType,
  FormContextType
 } from '@rjsf/utils';
import { Label } from '@/core/components/ui/label';


// --- Props Definition ---
interface SchemaDrivenFormProps<T = unknown> {
  schema: RJSFSchema;
  uiSchema?: UiSchema;
  formData: object;
  onFormChange: (data: object) => void;
  liveValidate?: boolean;
  widgets?: RegistryWidgetsType<T>;
  formContext?: FormContextType & T; // <-- Use the official type and our generic
}



// --- Custom Field Template (for better layout and labels) ---
function CustomFieldTemplate(props: FieldTemplateProps) {
  const { id, classNames, label, help, required, description, errors, children, schema } = props;

  if (props.hidden) {
    return <div className="hidden">{children}</div>;
  }
  
  const isCheckbox = schema.type === 'boolean' && (props.uiSchema?.['ui:widget'] === 'checkbox' || props.uiSchema?.['ui:widget'] === undefined);

  if (isCheckbox) {
      return <div className={classNames}>{children}</div>
  }

  return (
    <div className={classNames}>
      {label && (
        <Label htmlFor={id} className="block text-sm font-medium mb-1">
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}
      
      {description}
      
      {children}
      
      {errors}
      
      {help}
    </div>
  );
}

// --- Custom Object Field Template (for overall form layout) ---
function CustomObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  return (
    <div>
        {props.description && <p className="text-sm text-muted-foreground">{props.description}</p>}
        <div className="mt-4">
            {props.properties.map(element => (
                <div key={element.name} className="mb-4">
                    {element.content}
                </div>
            ))}
        </div>
    </div>
  );
}

// --- Custom Submit Button Template (to hide it) ---
// FIXED: The 'props' parameter was defined but never used, so it has been removed.
function HideSubmitButton() {
    return null;
}

/**
 * A reusable component that dynamically generates a form from a given JSON Schema.
 * It uses react-jsonschema-form with a shadcn/ui theme for a consistent look and feel.
 */
export default function SchemaDrivenForm<T>({ 
  schema, 
  uiSchema, 
  formData, 
  onFormChange, 
  liveValidate = false,
  widgets,
  formContext 
}: SchemaDrivenFormProps<T>) {

  const safeFormData = formData || {};

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={safeFormData}
      validator={validator}
      onChange={(e) => onFormChange(e.formData)}
      liveValidate={liveValidate}
      showErrorList={false}
      widgets={widgets}
      formContext={formContext}
      
      templates={{
        FieldTemplate: CustomFieldTemplate,
        ObjectFieldTemplate: CustomObjectFieldTemplate,
        ButtonTemplates: {
            SubmitButton: HideSubmitButton,
        }
      }}
    />
  );
}

================================================================================

File: components/publishing/GroupedFrontmatterFields.tsx
// src/components/publishing/GroupedFrontmatterFields.tsx
'use client';

import { useMemo } from 'react';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import SchemaDrivenForm from './SchemaDrivenForm';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/core/components/ui/accordion";

interface Group {
  title: string;
  fields: string[];
}
type StrictUiSchema = UiSchema & { 'ui:groups'?: Group[] };

interface GroupedFrontmatterFormProps {
  schema: RJSFSchema;
  uiSchema?: StrictUiSchema;
  formData: Record<string, unknown>;
  onFormChange: (newData: Record<string, unknown>) => void;
}

function createSubSchema(originalSchema: RJSFSchema, fields: string[]): RJSFSchema {
  const subSchema: RJSFSchema = { ...originalSchema, properties: {}, required: originalSchema.required?.filter(field => fields.includes(field)) };
  if (!subSchema.properties) subSchema.properties = {};
  for (const field of fields) {
    if (originalSchema.properties && originalSchema.properties[field]) {
      subSchema.properties[field] = originalSchema.properties[field];
    }
  }
  return subSchema;
}

export default function GroupedFrontmatterForm({
  schema,
  uiSchema,
  formData,
  onFormChange,
}: GroupedFrontmatterFormProps) {
  
  const { groups, ungroupedFields } = useMemo(() => {
    const definedGroups = uiSchema?.['ui:groups'] || [];
    const allSchemaFields = Object.keys(schema.properties || {});
    const fieldsInGroups = new Set(definedGroups.flatMap(g => g.fields));
    const remainingFields = allSchemaFields.filter(f => !fieldsInGroups.has(f));
    return { groups: definedGroups, ungroupedFields: remainingFields };
  }, [schema, uiSchema]);

  // FIXED: The handler now accepts the event from rjsf and extracts the formData.
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onFormChange(event.formData || {});
  };

  if (!schema.properties || Object.keys(schema.properties).length === 0) {
    return <p className="text-sm text-muted-foreground">This layout has no configurable fields.</p>;
  }

  return (
    <div className="border-t">
      <Accordion type="multiple" defaultValue={groups.map(g => g.title)} className="w-full">
        {groups.map((group) => {
          if (group.fields.length === 0) return null;
          return (
            <AccordionItem value={group.title} key={group.title}>
              <AccordionTrigger>{group.title}</AccordionTrigger>
              <AccordionContent className="pt-4">
                <SchemaDrivenForm
                  schema={createSubSchema(schema, group.fields)}
                  formData={formData}
                  onFormChange={handleChange}
                />
              </AccordionContent>
            </AccordionItem>
          );
        })}
      </Accordion>

      {ungroupedFields.length > 0 && (
        <div className="">
            <Accordion type='single' collapsible>

<AccordionItem value="item-1">                <AccordionTrigger>
                  Fields
                </AccordionTrigger>
                <AccordionContent>
<SchemaDrivenForm
            schema={createSubSchema(schema, ungroupedFields)}
            formData={formData}
            onFormChange={handleChange}
          />
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </div>
      )}
    </div>
  );
}

================================================================================

File: components/layout/ThreeColumnLayout.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';
import EditorHeader from '@/features/editor/components/EditorHeader';

interface ThreeColumnLayoutProps {
  leftSidebar: ReactNode;
  rightSidebar: ReactNode;
  children: ReactNode;
}

export default function ThreeColumnLayout({ leftSidebar, rightSidebar, children }: ThreeColumnLayoutProps) {
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const isRightOpen = useUIStore((state) => state.sidebar.isRightOpen);

  return (
    <div className="flex h-screen w-full flex-col bg-muted/20">
      <EditorHeader />
      
      {/* This is now the positioning context for all three columns */}
      <div className="relative flex-1 overflow-hidden">
        
        {/* --- START OF FIX --- */}
        
        {/* Left Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 left-0 z-20 h-full w-72 border-r bg-background transition-transform duration-300 ease-in-out',
            isLeftOpen ? 'translate-x-0' : '-translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {leftSidebar}
          </div>
        </aside>

        {/* Main Content: The layout is now controlled by padding */}
        <main
          className={cn(
            'h-full overflow-y-auto transition-all duration-300 ease-in-out',
            // When left sidebar is open, add left padding
            isLeftOpen ? 'lg:pl-72' : 'lg:pl-0',
            // When right sidebar is open, add right padding
            isRightOpen ? 'lg:pr-80' : 'lg:pr-0'
          )}
        >
          {children}
        </main>

        {/* Right Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 right-0 z-10 h-full w-80 border-l bg-background transition-transform duration-300 ease-in-out',
            isRightOpen ? 'translate-x-0' : 'translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {rightSidebar}
          </div>
        </aside>

        {/* --- END OF FIX --- */}
      </div>
    </div>
  );
}

================================================================================

File: lib/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { Input } from 'gray-matter'; // Import GrayMatterOption and Input
//import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { MarkdownFrontmatter, ParsedMarkdownFile } from '@/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Signum focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: lib/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: lib/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: lib/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { LocalSiteData, ParsedMarkdownFile, Manifest } from '@/types';
import { parseMarkdownString } from './markdownParser';
import { flattenStructureToPages } from '../core/services/fileTree.service';

async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const url = new URL(filePath, baseUrl).href;
  const response = await fetch(url, { cache: 'no-store' });
  if (!response.ok) {
    throw new Error(`Fetch failed for ${url}: ${response.statusText}`);
  }
  return response.text();
}

/**
 * Fetches and reconstructs an entire remote Signum site into the LocalSiteData format.
 * It fetches the manifest, then fetches all content files listed within it.
 * @param remoteSiteUrl The base URL of the remote Signum site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json, which is now the single source of truth.
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_signum/manifest.json');
    const manifest: Manifest = JSON.parse(manifestString);

    if (!manifest || !manifest.siteId || !manifest.structure) {
        throw new Error("Invalid manifest structure fetched from remote site.");
    }
    
    // 2. Collect all unique file paths from the manifest structure.
    const allPageNodes = flattenStructureToPages(manifest.structure);
    const contentFilePaths = [...new Set(allPageNodes.map(node => node.path))];

    // 3. Fetch all content files in parallel.
    const contentFilesPromises = contentFilePaths.map(async (path) => {
        try {
            const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, `_signum/${path}`);
            const { frontmatter, content } = parseMarkdownString(rawMarkdown);
            const slug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
            return { slug, path, frontmatter, content };
        } catch (error) {
            console.warn(`Could not fetch or parse content file: ${path}`, error);
            return null; // Return null on failure for this specific file
        }
    });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];

    // 4. Construct the final LocalSiteData object.
    const finalSiteData: LocalSiteData = {
      siteId: `remote-${manifest.siteId}`, // Prefix to distinguish in local state
      manifest: manifest,
      contentFiles: validContentFiles,
    };

    return finalSiteData;

  } catch (error) {
    console.error(`CRITICAL ERROR fetching remote site data for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

