FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: node_modules, ios, public
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html
================================================================================

File: types/index.ts
// src/types/index.ts

export interface NavItem {
  type: 'page' | 'collection' | 'folder';
  path: string; // The FULL path from content root, e.g., "about/team"
  order: number;
  children?: NavItem[];
}

export interface SiteConfigFile {
  title: string;
  description: string;
  author?: string;
  font_family?: 'serif' | 'sans-serif' | 'monospace';
  theme?: 'light' | 'dark' | 'auto';
  primary_color?: string;

  collections?: Array<{
    path: string;
    nav_label?: string;
    description?: string;
    sort_by?: string;
    sort_order?: 'asc' | 'desc';
  }>;
  nav_items?: NavItem[];
}

export interface MarkdownFrontmatter {
  title: string;
  date?: string;
  summary?: string;
  tags?: string[];
  status?: 'draft' | 'published';
  [key: string]: unknown;
}

export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

export interface LocalSiteData {
  siteId: string;
  config: SiteConfigFile;
  contentFiles: ParsedMarkdownFile[];
}

export interface AppState {
  sites: LocalSiteData[];
  addSite: (site: LocalSiteData) => Promise<void>;
  updateSiteConfig: (siteId: string, config: SiteConfigFile) => Promise<void>;
  updateSiteStructure: (siteId: string, navItems: NavItem[]) => Promise<void>;
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string, isNewFile?: boolean) => Promise<boolean>;
  deleteSiteAndState: (siteId: string) => Promise<void>;
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
}

export interface NavLinkItem {
  href: string;
  label: string;
  iconName?: string;
  isActive?: boolean;
  iconComponent?: React.ElementType;
  children?: NavLinkItem[];
}

export interface ManifestEntry {
  type: 'page' | 'collection_index';
  status: 'draft' | 'published';
  sourcePath: string;
  htmlPath: string;
  url: string;
  title?: string;
  date?: string;
  slug: string;
}

export interface Manifest {
  siteId: string;
  generatorVersion: string;
  config: SiteConfigFile;
  entries: ManifestEntry[];
}

================================================================================

File: app/layout.tsx
// src/app/layout.tsx
'use client'; 

import { useEffect, useState, Suspense } from 'react';
import { useAppStore } from '@/stores/useAppStore';
import Navbar from '@/components/core/Navbar'; 
import Footer from '@/components/core/Footer';   
import './globals.css'; 
import { Toaster } from "@/components/ui/sonner"; 
import { ThemeProvider } from "@/components/core/ThemeProvider"; 

// Loading component to show during initialization or suspense
function AppLoadingIndicator() { // CORRECTED: Ensure it returns JSX
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading Signum...</p>
      </div>
    </div>
  ); // <<< MISSING RETURN WAS HERE
}


export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true); 
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]); 

  const showLoading = clientMounted && !isInitialized;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Signum - Decentralized Publishing</title>
        {/* Ensure no stray characters or whitespace directly in <head> */}
      </head>
      <body>
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
          <div className="flex flex-col min-h-screen bg-background text-foreground">
            {showLoading ? (
              <AppLoadingIndicator /> // Now correctly used
            ) : (
              <>
                <Navbar />
                <main className="flex-grow container mx-auto px-4 py-8 sm:px-6 lg:px-8"> 
                  <Suspense fallback={<AppLoadingIndicator />}>
                    {children}
                  </Suspense>
                </main>
                <Footer />
              </>
            )}
          </div>
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================================================================================

File: app/page.tsx
// src/app/page.tsx
'use client';

import Link from 'next/link';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';
import { PlusCircle, Edit3, Eye, Trash2, FilePlus2, ExternalLink } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog"; // Assuming shadcn/ui
import { toast } from "sonner";
//import { useRouter } from 'next/navigation';

export default function HomePageDashboard() {
  const sites = useAppStore((state) => state.sites);
  const deleteSiteAndState = useAppStore((state) => state.deleteSiteAndState);
  const isInitialized = useAppStore((state) => state.isInitialized);
  //const router = useRouter();


  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

  if (!isInitialized) {
    // This state should ideally be handled by the RootLayout's loading indicator
    return (
        <div className="flex items-center justify-center h-screen">
            <p>Loading sites...</p>
        </div>
    );
  }

  return (
    <div className="container mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-8 gap-4">
        <h1 className="text-3xl font-bold text-foreground">My Signum Sites (Local)</h1>
        <Button asChild size="lg">
          <Link href="/create-site">
            <FilePlus2 className="mr-2 h-5 w-5" /> Create New Site
          </Link>
        </Button>
      </div>

      {sites.length === 0 ? (
        <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
          <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
          <p className="text-muted-foreground mb-4">
            You haven&apos;t created any sites. Click Create New Site to get started.
          </p>
          <Button asChild>
            <Link href="/create-site">
                <PlusCircle className="mr-2 h-4 w-4" /> Start Creating
            </Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {sites.map((site) => (
            <div 
                key={site.siteId} 
                className="bg-card border border-border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between"
            >
              <div>
                <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.config.title}>
                  {site.config.title || "Untitled Site"}
                </h2>
                <p className="text-sm text-muted-foreground mb-1 line-clamp-2" title={site.config.description}>
                  {site.config.description || 'No description provided.'}
                </p>
                <p className="text-xs text-muted-foreground mb-4 break-all" title={site.siteId}>
                  ID: {site.siteId}
                </p>
              </div>
              <div className="mt-4 flex flex-col sm:flex-row sm:justify-start gap-2">
                <Button variant="outline" size="sm" asChild className="flex-1 sm:flex-none">
                  <Link href={`/${site.siteId}`} target="_blank" rel="noopener noreferrer">
                    <Eye className="mr-2 h-4 w-4" /> View
                  </Link>
                </Button>
                <Button variant="default" size="sm" asChild className="flex-1 sm:flex-none">
                  <Link href={`/edit/${site.siteId}`}>
                     <Edit3 className="mr-2 h-4 w-4" /> Edit
                  </Link>
                </Button>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" size="sm" className="flex-1 sm:flex-none">
                      <Trash2 className="mr-2 h-4 w-4" /> Delete
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This action cannot be undone. This will permanently delete the site
                        {site.config.title || 'this site'} and all its content from your local storage.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() => handleDeleteSite(site.siteId, site.config.title || 'Untitled Site')}
                        className="bg-destructive hover:bg-destructive/90 text-destructive-foreground"
                      >
                        Yes, delete site
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </div>
            </div>
          ))}
        </div>
      )}
       <footer className="mt-12 text-center text-sm text-muted-foreground">
        <p>Signum Local Client v0.1.0</p>
        <p>
          <Link href="https://github.com/your-repo/signum-client" target="_blank" rel="noopener noreferrer" className="hover:text-primary transition-colors">
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
      </footer>
    </div>
  );
}

================================================================================

File: app/globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: app/sites/[siteId]/layout.tsx
// src/app/(browsing)/[siteId]/layout.tsx
'use client';

import Link from 'next/link';
import { useParams, usePathname } from 'next/navigation';
import { useEffect, useState, useMemo } from 'react';
import * as localSiteFs from '@/lib/localSiteFs';
import { fetchRemoteSiteData } from '@/lib/remoteSiteFetcher';
import type { LocalSiteData, ParsedMarkdownFile, NavLinkItem as NavLinkItemType } from '@/types'; // Use NavLinkItemType
import { Home, ExternalLink, Menu, X, FileText as FileTextIcon, Columns as ColumnsIcon } from 'lucide-react'; // Aliased icons
import { Button } from '@/components/ui/button';
import { parseSiteIdentifier, type ParsedSiteIdentifier } from '@/lib/browsingUtils';
import { cn } from '@/lib/utils';

// NavLinkItem is now imported from '@/types'

export default function SiteBrowsingLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const params = useParams();
  const pathname = usePathname();

  const [siteData, setSiteData] = useState<LocalSiteData | null | undefined>(undefined);
  const [isLoading, setIsLoading] = useState(true);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [parsedIdentifier, setParsedIdentifier] = useState<ParsedSiteIdentifier | null>(null);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  const siteIdParamValue = useMemo(() => params.siteId as string, [params.siteId]);

  useEffect(() => {
    const localParsedResult = parseSiteIdentifier(siteIdParamValue);

    if (!localParsedResult || (localParsedResult.isRemote && !localParsedResult.remoteBaseUrl)) {
      setParsedIdentifier(null); setIsLoading(false); setSiteData(null);
      setErrorMessage(localParsedResult?.isRemote ? `Invalid remote site URL: ${localParsedResult.cleanedIdOrUrl}` : "Site ID invalid.");
      return;
    }
    setParsedIdentifier(localParsedResult);

    let mounted = true;
    setIsLoading(true); setSiteData(undefined); setErrorMessage(null);

    async function fetchLayoutData(validParsedResult: ParsedSiteIdentifier) {
      let fetchedSiteData: LocalSiteData | null = null;
      if (validParsedResult.isRemote && validParsedResult.remoteBaseUrl) {
        fetchedSiteData = await fetchRemoteSiteData(validParsedResult.remoteBaseUrl);
        if (!fetchedSiteData && mounted) setErrorMessage(`Failed to fetch remote: ${validParsedResult.remoteBaseUrl}.`);
      } else if (!validParsedResult.isRemote) {
        fetchedSiteData = await localSiteFs.getSiteById(validParsedResult.effectiveSiteId);
        if (!fetchedSiteData && mounted) setErrorMessage(`Local site "${validParsedResult.effectiveSiteId}" not found.`);
      }
      if (!mounted) return;
      setSiteData(fetchedSiteData);
      setIsLoading(false);
    }
    if (localParsedResult) {
        fetchLayoutData(localParsedResult);
    }
    return () => { mounted = false; };
  }, [siteIdParamValue]);


  const navLinks: NavLinkItemType[] = useMemo(() => {
    if (!siteData?.contentFiles || !parsedIdentifier) return [];

    const links: NavLinkItemType[] = [];
    const topLevelPageSlugs = new Set<string>();
    const folderInfo: Record<string, { count: number, files: ParsedMarkdownFile[], representativeFile?: ParsedMarkdownFile }> = {};

    siteData.contentFiles.forEach(file => {
      if (file.frontmatter.draft || file.frontmatter.status === 'draft') return;

      const relativePath = file.path.replace(/^content\//, '');
      const pathParts = relativePath.split('/');

      if (pathParts.length === 1 && relativePath.endsWith('.md') && relativePath !== 'index.md') {
        const slug = pathParts[0].replace(/\.md$/, '');
        topLevelPageSlugs.add(slug);
        if (!folderInfo[slug]) folderInfo[slug] = { count: 0, files: [] };
        folderInfo[slug].files.push(file);
        folderInfo[slug].representativeFile = file;
      } else if (pathParts.length > 1 && pathParts[0] !== '') {
        const folderSlug = pathParts[0];
        if (!folderInfo[folderSlug]) {
          folderInfo[folderSlug] = { count: 0, files: [] };
        }
        if (relativePath.endsWith('.md')) {
            folderInfo[folderSlug].count++;
            folderInfo[folderSlug].files.push(file);
            if(relativePath === `${folderSlug}/index.md` || !folderInfo[folderSlug].representativeFile) {
                folderInfo[folderSlug].representativeFile = file;
            }
        }
      }
    });

    const homeHref = `/${parsedIdentifier.rawParam}`;
    links.push({ href: homeHref, label: "Home", iconComponent: Home, isActive: pathname === homeHref || pathname === `${homeHref}/` });

    topLevelPageSlugs.forEach(slug => {
        if (folderInfo[slug] && folderInfo[slug].count === 0 && folderInfo[slug].representativeFile) { 
            const fileForTitle = folderInfo[slug].representativeFile!;
            const href = `/${parsedIdentifier.rawParam}/${slug}`;
            links.push({
                href,
                label: fileForTitle.frontmatter.title || slug.charAt(0).toUpperCase() + slug.slice(1),
                iconComponent: FileTextIcon,
                isActive: pathname === href,
            });
        }
    });
    
    Object.entries(folderInfo).forEach(([folderSlug, info]) => {
      if (topLevelPageSlugs.has(folderSlug) && info.count === 0) return; 

      if (info.count > 0 && info.representativeFile) { 
        const href = `/${parsedIdentifier.rawParam}/${folderSlug}`;
        let label = folderSlug.charAt(0).toUpperCase() + folderSlug.slice(1);
        const indexFileInFolder = info.files.find(f => f.path === `content/${folderSlug}/index.md`);
        if (indexFileInFolder?.frontmatter.title) {
            label = indexFileInFolder.frontmatter.title;
        } else if (siteData.config.collections?.find(c => c.path === folderSlug)?.nav_label) {
            label = siteData.config.collections.find(c => c.path === folderSlug)!.nav_label!;
        } else if (info.count === 1 && info.files[0]?.frontmatter.title) {
            label = info.files[0].frontmatter.title;
        }
        
        links.push({
          href,
          label,
          iconComponent: ColumnsIcon,
          isActive: pathname === href || pathname.startsWith(`${href}/`),
        });
      }
    });
    
    const uniqueLinks = Array.from(new Map(links.map(link => [link.href, link])).values());

    return uniqueLinks.sort((a, b) => {
        if (a.label === "Home") return -1;
        if (b.label === "Home") return 1;
        return a.label.localeCompare(b.label);
    });

  }, [siteData, parsedIdentifier, pathname]);

  if (isLoading) { return <div className="p-4 text-center">Loading site layout...</div>; }
  if (!siteData || !parsedIdentifier) { return <div className="p-4 text-center">{errorMessage || "Site not found or error loading layout."}</div>;}

  const siteConfig = siteData.config;
  const currentDisplaySiteId = parsedIdentifier.rawParam;

  const SiteNavMenu = ({ isMobile }: { isMobile?: boolean }) => (
    <>
      {navLinks.map(link => {
        const IconComp = link.iconComponent;
        return (
            <Button 
            variant="ghost" 
            size="sm" 
            asChild 
            key={link.href}
            className={cn(
                "justify-start",
                isMobile ? "w-full text-base py-3" : "md:w-auto",
                link.isActive && "bg-accent text-accent-foreground hover:bg-accent/90"
            )}
            >
            <Link href={link.href} title={link.label} passHref onClick={() => setIsMobileMenuOpen(false)}>
                {IconComp && <IconComp className={cn("h-4 w-4 shrink-0", isMobile ? "mr-3" : "mr-1.5")} />}
                <span>{link.label}</span>
            </Link>
            </Button>
        );
      })}
    </>
  );

  return (
    <div className="flex flex-col min-h-screen bg-background text-foreground">
      <header className="sticky top-16 md:top-0 z-30 w-full border-b bg-background/80 backdrop-blur-md supports-[backdrop-filter]:bg-background/60">
        <div className="container flex h-16 items-center">
          <Link href={`/${currentDisplaySiteId}`} className="flex items-center space-x-2 mr-auto" onClick={() => setIsMobileMenuOpen(false)}>
            <span className="text-xl font-semibold text-foreground truncate hover:text-primary transition-colors">
              {siteConfig?.title || parsedIdentifier.cleanedIdOrUrl}
            </span>
            {parsedIdentifier.isRemote && parsedIdentifier.remoteBaseUrl && (
                <a href={parsedIdentifier.remoteBaseUrl} target="_blank" rel="noopener noreferrer" title={`Open original remote site: ${parsedIdentifier.remoteBaseUrl}`} className="ml-1 flex-shrink-0">
                    <ExternalLink className="h-4 w-4 text-muted-foreground hover:text-primary" />
                </a>
            )}
          </Link>
          
          <nav className="hidden md:flex items-center space-x-1">
            <SiteNavMenu />
          </nav>

          <div className="md:hidden ml-2">
            <Button variant="ghost" size="icon" onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)} aria-label="Toggle menu">
              {isMobileMenuOpen ? <X className="h-6 w-6" /> : <Menu className="h-6 w-6" />}
            </Button>
          </div>
        </div>
         {isMobileMenuOpen && (
          <div className="md:hidden border-t bg-background shadow-lg">
            <nav className="container flex flex-col space-y-1 py-3">
              <SiteNavMenu isMobile={true} />
            </nav>
          </div>
        )}
      </header>
      
      <main className="flex-grow w-full">
        {children}
      </main>
      
      <footer className="border-t bg-muted/10 py-6 text-center">
        <p className="text-sm text-muted-foreground">
          Viewing: {siteConfig?.title || parsedIdentifier.cleanedIdOrUrl} ({parsedIdentifier.isRemote ? "Remote" : "Local"})
        </p>
         <Link href="/" className="mt-1 inline-block text-sm text-primary hover:underline">
            Back to Signum Dashboard
          </Link>
      </footer>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/page.tsx
// src/app/sites/[siteId]/posts/new/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { usePosts } from '@/hooks/use-posts';
import { useSites } from '@/hooks/use-sites';
import { Button } from '@/components/ui/button';
import { MarkdownEditor } from '@/components/content/markdown-editor';
import { 
  ArrowLeftIcon, 
  EyeIcon, 
  BookmarkIcon,
  RocketLaunchIcon,
  ClockIcon,
  TagIcon,
  
} from '@heroicons/react/24/outline';
import Link from 'next/link';

interface PageProps {
  params: { siteId: string };
}

export default function NewPostPage({ params }: PageProps) {
  const router = useRouter();
  const { createPost } = usePosts();
  const { sites } = useSites();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [isDraft, setIsDraft] = useState(true);
  const [autoSaveStatus, setAutoSaveStatus] = useState<'saved' | 'saving' | 'unsaved'>('saved');
  
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    summary: '',
    tags: '',
    allow_likes: true,
    slug: '',
  });

  const [errors, setErrors] = useState<Record<string, string>>({});
  
  // Get current site info
  const currentSite = sites.find(s => s.id === params.siteId);

  // Auto-generate slug from title
  useEffect(() => {
    if (formData.title && !formData.slug) {
      const generatedSlug = formData.title
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .trim();
      setFormData(prev => ({ ...prev, slug: generatedSlug }));
    }
  }, [formData.title, formData.slug]);

  // Auto-save functionality
  useEffect(() => {
    if (!formData.title && !formData.content) return;

    setAutoSaveStatus('saving');
    const timeoutId = setTimeout(() => {
      // In a real app, this would save to IndexedDB or localStorage
      localStorage.setItem(`draft-${params.siteId}`, JSON.stringify(formData));
      setAutoSaveStatus('saved');
    }, 2000);

    return () => clearTimeout(timeoutId);
  }, [formData, params.siteId]);

  // Load draft from localStorage on mount
  useEffect(() => {
    const savedDraft = localStorage.getItem(`draft-${params.siteId}`);
    if (savedDraft) {
      try {
        const draftData = JSON.parse(savedDraft);
        setFormData(draftData);
        setAutoSaveStatus('unsaved');
      } catch (error) {
        console.error('Failed to load draft:', error);
      }
    }
  }, [params.siteId]);

  const validateForm = () => {
    const newErrors: Record<string, string> = {};

    if (!formData.title.trim()) {
      newErrors.title = 'Title is required';
    }

    if (!formData.content.trim()) {
      newErrors.content = 'Content is required';
    }

    if (formData.slug && !/^[a-z0-9-]+$/.test(formData.slug)) {
      newErrors.slug = 'Slug can only contain lowercase letters, numbers, and hyphens';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (saveAsDraft = true) => {
    if (!validateForm()) return;
    if (isSubmitting) return;

    setIsSubmitting(true);
    try {
      const postData = {
        title: formData.title.trim(),
        content: formData.content.trim(),
        summary: formData.summary.trim() || generateSummary(formData.content),
        tags: formData.tags.split(',').map(tag => tag.trim()).filter(Boolean),
        allow_likes: formData.allow_likes,
        slug: formData.slug || generateSlugFromTitle(formData.title),
        draft: saveAsDraft,
      };

      const newPost = await createPost(params.siteId, postData);
      
      // Clear the draft from localStorage
      localStorage.removeItem(`draft-${params.siteId}`);
      
      // Redirect to the new post
      router.push(`/sites/${params.siteId}/posts/${newPost.id}`);
    } catch (error) {
      console.error('Failed to create post:', error);
      alert('Failed to create post. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const generateSummary = (content: string): string => {
    // Remove markdown syntax and get first 150 characters
    const plainText = content
      .replace(/#{1,6}\s+/g, '') // Remove headers
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold
      .replace(/\*(.*?)\*/g, '$1') // Remove italic
      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Remove links, keep text
      .replace(/`([^`]+)`/g, '$1') // Remove inline code
      .replace(/\n+/g, ' ') // Replace newlines with spaces
      .trim();

    return plainText.length > 150 
      ? plainText.substring(0, 150) + '...'
      : plainText;
  };

  const generateSlugFromTitle = (title: string): string => {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim();
  };

  const handleInputChange = (field: string, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    setAutoSaveStatus('unsaved');
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }));
    }
  };

  const isValid = formData.title.trim() && formData.content.trim();

  if (!currentSite) {
    return (
      <div className="p-6">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-gray-900 mb-2">Site Not Found</h1>
          <p className="text-gray-600 mb-4">The site you&apos;re looking for doesn&apos;t exist.</p>
          <Link href="/sites">
            <Button>Back to Sites</Button>
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      {/* Header */}
      <div className="mb-8">
        <Link 
          href={`/sites/${params.siteId}`}
          className="inline-flex items-center text-sm text-gray-600 hover:text-gray-900 mb-4"
        >
          <ArrowLeftIcon className="h-4 w-4 mr-1" />
          Back to {currentSite.config.title}
        </Link>
        
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">New Post</h1>
            <p className="text-gray-600 mt-2">
              Create a new post for your site.
            </p>
          </div>
          
          <div className="flex items-center space-x-3">
            {/* Auto-save status */}
            <div className="flex items-center space-x-2 text-sm text-gray-500">
              <ClockIcon className="h-4 w-4" />
              <span>
                {autoSaveStatus === 'saved' && 'Draft saved'}
                {autoSaveStatus === 'saving' && 'Saving...'}
                {autoSaveStatus === 'unsaved' && 'Unsaved changes'}
              </span>
            </div>
            
            <Button
              variant="outline"
              onClick={() => setShowPreview(!showPreview)}
              className="flex items-center space-x-2"
            >
              <EyeIcon className="h-4 w-4" />
              <span>{showPreview ? 'Hide Preview' : 'Preview'}</span>
            </Button>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        {/* Main content */}
        <div className={`${showPreview ? 'lg:col-span-2' : 'lg:col-span-3'}`}>
          <div className="space-y-6">
            {/* Post metadata */}
            <div className="bg-white rounded-lg border border-gray-200 p-6">
              <div className="space-y-4">
                <div>
                  <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
                    Title *
                  </label>
                  <input
                    type="text"
                    id="title"
                    value={formData.title}
                    onChange={(e) => handleInputChange('title', e.target.value)}
                    className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                      errors.title ? 'border-red-300' : 'border-gray-300'
                    }`}
                    placeholder="Enter your post title"
                  />
                  {errors.title && (
                    <p className="mt-1 text-sm text-red-600">{errors.title}</p>
                  )}
                </div>
                
                <div>
                  <label htmlFor="slug" className="block text-sm font-medium text-gray-700 mb-1">
                    URL Slug
                  </label>
                  <div className="flex items-center">
                    <span className="text-sm text-gray-500 mr-2">
                      {currentSite.config.hosting.canonical_url}/posts/
                    </span>
                    <input
                      type="text"
                      id="slug"
                      value={formData.slug}
                      onChange={(e) => handleInputChange('slug', e.target.value)}
                      className={`flex-1 px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                        errors.slug ? 'border-red-300' : 'border-gray-300'
                      }`}
                      placeholder="auto-generated-from-title"
                    />
                  </div>
                  {errors.slug && (
                    <p className="mt-1 text-sm text-red-600">{errors.slug}</p>
                  )}
                  <p className="text-sm text-gray-500 mt-1">
                    Leave empty to auto-generate from title
                  </p>
                </div>
                
                <div>
                  <label htmlFor="summary" className="block text-sm font-medium text-gray-700 mb-1">
                    Summary
                  </label>
                  <textarea
                    id="summary"
                    rows={2}
                    value={formData.summary}
                    onChange={(e) => handleInputChange('summary', e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Brief summary of your post (optional)"
                  />
                  <p className="text-sm text-gray-500 mt-1">
                    If left empty, a summary will be generated from your content.
                  </p>
                </div>
                
                <div>
                  <label htmlFor="tags" className="block text-sm font-medium text-gray-700 mb-1">
                    Tags
                  </label>
                  <div className="flex items-center space-x-2">
                    <TagIcon className="h-5 w-5 text-gray-400" />
                    <input
                      type="text"
                      id="tags"
                      value={formData.tags}
                      onChange={(e) => handleInputChange('tags', e.target.value)}
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder="technology, tutorial, opinion"
                    />
                  </div>
                  <p className="text-sm text-gray-500 mt-1">
                    Separate tags with commas
                  </p>
                </div>
                
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    id="allow_likes"
                    checked={formData.allow_likes}
                    onChange={(e) => handleInputChange('allow_likes', e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label htmlFor="allow_likes" className="ml-2 text-sm text-gray-700">
                    Allow likes on this post
                  </label>
                </div>
              </div>
            </div>

            {/* Content editor */}
            <div className="bg-white rounded-lg border border-gray-200 p-6">
              <label className="block text-sm font-medium text-gray-700 mb-4">
                Content *
              </label>
              <MarkdownEditor
                value={formData.content}
                onChange={(value) => handleInputChange('content', value)}
                height="500px"
                className={errors.content ? 'border-red-300' : ''}
              />
              {errors.content && (
                <p className="mt-2 text-sm text-red-600">{errors.content}</p>
              )}
            </div>
          </div>
        </div>

        {/* Preview sidebar */}
        {showPreview && (
          <div className="lg:col-span-1">
            <div className="sticky top-6">
              <div className="bg-white rounded-lg border border-gray-200 p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Preview</h3>
                
                <div className="space-y-4">
                  {formData.title && (
                    <div>
                      <h1 className="text-xl font-bold text-gray-900">
                        {formData.title}
                      </h1>
                      <p className="text-sm text-gray-500 mt-1">
                        {new Date().toLocaleDateString()}
                      </p>
                    </div>
                  )}
                  
                  {formData.tags && (
                    <div className="flex flex-wrap gap-1">
                      {formData.tags.split(',').map(tag => tag.trim()).filter(Boolean).map((tag) => (
                        <span
                          key={tag}
                          className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800"
                        >
                          {tag}
                        </span>
                      ))}
                    </div>
                  )}
                  
                  {formData.summary && (
                    <p className="text-sm text-gray-600 italic">
                      {formData.summary}
                    </p>
                  )}
                  
                  {formData.content && (
                    <div className="prose prose-sm max-w-none">
                      <div dangerouslySetInnerHTML={{ 
                        __html: formData.content.substring(0, 500) + (formData.content.length > 500 ? '...' : '')
                      }} />
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Action bar */}
      <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 p-4 md:pl-64">
        <div className="max-w-4xl mx-auto flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <label className="flex items-center">
              <input
                type="radio"
                name="publish_status"
                checked={isDraft}
                onChange={() => setIsDraft(true)}
                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
              />
              <span className="ml-2 text-sm text-gray-700 flex items-center">
                <BookmarkIcon className="h-4 w-4 mr-1" />
                Save as Draft
              </span>
            </label>
            
            <label className="flex items-center">
              <input
                type="radio"
                name="publish_status"
                checked={!isDraft}
                onChange={() => setIsDraft(false)}
                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
              />
              <span className="ml-2 text-sm text-gray-700 flex items-center">
                <RocketLaunchIcon className="h-4 w-4 mr-1" />
                Publish Now
              </span>
            </label>
          </div>
          
          <div className="flex space-x-3">
            <Link href={`/sites/${params.siteId}`}>
              <Button variant="outline">Cancel</Button>
            </Link>
            
            <Button 
              onClick={() => handleSubmit(isDraft)}
              disabled={isSubmitting || !isValid}
              className="flex items-center space-x-2"
            >
              {isSubmitting ? (
                <div className="h-4 w-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
              ) : isDraft ? (
                <BookmarkIcon className="h-4 w-4" />
              ) : (
                <RocketLaunchIcon className="h-4 w-4" />
              )}
              <span>
                {isSubmitting 
                  ? (isDraft ? 'Saving...' : 'Publishing...') 
                  : (isDraft ? 'Save Draft' : 'Publish Post')
                }
              </span>
            </Button>
          </div>
        </div>
      </div>

      {/* Spacer for fixed action bar */}
      <div className="h-20" />
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/page.tsx
// src/app/(publishing)/edit/[siteId]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import SiteConfigForm from '@/components/publishing/SiteConfigForm';
import { Button } from '@/components/ui/button';
import { SiteConfigFile } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";

export default function EditSiteConfigPage() {
  const router = useRouter(); // Not used in this version, but good to have if needed
  const params = useParams();
  const siteId = params.siteId as string;

  // Selectors for store state and actions
  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateSiteConfigAction = useAppStore(state => state.updateSiteConfig);

  const [currentConfig, setCurrentConfig] = useState<SiteConfigFile | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);


  useEffect(() => {
    if (site?.config) {
      // Deep copy to avoid direct mutation of store state if form changes object references
      setCurrentConfig(JSON.parse(JSON.stringify(site.config)));
      setHasChanges(false); // Reset changes when site data reloads
    }
  }, [site]); // Re-run if the site object from the store changes

  const handleConfigChange = useCallback((newConfig: SiteConfigFile) => {
    setCurrentConfig(newConfig);
    setHasChanges(true);
  }, []);

  const handleSaveConfig = async () => {
    if (currentConfig && siteId) {
      if (!currentConfig.title.trim()) {
        toast.error("Site title cannot be empty.");
        return;
      }
      setIsLoading(true);
      try {
        await updateSiteConfigAction(siteId, currentConfig);
        toast.success('Site configuration saved successfully!');
        setHasChanges(false); // Reset changes after successful save
      } catch (error) {
        console.error("Error saving site configuration:", error);
        toast.error("Failed to save configuration. Please try again.");
      } finally {
        setIsLoading(false);
      }
    }
  };

  if (!site) {
    // This case should ideally be handled by the layout or a loading state from the store
    return <p className="p-4">Loading site data or site not found...</p>;
  }
  if (!currentConfig) {
     return <p className="p-4">Loading configuration...</p>;
  }


  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Edit Site Configuration</h1>
        {/* Optional: Add a "Discard Changes" button */}
      </div>
      <SiteConfigForm initialConfig={currentConfig} onConfigChange={handleConfigChange} />
      <Button 
        onClick={handleSaveConfig} 
        disabled={isLoading || !hasChanges} 
        className="mt-6"
      >
        {isLoading ? 'Saving...' : 'Save Configuration'}
      </Button>
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/layout.tsx
// src/app/(publishing)/edit/[siteId]/layout.tsx
'use client';

import Link from 'next/link';
import { useParams, usePathname, useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';
import { Settings, Eye, Home, PlusCircle, FolderPlus, UploadCloud } from 'lucide-react';
import { buildFileTree, type TreeNode } from '@/lib/fileTreeUtils'; 
import FileTree from '@/components/publishing/FileTree';
import NewCollectionDialog from '@/components/publishing/NewCollectionDialog';
import { useEffect, useMemo, useState, useCallback } from 'react';
import { toast } from 'sonner';
import { exportSiteToZip } from '@/lib/siteExporter';
import { slugify } from '@/lib/utils';
import { NavItem } from '@/types';

const NEW_FILE_SLUG_MARKER = '_new';

const flattenTreeToNavItems = (nodes: TreeNode[]): NavItem[] => {
    const list: NavItem[] = []; // Use const as it's not reassigned
    nodes.forEach((node, index) => {
        const itemPath = node.path.replace('content/', '').replace('.md', '');
        const navItem: NavItem = {
            type: node.type === 'file' ? 'page' : node.type as 'collection' | 'folder',
            path: itemPath,
            order: index,
            children: node.children ? flattenTreeToNavItems(node.children) : [],
        };
        list.push(navItem);
    });
    return list;
};


export default function EditSiteLayout({ children }: { children: React.ReactNode }) {
  const params = useParams();
  const pathname = usePathname();
  const router = useRouter();
  const siteId = params.siteId as string;

  const site = useAppStore((state) => state.getSiteById(siteId));
  const updateSiteStructure = useAppStore((state) => state.updateSiteStructure); // Get correct action
  const [isPublishing, setIsPublishing] = useState(false);
  
  const [localNodes, setLocalNodes] = useState<TreeNode[]>([]);
  const [activePath, setActivePath] = useState<string | undefined>();

  useEffect(() => {
    if (site?.contentFiles && site.config) {
      const builtNodes = buildFileTree(site.config, site.contentFiles);
      setLocalNodes(builtNodes);
    } else {
      setLocalNodes([]);
    }
  }, [site]);

  useEffect(() => {
    const pathSegments = pathname.split('/');
    if (pathname.includes('/collection/')) {
        const collectionName = pathSegments.find((v, i) => pathSegments[i-1] === 'collection');
        if (collectionName) setActivePath(`content/${collectionName}`);
    } else if (pathname.includes('/content/')) {
        const contentPath = pathname.substring(pathname.indexOf('/content/') + 8).replace(/\/$/, '');
        const existingFile = site?.contentFiles.find(f => 
            f.path === `content/${contentPath}.md`
        );
        setActivePath(existingFile?.path);
    } else {
        setActivePath(undefined);
    }
  }, [pathname, site?.contentFiles]);

  const handleStructureChange = useCallback((reorderedNodes: TreeNode[]) => {
      if (!site) return;
      
      setLocalNodes(reorderedNodes);

      const newNavItems = flattenTreeToNavItems(reorderedNodes);
      
      updateSiteStructure(siteId, newNavItems); 
  }, [site, siteId, updateSiteStructure]);


  const handleNavigateToNewFile = (parentPath: string = 'content') => {
    const parentSlugPart = parentPath === 'content' ? '' : parentPath.replace(/^content\/?/, '');
    const newFileRoute = `/edit/${siteId}/content/${parentSlugPart ? parentSlugPart + '/' : ''}${NEW_FILE_SLUG_MARKER}`;
    router.push(newFileRoute.replace(/\/\//g, '/'));
  };
  
  const handleCreateNewCollection = async (name: string, slug: string) => {
    if (!site) return;

    const newCollectionConfig = {
        path: slug, nav_label: name, description: '',
        sort_by: 'date', sort_order: 'desc' as const,
    };
    
    const newNavItem: NavItem = {
        type: 'collection', path: slug,
        order: site.config.nav_items?.length || 0,
    };

    const newConfig = {
        ...site.config,
        collections: [...(site.config.collections || []), newCollectionConfig],
        nav_items: [...(site.config.nav_items || []), newNavItem],
    };
    // CORRECTED: Call the correct state update function
    await updateSiteStructure(siteId, newConfig.nav_items);
    
    toast.success(`Collection "${name}" created!`);
    router.push(`/edit/${siteId}/collection/${slug}`);
  };

  const handlePublishSite = async () => {
    // ... This function is unchanged
    if (!site) {
      toast.error("Site data not found. Cannot publish.");
      return;
    }
    setIsPublishing(true);
    toast.info("Generating site bundle for download...");
    try {
      const blob = await exportSiteToZip(site);
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${slugify(site.config.title || 'signum-site')}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      toast.success("Site bundle downloaded!");
    } catch (error) {
      console.error("Error publishing site to Zip:", error);
      toast.error(`Failed to generate Zip: ${(error as Error).message}`);
    } finally {
        setIsPublishing(false);
    }
  };
  
  const existingCollectionPaths = useMemo(() => site?.config.collections?.map(c => c.path) || [], [site?.config.collections]);

  if (!site) {
    return (
        <div className="flex flex-col items-center justify-center h-screen">
            <p className="mb-2">Loading site editor or site not found...</p>
            <Button variant="link" asChild><Link href="/">Go Home</Link></Button>
        </div>
    );
  }

  const isSiteConfigPageActive = pathname === `/edit/${siteId}/config`;

  return (
    <div className="flex h-screen bg-background overflow-hidden">
      <aside className="w-72 border-r bg-muted/40 p-4 flex flex-col shrink-0">
        <div className="mb-4">
            <h2 className="text-xl font-semibold truncate" title={site.config.title}>
                {site.config.title || 'Site Editor'}
            </h2>
            <p className="text-xs text-muted-foreground truncate" title={siteId}>ID: {siteId}</p>
        </div>

        <nav className="flex flex-col space-y-1 mb-4">
          <Button variant="ghost" asChild className={`justify-start ${isSiteConfigPageActive ? 'bg-accent text-accent-foreground' : ''}`}>
            <Link href={`/edit/${siteId}/config`}>
              <Settings className="mr-2 h-4 w-4" /> Site Config
            </Link>
          </Button>
           <Button variant="ghost" onClick={() => handleNavigateToNewFile('content')} className="justify-start">
              <PlusCircle className="mr-2 h-4 w-4" /> New Content File
            </Button>
            <NewCollectionDialog existingCollectionPaths={existingCollectionPaths} onSubmit={handleCreateNewCollection}>
                <Button variant="ghost" className="w-full justify-start">
                    <FolderPlus className="mr-2 h-4 w-4" /> New Collection
                </Button>
            </NewCollectionDialog>
        </nav>

        <div className="mb-2 flex justify-between items-center">
            <h3 className="text-sm font-semibold px-1">Site Structure</h3>
        </div>
        
        <div className="flex-grow overflow-y-auto pr-1 -mr-1 custom-scrollbar">
          <FileTree 
            nodes={localNodes} 
            baseEditPath={`/edit/${siteId}`}
            activePath={activePath}
            onFileCreate={handleNavigateToNewFile} 
            onStructureChange={handleStructureChange} // CORRECTED: Prop name matches component
          />
        </div>

        <div className="mt-auto space-y-2 pt-4 border-t shrink-0">
            <Button variant="default" onClick={handlePublishSite} disabled={isPublishing} className="w-full justify-start">
              <UploadCloud className="mr-2 h-4 w-4" /> {isPublishing ? 'Publishing...' : 'Publish Site'}
            </Button>
            <Button variant="outline" asChild className="w-full justify-start">
                <Link href={`/${siteId}`} target="_blank" rel="noopener noreferrer">
                    <Eye className="mr-2 h-4 w-4" /> View Site (Live)
                </Link>
            </Button>
            <Button variant="ghost" asChild className="w-full justify-start">
              <Link href="/">
                <Home className="mr-2 h-4 w-4" /> App Dashboard
              </Link>
            </Button>
        </div>
      </aside>
      <div className="flex-1 overflow-y-auto p-6">
        {children}
      </div>
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/page.tsx
// src/app/(publishing)/edit/[siteId]/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page now simply redirects to the config page by default for a site editor.
export default function SiteEditorRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      router.replace(`/edit/${siteId}/config`);
    }
  }, [siteId, router]);

  return (
    <div className="p-6 flex justify-center items-center h-full">
      <p>Redirecting to site configuration...</p>
      {/* You could add a spinner here */}
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/collection/[collectionName]/page.tsx
// src/app/(publishing)/edit/[siteId]/collection/[collectionName]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import { useCallback, useMemo, useState, useEffect } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from 'sonner';
import { FileText, PlusCircle } from 'lucide-react';

export default function EditCollectionPage() {
    const params = useParams();
    const router = useRouter();
    const siteId = params.siteId as string;
    const collectionName = params.collectionName as string;

    const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
    const updateSiteConfig = useAppStore(state => state.updateSiteConfig);

    const collectionPath = `content/${collectionName}`;

    const collectionData = useMemo(() => {
        if (!site) return null;
        const collectionConfig = site.config.collections?.find(c => c.path === collectionName);
        const items = site.contentFiles.filter(f => 
            f.path.startsWith(`${collectionPath}/`) && !f.path.endsWith('/index.md')
        );
        return { config: collectionConfig, items };
    }, [site, collectionName, collectionPath]);

    // Form state
    const [navLabel, setNavLabel] = useState('');
    const [description, setDescription] = useState('');
    const [sortBy, setSortBy] = useState('date');
    const [sortOrder, setSortOrder] = useState('desc');
    
    useEffect(() => {
        if (collectionData?.config) {
            setNavLabel(collectionData.config.nav_label || '');
            setDescription(collectionData.config.description || '');
            setSortBy(collectionData.config.sort_by || 'date');
            setSortOrder(collectionData.config.sort_order || 'desc');
        }
    }, [collectionData]);
    
    const handleSaveChanges = async () => {
        if (!site || !collectionData?.config) {
            toast.error("Cannot save, collection configuration not found.");
            return;
        }

        const newCollections = (site.config.collections || []).map(c => {
            if (c.path === collectionName) {
                return {
                    ...c,
                    nav_label: navLabel.trim() || collectionName,
                    description: description.trim(),
                    sort_by: sortBy,
                    sort_order: sortOrder as 'asc' | 'desc',
                };
            }
            return c;
        });
        
        const newSiteConfig = { ...site.config, collections: newCollections };
        await updateSiteConfig(siteId, newSiteConfig);

        toast.success(`Collection "${collectionName}" updated successfully!`);
    };
    
    if (!site || !collectionData?.config) {
        return <div>Loading collection data or collection not found...</div>;
    }

    const title = navLabel || collectionName.charAt(0).toUpperCase() + collectionName.slice(1);

    return (
        <div className="flex flex-row h-full gap-6">
            <main className="flex-1 flex flex-col">
                <div className="flex justify-between items-center mb-4">
                    <h1 className="text-2xl font-bold">Editing Collection: {title}</h1>
                    <Button asChild>
                        <Link href={`/edit/${siteId}/content/${collectionName}/_new`}>
                            <PlusCircle className="mr-2 h-4 w-4" /> New Item
                        </Link>
                    </Button>
                </div>
                <div className="flex-grow p-4 border rounded-lg bg-background overflow-y-auto">
                    <h2 className="text-lg font-semibold mb-3">Items in this Collection</h2>
                    {collectionData.items.length > 0 ? (
                        <ul className="space-y-2">
                            {collectionData.items.map(item => (
                                <li key={item.path}>
                                    <Link href={`/edit/${siteId}/content/${item.path.replace('content/', '').replace('.md', '')}`} className="flex items-center p-2 rounded-md hover:bg-muted transition-colors">
                                        <FileText className="h-4 w-4 mr-3 text-muted-foreground" />
                                        <span className="font-medium">{item.frontmatter.title || item.slug}</span>
                                        <span className="text-sm text-muted-foreground ml-auto">{item.frontmatter.date}</span>
                                    </Link>
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p className="text-muted-foreground text-center py-8">No items in this collection yet. Click &quot;New Item&quot; to start.</p>
                    )}
                </div>
            </main>

            <aside className="w-80 border-l bg-muted/20 p-4 space-y-6 overflow-y-auto h-full shrink-0">
                <h2 className="text-lg font-semibold border-b pb-2">Collection Settings</h2>
                <div>
                    <Label htmlFor="navLabel">Navigation Label</Label>
                    <Input id="navLabel" value={navLabel} onChange={e => setNavLabel(e.target.value)} placeholder="e.g., Blog Posts" />
                    <p className="text-xs text-muted-foreground mt-1">How this collection appears in the site menu.</p>
                </div>
                <div>
                    <Label htmlFor="description">Listing Page Description</Label>
                    <Textarea id="description" value={description} onChange={e => setDescription(e.target.value)} placeholder="A short description for the top of the collection page." rows={4} />
                </div>
                 <div>
                    <Label>Sort Items By</Label>
                    <div className="flex gap-2 mt-1">
                        <Select value={sortBy} onValueChange={setSortBy}>
                            <SelectTrigger><SelectValue/></SelectTrigger>
                            <SelectContent>
                                <SelectItem value="date">Date</SelectItem>
                                <SelectItem value="title">Title</SelectItem>
                            </SelectContent>
                        </Select>
                        <Select value={sortOrder} onValueChange={setSortOrder}>
                            <SelectTrigger><SelectValue/></SelectTrigger>
                            <SelectContent>
                                <SelectItem value="desc">Descending</SelectItem>
                                <SelectItem value="asc">Ascending</SelectItem>
                            </SelectContent>
                        </Select>
                    </div>
                </div>
                <Button onClick={handleSaveChanges} className="w-full">Save Collection Settings</Button>
            </aside>
        </div>
    );
}

================================================================================

File: app/(publishing)/edit/[siteId]/config/page.tsx
// src/app/(publishing)/edit/[siteId]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation'; // useRouter might be useful later
import { useAppStore } from '@/stores/useAppStore';
import SiteConfigForm from '@/components/publishing/SiteConfigForm';
import { Button } from '@/components/ui/button';
import { SiteConfigFile } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import Link from 'next/link'; // For linking back if site not found

export default function EditSiteConfigPage() {
  const params = useParams();
  const siteId = params.siteId as string; // Get siteId from URL parameters

  // Selectors for store state and actions.
  // Using useCallback for the selector function passed to useAppStore can sometimes
  // help with memoization if the selector itself is complex, but for simple getters,
  // it's often not strictly necessary if the dependencies are handled correctly.
  // Here, siteId is a dependency for the selector.
  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateSiteConfigAction = useAppStore(state => state.updateSiteConfig);
  const isStoreInitialized = useAppStore(state => state.isInitialized);

  // State for the form's current configuration data
  const [currentConfig, setCurrentConfig] = useState<SiteConfigFile | null>(null);
  // State to manage loading status during save operations
  const [isLoading, setIsLoading] = useState(false);
  // State to track if there are unsaved changes in the form
  const [hasChanges, setHasChanges] = useState(false);

  // Effect to initialize or update the form's currentConfig when the site data from the store changes
  // or when the component first mounts with a valid siteId.
  useEffect(() => {
    if (site?.config) {
      // Deep copy the site's config to local state to avoid direct mutation of the store's state.
      // This is crucial if SiteConfigForm or other interactions might modify nested objects.
      setCurrentConfig(JSON.parse(JSON.stringify(site.config)));
      setHasChanges(false); // Reset unsaved changes flag when site data reloads or component mounts
    } else if (isStoreInitialized && !site) {
      // If store is initialized but site not found, setCurrentConfig to null
      // to trigger the "Site not found" message.
      setCurrentConfig(null); 
    }
    // Dependency array: re-run this effect if 'site' object changes or 'isStoreInitialized' changes.
  }, [site, isStoreInitialized]); 

  // Callback to handle changes from the SiteConfigForm component
  const handleConfigChange = useCallback((newConfig: SiteConfigFile) => {
    setCurrentConfig(newConfig);
    setHasChanges(true); // Mark that there are unsaved changes
  }, []); // No dependencies needed if it only sets local state

  // Callback to handle saving the configuration
  const handleSaveConfig = async () => {
    if (currentConfig && siteId) { // Ensure currentConfig and siteId are available
      if (!currentConfig.title || currentConfig.title.trim() === "") {
        toast.error("Site title cannot be empty.");
        return;
      }
      setIsLoading(true); // Set loading state
      try {
        // Call the store action to update the site configuration
        await updateSiteConfigAction(siteId, currentConfig);
        toast.success('Site configuration saved successfully!');
        setHasChanges(false); // Reset unsaved changes flag after successful save
      } catch (error) {
        console.error("Error saving site configuration:", error);
        toast.error("Failed to save configuration. Please try again.");
      } finally {
        setIsLoading(false); // Reset loading state
      }
    } else {
      toast.error("Cannot save: Configuration data is missing.");
    }
  };

  // Render loading state if the store is not yet initialized
  if (!isStoreInitialized) {
    return (
        <div className="p-6 flex justify-center items-center min-h-[calc(100vh-var(--header-height))]">
            <p>Loading site editor...</p> {/* Replace with a spinner */}
        </div>
    );
  }

  // Render "Site not found" if the store is initialized but the site doesn't exist
  // or if currentConfig couldn't be set (e.g., site was deleted).
  if (!site || !currentConfig) {
    return (
      <div className="p-6 text-center">
        <h2 className="text-xl font-semibold mb-4">Site Not Found</h2>
        <p className="text-muted-foreground mb-4">
          The site with ID "{siteId}" could not be found or is no longer available.
        </p>
        <Button asChild variant="outline">
          <Link href="/">Go to Dashboard</Link>
        </Button>
      </div>
    );
  }

  // Render the main form if site and config are loaded
  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center gap-2">
        <h1 className="text-2xl font-bold">Edit Site Configuration</h1>
        {/* You could add a "Last saved" timestamp here if desired */}
      </div>
      
      <SiteConfigForm 
        initialConfig={currentConfig} 
        onConfigChange={handleConfigChange} 
      />
      
      <div className="flex justify-end pt-4">
        <Button 
          onClick={handleSaveConfig} 
          disabled={isLoading || !hasChanges} 
          size="lg"
        >
          {isLoading ? 'Saving...' : 'Save Configuration'}
          {hasChanges && !isLoading && <span className="ml-2 text-xs opacity-70">*</span>}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/content/[[...slug]]/page.tsx
// src/app/(publishing)/edit/[siteId]/content/[[...slug]]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import MarkdownEditor from '@/components/publishing/MarkdownEditor';
import FrontmatterSidebar from '@/components/publishing/FrontmatterSidebar';
import { Button } from '@/components/ui/button';
import type { MarkdownFrontmatter } from '@/types';
import { useEffect, useState, useCallback, useMemo, useRef } from 'react';
import { stringifyToMarkdown } from '@/lib/markdownParser'; // Removed unused: parseMarkdownString
import { slugify } from '@/lib/utils';
import { toast } from "sonner";
import { Trash2, Save, Cloud, AlertCircle, CheckCircle } from 'lucide-react';
// import Link from 'next/link'; // Not used directly in this version of UI
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Link } from '@/components/ui/link';

const NEW_FILE_SLUG_MARKER = '_new';
const AUTOSAVE_DELAY = 2500;

type AutoSaveStatus = "unsaved" | "saving" | "saved" | "error";

export default function EditContentPage() {
  const params = useParams();
  const router = useRouter();
  const siteId = params.siteId as string;
  
  const slugSegments = useMemo(() => (params.slug as string[]) || [], [params.slug]);
  const isNewFileIntent = useMemo(() => slugSegments.includes(NEW_FILE_SLUG_MARKER), [slugSegments]);
  
  const parentPathForNewFile = useMemo(() => {
    if (!isNewFileIntent) return 'content';
    const newMarkerIndex = slugSegments.indexOf(NEW_FILE_SLUG_MARKER);
    return newMarkerIndex > 0 ? `content/${slugSegments.slice(0, newMarkerIndex).join('/')}` : 'content';
  }, [slugSegments, isNewFileIntent]);

  const targetPathForExistingFile = useMemo(() => {
    if (isNewFileIntent) return '';
    const pathParts = slugSegments.filter(s => s !== NEW_FILE_SLUG_MARKER);
    if (pathParts.length === 0 && siteId) return 'content/index.md';
    return `content/${pathParts.join('/')}.md`;
  }, [slugSegments, isNewFileIntent, siteId]);

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const addOrUpdateContentFileAction = useAppStore(state => state.addOrUpdateContentFile);
  const deleteContentFileAction = useAppStore(state => state.deleteContentFileAndState);

  const [currentFrontmatter, setCurrentFrontmatter] = useState<MarkdownFrontmatter | null>(null);
  const [currentBodyContent, setCurrentBodyContent] = useState<string>('');
  const [currentFilePath, setCurrentFilePath] = useState<string>('');
  
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [isNewFileMode, setIsNewFileMode] = useState(false);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [proposedSlugForNewFile, setProposedSlugForNewFile] = useState<string>('');
  const [autoSaveStatus, setAutoSaveStatus] = useState<AutoSaveStatus>("saved");

  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleSaveContent = useCallback(async (isAutosave: boolean = false) => {
    // This function needs access to component state like currentFrontmatter, siteId, etc.
    // So, it's defined inside the component.
    // The dependency array for its own useCallback will be crucial.

    if (!currentFrontmatter || !siteId) {
      if (!isAutosave) toast.error("Cannot save: Critical data is missing.");
      setAutoSaveStatus("error");
      return;
    }
    if (!currentFrontmatter.title || !currentFrontmatter.title.trim()) {
      if (!isAutosave) toast.error("Title is required to save.");
      setAutoSaveStatus(isNewFileMode ? "unsaved" : "error");
      return;
    }

    if (!isAutosave) setIsSaving(true);
    setAutoSaveStatus("saving");

    let filePathToSave = currentFilePath;
    let finalSlug = proposedSlugForNewFile;

    if (isNewFileMode) {
      if (!finalSlug || !finalSlug.trim()) {
        finalSlug = slugify(currentFrontmatter.title);
      }
      if (!finalSlug || !finalSlug.trim()) {
        if (!isAutosave) toast.error("A valid slug could not be generated. Please provide a valid title or manually enter a slug.");
        setAutoSaveStatus("unsaved");
        if (!isAutosave) setIsSaving(false);
        return;
      }
      
      filePathToSave = `${parentPathForNewFile}/${finalSlug}.md`.replace(/\/\//g, '/');
      
      if (site?.contentFiles.some(f => f.path === filePathToSave)) {
        if (!isAutosave) toast.error(`A file named "${finalSlug}.md" already exists. Please choose a different title or slug.`);
        setAutoSaveStatus("error");
        if (!isAutosave) setIsSaving(false);
        return;
      }
    }

    const rawMarkdownToSave = stringifyToMarkdown(currentFrontmatter, currentBodyContent);

    try {
      const success = await addOrUpdateContentFileAction(siteId, filePathToSave, rawMarkdownToSave);
      if (success) {
        if (!isAutosave) toast.success(`Content "${currentFrontmatter.title}" saved successfully!`);
        setHasUnsavedChanges(false);
        setAutoSaveStatus("saved");
        
        if (isNewFileMode) {
          setIsNewFileMode(false);
          setCurrentFilePath(filePathToSave);
          const newEditPathSegments = filePathToSave.replace(/^content\//, '').replace(/\.md$/, '');
          router.replace(`/edit/${siteId}/content/${newEditPathSegments}`);
        }
      } else {
        if (!isAutosave) toast.error("Failed to save: Invalid frontmatter. Check console.");
        setAutoSaveStatus("error");
      }
    } catch (error) {
      console.error("Error saving content:", error);
      if (!isAutosave) toast.error(`Failed to save content: ${(error as Error).message}`);
      setAutoSaveStatus("error");
    } finally {
      if (!isAutosave) setIsSaving(false);
    }
  }, [ // Dependencies for handleSaveContent
    currentFrontmatter, siteId, currentFilePath, proposedSlugForNewFile, isNewFileMode, 
    parentPathForNewFile, site?.contentFiles, currentBodyContent, 
    addOrUpdateContentFileAction, router // Note: `site` can be just `site?.contentFiles` if that's all that's needed
  ]);


  const triggerAutoSave = useCallback(() => {
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }
    if (isNewFileMode && (!currentFrontmatter?.title?.trim() || !proposedSlugForNewFile.trim())) {
        setAutoSaveStatus("unsaved");
        return;
    }
    if (!hasUnsavedChanges && autoSaveStatus !== "error") {
        setAutoSaveStatus("saved");
        return;
    }

    setAutoSaveStatus("unsaved");
    autoSaveTimeoutRef.current = setTimeout(async () => {
      if (isNewFileMode && (!currentFrontmatter?.title?.trim() || !proposedSlugForNewFile.trim())) {
        console.log("Autosave for new file skipped: title or slug not ready.");
        setAutoSaveStatus("unsaved");
        return;
      }
      await handleSaveContent(true);
    }, AUTOSAVE_DELAY);
  }, [ // Dependencies for triggerAutoSave
    isNewFileMode, hasUnsavedChanges, currentFrontmatter?.title, proposedSlugForNewFile, 
    autoSaveStatus, handleSaveContent // Added autoSaveStatus and handleSaveContent
  ]);


  useEffect(() => {
    setIsLoading(true);
    setHasUnsavedChanges(false);
    setAutoSaveStatus("saved");

    if (site) {
      if (isNewFileIntent) {
        setIsNewFileMode(true);
        setCurrentFrontmatter({
          title: '',
          date: new Date().toISOString().split('T')[0],
          status: 'draft',
          summary: '',
          tags: [],
        });
        setCurrentBodyContent('');
        setProposedSlugForNewFile('');
        setCurrentFilePath('');
        setIsLoading(false);
      } else {
        setIsNewFileMode(false);
        const existingFile = site.contentFiles.find(f => f.path === targetPathForExistingFile);
        if (existingFile) {
          const fm = typeof existingFile.frontmatter === 'object' && existingFile.frontmatter !== null 
                       ? existingFile.frontmatter 
                       : { title: existingFile.slug };
          setCurrentFrontmatter(fm as MarkdownFrontmatter);
          setCurrentBodyContent(existingFile.content || '');
          setCurrentFilePath(existingFile.path);
          setProposedSlugForNewFile(existingFile.slug);
        } else {
          toast.error(`File not found: ${targetPathForExistingFile}`);
          setCurrentFrontmatter(null);
          setCurrentBodyContent('');
        }
        setIsLoading(false);
      }
    } else if (useAppStore.getState().isInitialized && siteId) {
        toast.error(`Site with ID ${siteId} not found.`);
        setCurrentFrontmatter(null);
        setIsLoading(false);
    }
  }, [site, siteId, targetPathForExistingFile, isNewFileIntent]);


  useEffect(() => {
    // This effect should run whenever content changes that needs to be autosaved.
    if (!isLoading && (currentFrontmatter || currentBodyContent) && hasUnsavedChanges) {
      triggerAutoSave();
    }
    // Cleanup timeout on component unmount or when dependencies change
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, [currentFrontmatter, currentBodyContent, isLoading, hasUnsavedChanges, triggerAutoSave]);


  const handleFrontmatterChange = useCallback((newFrontmatter: MarkdownFrontmatter) => {
    setCurrentFrontmatter(newFrontmatter);
    setHasUnsavedChanges(true);
    setAutoSaveStatus("unsaved");
    if (isNewFileMode && typeof newFrontmatter.title === 'string') {
        setProposedSlugForNewFile(slugify(newFrontmatter.title));
    }
  }, [isNewFileMode]);

  const handleBodyChange = useCallback((newBody: string) => {
    setCurrentBodyContent(newBody);
    setHasUnsavedChanges(true);
    setAutoSaveStatus("unsaved");
  }, []);

  const handleProposedSlugChange = useCallback((newSlug: string) => {
    if (isNewFileMode) {
        setProposedSlugForNewFile(slugify(newSlug));
        setHasUnsavedChanges(true);
        setAutoSaveStatus("unsaved");
    }
  }, [isNewFileMode]);


  const handleDeleteContentFile = async () => {
    if (isNewFileMode || !currentFilePath || !site || !currentFrontmatter) {
        toast.info("Cannot delete an unsaved new file or if file path is missing.");
        return;
    }
    try {
        await deleteContentFileAction(siteId, currentFilePath);
        toast.success(`File "${currentFrontmatter.title || currentFilePath}" deleted.`);
        router.push(`/edit/${siteId}`); 
    } catch (error) {
        toast.error(`Failed to delete file: ${(error as Error).message}`);
        console.error("Error deleting file:", error);
    }
  };

  const renderAutoSaveIndicator = () => {
    switch (autoSaveStatus) {
      case "saving":
        return <><Cloud className="h-4 w-4 mr-1.5 animate-pulse text-blue-500" /> Saving...</>;
      case "saved":
        return <><CheckCircle className="h-4 w-4 mr-1.5 text-green-500" /> Saved</>;
      case "unsaved":
        return <><Save className="h-4 w-4 mr-1.5 text-amber-500" /> Unsaved changes</>;
      case "error":
        return <><AlertCircle className="h-4 w-4 mr-1.5 text-red-500" /> Save error!</>;
      default:
        return null;
    }
  };

  // MOVED LOADING/ERROR RETURNS HERE, INSIDE THE FUNCTION BODY
  if (isLoading) {
    return <div className="p-6 flex justify-center items-center min-h-[calc(100vh-128px)]"><p>Loading editor...</p></div>;
  }
  if (!currentFrontmatter && !isNewFileMode && !isLoading) {
    return (
        <div className="p-6 text-center">
            <h2 className="text-xl font-semibold mb-4">Content Not Found</h2>
            <p className="text-muted-foreground mb-4">
            The content for path &quot;{targetPathForExistingFile.replace('content/', '')}&quot; could not be loaded.
            </p>
            <Button asChild variant="outline">
                <Link href={`/edit/${siteId}`}>Go to Site Editor Home</Link>
            </Button>
        </div>
    );
  }
   if (!site && siteId && !isLoading) { 
    return <div className="p-6 text-center"><p>Site data for ID &quot;{siteId}&quot; not available.</p></div>;
  }

  return (
    <div className="flex flex-row h-full">
      <main className="flex-1 flex flex-col p-6 pr-0 overflow-hidden">
        <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-2 shrink-0">
          <h1 className="text-xl font-bold truncate">
            {isNewFileMode ? 'Create New Content' : `Edit: ${currentFrontmatter?.title || proposedSlugForNewFile || 'Content'}`}
          </h1>
          <div className="flex items-center gap-2">
            <div className="text-sm text-muted-foreground flex items-center min-w-[120px]">
                {renderAutoSaveIndicator()}
            </div>
            {!isNewFileMode && currentFilePath && currentFrontmatter && (
                <AlertDialog>
                    <AlertDialogTrigger asChild>
                        <Button variant="outline" size="sm" className="text-destructive border-destructive hover:bg-destructive/10 hover:text-destructive focus-visible:ring-destructive/50">
                            <Trash2 className="h-4 w-4 mr-1.5" /> Delete
                        </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent> 
                        <AlertDialogHeader>
                        <AlertDialogTitle>Delete this content file?</AlertDialogTitle>
                        <AlertDialogDescription>
                            Are you sure you want to delete &quot;{currentFrontmatter.title || currentFilePath}&quot;? This action cannot be undone.
                        </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={handleDeleteContentFile} className="bg-destructive hover:bg-destructive/90">
                            Yes, Delete File
                        </AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialog>
            )}
            <Button 
              onClick={() => handleSaveContent(false)}
              disabled={isSaving || (isNewFileMode && (!currentFrontmatter?.title?.trim() || !proposedSlugForNewFile.trim()))}
              size="sm"
              title={isNewFileMode && (!currentFrontmatter?.title?.trim() || !proposedSlugForNewFile.trim()) ? "Enter a title to enable saving" : "Save changes"}
            >
              <Save className="h-4 w-4 mr-1.5" />
              {isSaving ? 'Saving...' : 'Save Now'}
            </Button>
          </div>
        </div>
        {currentFrontmatter && (
             <div className="flex-grow overflow-y-auto">
                <MarkdownEditor
                    key={currentFilePath || 'new-file-editor'}
                    initialValue={currentBodyContent}
                    onChange={handleBodyChange}
                />
            </div>
        )}
         {!currentFrontmatter && isNewFileMode && (
            <div className="flex-grow flex items-center justify-center text-muted-foreground">
                <p>Initializing new content editor...</p>
            </div>
        )}
      </main>
      {currentFrontmatter && (
        <FrontmatterSidebar
            frontmatter={currentFrontmatter}
            onFrontmatterChange={handleFrontmatterChange}
            isNewFileMode={isNewFileMode}
            proposedSlug={proposedSlugForNewFile}
            onProposedSlugChange={handleProposedSlugChange}
        />
      )}
    </div>
  );
}

================================================================================

File: app/(publishing)/create-site/page.tsx
// src/app/(publishing)/create-site/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import { SiteConfigFile, LocalSiteData, ParsedMarkdownFile, MarkdownFrontmatter } from '@/types';
import SiteConfigForm from '@/components/publishing/SiteConfigForm';
import { Button } from '@/components/ui/button';
import { generateSiteId } from '@/lib/utils';
import { toast } from "sonner";

export default function CreateSitePage() {
  const router = useRouter();
  const addSite = useAppStore((state) => state.addSite);

  const [siteConfig, setSiteConfig] = useState<SiteConfigFile>({
    title: '',
    description: '',
    author: '',
    // Initialize new style properties with defaults
    font_family: 'sans-serif',
    theme: 'light',
    primary_color: '#007AFF',
    collections: [],
  });
  const [isLoading, setIsLoading] = useState(false);

  const handleConfigChange = (newConfig: SiteConfigFile) => {
    setSiteConfig(newConfig);
  };

  const handleSubmit = async () => {
    if (!siteConfig.title.trim()) {
      toast.error('Site title is required.');
      return;
    }
    setIsLoading(true);

    const newSiteId = generateSiteId(siteConfig.title);
    const defaultIndexFrontmatter: MarkdownFrontmatter = { title: 'Welcome' };
    const defaultIndexBody = `# Welcome to ${siteConfig.title}\n\nThis is your new site's homepage. Start editing!`;
    
    const defaultIndexFile: ParsedMarkdownFile = {
        slug: 'index',
        path: 'content/index.md',
        frontmatter: defaultIndexFrontmatter,
        content: defaultIndexBody,
    };

    // Construct the config for newSiteData using the spread of siteConfig from state
    // This ensures all fields, including the new top-level style fields, are included.
    const newSiteData: LocalSiteData = {
      siteId: newSiteId,
      config: {
        ...siteConfig, // Spread all current form values
        title: siteConfig.title.trim(), // Ensure title is trimmed
        description: siteConfig.description.trim(), // Ensure description is trimmed
        author: siteConfig.author?.trim() || '', // Handle optional author
        // Ensure collections is an array if not set by form for some reason
        collections: siteConfig.collections || [], 
      },
      contentFiles: [defaultIndexFile],
    };

    try {
      await addSite(newSiteData);
      toast.success(`Site "${siteConfig.title}" created locally!`);
      router.push(`/edit/${newSiteId}/config`);
    } catch (error) {
      console.error("Error creating site:", error);
      toast.error("Failed to create site. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-2xl">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Create New Site</h1>
        <Button onClick={() => router.push('/')} variant="outline">
          Back to Dashboard
        </Button>
      </div>
      <SiteConfigForm initialConfig={siteConfig} onConfigChange={handleConfigChange} />
      <Button onClick={handleSubmit} disabled={isLoading} className="mt-6 w-full sm:w-auto">
        {isLoading ? 'Creating...' : 'Create Site Locally'}
      </Button>
    </div>
  );
}

================================================================================

File: app/(browsing)/[siteId]/layout.tsx
// src/app/(browsing)/[siteId]/layout.tsx
'use client';

import Link from 'next/link';
import { useParams, usePathname } from 'next/navigation';
import { useEffect, useState, useMemo } from 'react';
import * as localSiteFs from '@/lib/localSiteFs';
import { fetchRemoteSiteData } from '@/lib/remoteSiteFetcher';
import { LocalSiteData, ParsedMarkdownFile } from '@/types';
import { Home, ExternalLink, Menu, X, FileText, Columns } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { parseSiteIdentifier, ParsedSiteIdentifier } from '@/lib/browsingUtils';
import { cn } from '@/lib/utils';

interface NavLinkItem {
  href: string;
  label: string;
  icon?: React.ElementType;
  isActive?: boolean;
}

export default function SiteBrowsingLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const params = useParams();
  const pathname = usePathname();

  const [siteData, setSiteData] = useState<LocalSiteData | null | undefined>(undefined);
  // ... (isLoading, errorMessage, parsedIdentifier, isMobileMenuOpen states remain the same) ...
  const [isLoading, setIsLoading] = useState(true);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [parsedIdentifier, setParsedIdentifier] = useState<ParsedSiteIdentifier | null>(null);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  const siteIdParamValue = useMemo(() => params.siteId as string, [params.siteId]);

  useEffect(() => {
    // ... (useEffect for fetching siteData remains the same as the last correct version) ...
    const localParsedResult = parseSiteIdentifier(siteIdParamValue);

    if (!localParsedResult || (localParsedResult.isRemote && !localParsedResult.remoteBaseUrl)) {
      setParsedIdentifier(null); setIsLoading(false); setSiteData(null);
      setErrorMessage(localParsedResult?.isRemote ? `Invalid remote site URL: ${localParsedResult.cleanedIdOrUrl}` : "Site ID invalid.");
      return;
    }
    setParsedIdentifier(localParsedResult);

    let mounted = true;
    setIsLoading(true); setSiteData(undefined); setErrorMessage(null);

    async function fetchLayoutData(validParsedResult: ParsedSiteIdentifier) {
      let fetchedSiteData: LocalSiteData | null = null;
      if (validParsedResult.isRemote && validParsedResult.remoteBaseUrl) {
        fetchedSiteData = await fetchRemoteSiteData(validParsedResult.remoteBaseUrl);
        if (!fetchedSiteData) setErrorMessage(`Failed to fetch remote: ${validParsedResult.remoteBaseUrl}.`);
      } else if (!validParsedResult.isRemote) {
        fetchedSiteData = await localSiteFs.getSiteById(validParsedResult.effectiveSiteId);
        if (!fetchedSiteData) setErrorMessage(`Local site "${validParsedResult.effectiveSiteId}" not found.`);
      }
      if (!mounted) return;
      setSiteData(fetchedSiteData);
      setIsLoading(false);
    }
    fetchLayoutData(localParsedResult);
    return () => { mounted = false; };
  }, [siteIdParamValue]);


  const navLinks: NavLinkItem[] = useMemo(() => {
    if (!siteData?.contentFiles || !parsedIdentifier) return [];

    const links: NavLinkItem[] = [];
    const topLevelPageSlugs = new Set<string>();
    const folderInfo: Record<string, { count: number, files: ParsedMarkdownFile[] }> = {};

    // --- Pass 1: Categorize files and count items in folders ---
    siteData.contentFiles.forEach(file => {
      if (file.frontmatter.draft) return;

      const relativePath = file.path.replace(/^content\//, '');
      const pathParts = relativePath.split('/');

      if (pathParts.length === 1 && relativePath.endsWith('.md') && relativePath !== 'index.md') {
        // Top-level page file (e.g., content/about.md)
        const slug = pathParts[0].replace(/\.md$/, '');
        topLevelPageSlugs.add(slug);
        // Store the file info for later to get title
        if (!folderInfo[slug]) folderInfo[slug] = { count: 0, files: [] }; // Ensure entry exists
        folderInfo[slug].files.push(file);


      } else if (pathParts.length > 1 && pathParts[0] !== '') {
        // File is in a subdirectory (e.g., content/blog/post1.md)
        const folderSlug = pathParts[0];
        if (!folderInfo[folderSlug]) {
          folderInfo[folderSlug] = { count: 0, files: [] };
        }
        if (relativePath.endsWith('.md')) { // Only count markdown files for this logic
            folderInfo[folderSlug].count++;
            folderInfo[folderSlug].files.push(file);
        }
      }
    });

    // --- Pass 2: Generate Nav Links ---
    // Home link
    const homeHref = `/${parsedIdentifier.rawParam}`;
    links.push({ href: homeHref, label: "Home", icon: Home, isActive: pathname === homeHref || pathname === `${homeHref}/` });

    // Top-level page links (that are not folders)
    topLevelPageSlugs.forEach(slug => {
        // Ensure this slug doesn't also represent a folder that would be treated as a collection/page
        if (folderInfo[slug] && folderInfo[slug].count === 0) { // It's a top-level file, not a folder with same name
            const fileForTitle = folderInfo[slug].files[0]; // Should be the page itself
            const href = `/${parsedIdentifier.rawParam}/${slug}`;
            links.push({
            href,
            label: fileForTitle?.frontmatter.title || slug.charAt(0).toUpperCase() + slug.slice(1),
            icon: FileText,
            isActive: pathname === href,
            });
        }
    });
    
    // Folder links (either single page folder or collection)
    Object.entries(folderInfo).forEach(([folderSlug, info]) => {
      if (topLevelPageSlugs.has(folderSlug) && info.count === 0) return; // Already handled as top-level page

      if (info.count > 0) { // It's a folder with content
        const href = `/${parsedIdentifier.rawParam}/${folderSlug}`;
        let label = folderSlug.charAt(0).toUpperCase() + folderSlug.slice(1);
        let icon = Columns; // Default to collection icon

        if (info.count === 1) {
          // If it's a single-page folder, the label might come from that single page's title
          label = info.files[0]?.frontmatter.title || label;
          icon = FileText; // Icon for single page
        }

        links.push({
          href,
          label,
          icon,
          isActive: pathname === href || pathname.startsWith(`${href}/`),
        });
      }
    });
    
    // Remove duplicates that might arise if a top-level page slug is same as a folder slug (folder takes precedence)
    const uniqueLinks = Array.from(new Map(links.map(link => [link.href, link])).values());

    return uniqueLinks.sort((a, b) => {
        if (a.label === "Home") return -1;
        if (b.label === "Home") return 1;
        return a.label.localeCompare(b.label);
    });

  }, [siteData, parsedIdentifier, pathname]);

  // ... (isLoading, error UI, SiteNavMenu, and main return structure remain similar to your last full version)
  if (isLoading) { return <div className="p-4 text-center">Loading site layout...</div>; }
  if (!siteData || !parsedIdentifier) { return <div className="p-4 text-center">{errorMessage || "Site not found or error loading layout."}</div>;}

  const siteConfig = siteData.config;
  const currentDisplaySiteId = parsedIdentifier.rawParam;

  const SiteNavMenu = ({ isMobile }: { isMobile?: boolean }) => (
    <>
      {navLinks.map(link => (
        <Button 
          variant="ghost" 
          size="sm" 
          asChild 
          key={link.href}
          className={cn(
            "justify-start",
            isMobile ? "w-full text-base py-3" : "md:w-auto", // Adjusted for better mobile feel
            link.isActive && "bg-accent text-accent-foreground hover:bg-accent/90"
          )}
        >
          <Link href={link.href} title={link.label} passHref onClick={() => setIsMobileMenuOpen(false)}>
            {link.icon && <link.icon className={cn("h-4 w-4 shrink-0", isMobile ? "mr-3" : "mr-1.5")} />}
            <span>{link.label}</span>
          </Link>
        </Button>
      ))}
    </>
  );

  return (
    <div className="flex flex-col min-h-screen bg-background text-foreground">
      <header className="sticky top-16 md:top-0 z-30 w-full border-b bg-background/80 backdrop-blur-md supports-[backdrop-filter]:bg-background/60">
        <div className="container flex h-16 items-center"> {/* Increased height for better touch targets / spacing */}
          <Link href={`/${currentDisplaySiteId}`} className="flex items-center space-x-2 mr-auto" onClick={() => setIsMobileMenuOpen(false)}>
            <span className="text-xl font-semibold text-foreground truncate hover:text-primary transition-colors">
              {siteConfig?.title || parsedIdentifier.cleanedIdOrUrl}
            </span>
            {parsedIdentifier.isRemote && parsedIdentifier.remoteBaseUrl && (
                <a href={parsedIdentifier.remoteBaseUrl} target="_blank" rel="noopener noreferrer" title={`Open original remote site: ${parsedIdentifier.remoteBaseUrl}`} className="ml-1 flex-shrink-0">
                    <ExternalLink className="h-4 w-4 text-muted-foreground hover:text-primary" />
                </a>
            )}
          </Link>
          
          <nav className="hidden md:flex items-center space-x-1">
            <SiteNavMenu />
          </nav>

          <div className="md:hidden ml-2">
            <Button variant="ghost" size="icon" onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)} aria-label="Toggle menu">
              {isMobileMenuOpen ? <X className="h-6 w-6" /> : <Menu className="h-6 w-6" />}
            </Button>
          </div>
        </div>
         {isMobileMenuOpen && (
          <div className="md:hidden border-t bg-background shadow-lg"> {/* Added background and shadow for mobile menu */}
            <nav className="container flex flex-col space-y-1 py-3">
              <SiteNavMenu isMobile={true} />
            </nav>
          </div>
        )}
      </header>
      
      <main className="flex-grow w-full">
        {children}
      </main>
      
      <footer className="border-t bg-muted/10 py-6 text-center"> {/* Updated bg-muted/10 for subtlety */}
        <p className="text-sm text-muted-foreground">
          Viewing: {siteConfig?.title || parsedIdentifier.cleanedIdOrUrl} ({parsedIdentifier.isRemote ? "Remote" : "Local"})
        </p>
         <Link href="/" className="mt-1 inline-block text-sm text-primary hover:underline">
            Back to Signum Dashboard
          </Link>
      </footer>
    </div>
  );
}

================================================================================

File: app/(browsing)/[siteId]/[[...slug]]/page.tsx
// src/app/(browsing)/[siteId]/[[...slug]]/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useEffect, useState, useMemo } from 'react';
import * as localSiteFs from '@/lib/localSiteFs';
import { fetchRemoteSiteData } from '@/lib/remoteSiteFetcher';
import type { LocalSiteData } from '@/types';
import { Button } from '@/components/ui/button';
import { AlertTriangle } from 'lucide-react';
import { parseSiteIdentifier, type ParsedSiteIdentifier } from '@/lib/browsingUtils';
import Link from 'next/link';
import { cn } from '@/lib/utils';
import { generateNavLinks } from '@/lib/navigationUtils';
import { resolvePageContent, PageType } from '@/lib/pageResolver';
import { renderHeader as renderThemeHeaderString } from '@/themes/default/partials/header';
import { renderFooter as renderThemeFooterString } from '@/themes/default/partials/footer';

enum PageRenderState { Loading, Display, NotFound, Error }

const THEME_WRAPPER_CLASS = "signum-theme-default-wrapper"; // Consistent wrapper class

export default function CatchAllSitePage() {
  const paramsHook = useParams();
  const [siteData, setSiteData] = useState<LocalSiteData | null | undefined>(undefined);
  const [renderState, setRenderState] = useState<PageRenderState>(PageRenderState.Loading);
  const [pageHtmlContent, setPageHtmlContent] = useState<string>("");
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [pageMetaTitle, setPageMetaTitle] = useState<string>("Loading...");
  const [parsedPageIdentifier, setParsedPageIdentifier] = useState<ParsedSiteIdentifier | null>(null);

  const siteIdParamValue = useMemo(() => paramsHook.siteId as string, [paramsHook.siteId]);
  const slugArray = useMemo(() => (paramsHook.slug as string[] | undefined) || [], [paramsHook.slug]);

  useEffect(() => {
    setRenderState(PageRenderState.Loading);
    setPageHtmlContent(""); 
    setErrorMessage(null); 
    setPageMetaTitle("Loading...");

    const localParsedResult = parseSiteIdentifier(siteIdParamValue);
    if (!localParsedResult) {
        setErrorMessage("Invalid site identifier in URL.");
        setRenderState(PageRenderState.Error);
        setPageMetaTitle("Error");
        return;
    }
    setParsedPageIdentifier(localParsedResult);

    async function processAndRenderSiteContent(validParsedResult: ParsedSiteIdentifier) {
      let fetchedSiteData: LocalSiteData | null = null;
      if (validParsedResult.isRemote && validParsedResult.remoteBaseUrl) {
        fetchedSiteData = await fetchRemoteSiteData(validParsedResult.remoteBaseUrl);
        if (!fetchedSiteData) setErrorMessage(`Failed to fetch remote site: ${validParsedResult.remoteBaseUrl}.`);
      } else if (!validParsedResult.isRemote) {
        fetchedSiteData = await localSiteFs.getSiteById(validParsedResult.effectiveSiteId);
        if (!fetchedSiteData) setErrorMessage(`Local site "${validParsedResult.effectiveSiteId}" not found.`);
      }

      if (!fetchedSiteData) {
        setSiteData(null); 
        setRenderState(PageRenderState.Error); 
        setPageMetaTitle("Site Not Found"); 
        return;
      }
      setSiteData(fetchedSiteData);

      // --- Use shared resolvers for content and navigation ---
      const resolution = resolvePageContent(fetchedSiteData, slugArray);
      const siteRootPathForLinks = `/${validParsedResult.rawParam}/`.replace(/\/\//g, '/');
      const navLinks = generateNavLinks(fetchedSiteData, {isStaticExport: false, siteRootPath: siteRootPathForLinks});
      
      const themeHeaderHtml = renderThemeHeaderString(fetchedSiteData.config, navLinks, siteRootPathForLinks);
      const themeFooterHtml = renderThemeFooterString(fetchedSiteData.config);

      switch (resolution.type) {
        case PageType.SinglePage:
        case PageType.CollectionListing:
          setPageHtmlContent(`${themeHeaderHtml}<main class="site-content">${resolution.mainContentHtml}</main>${themeFooterHtml}`);
          setPageMetaTitle(resolution.pageTitle || 'Untitled');
          setRenderState(PageRenderState.Display);
          break;
        
        case PageType.NotFound:
          setRenderState(PageRenderState.NotFound);
          setErrorMessage(resolution.errorMessage || "Page not found.");
          setPageMetaTitle("Page Not Found");
          break;
      }
    }
    processAndRenderSiteContent(localParsedResult);
  }, [siteIdParamValue, slugArray]);

  useEffect(() => {
    if (renderState === PageRenderState.Loading) {
        document.title = "Loading... | Signum";
    } else {
        let title = pageMetaTitle;
        if (siteData?.config?.title) title += ` | ${siteData.config.title}`;
        document.title = title;
    }
  }, [renderState, pageMetaTitle, siteData]);

  const wrapperClasses = [THEME_WRAPPER_CLASS];
  const wrapperStyles: React.CSSProperties = {};

  if (siteData?.config) {
    if (siteData.config.theme === 'dark') wrapperClasses.push('theme-dark');
    else if (siteData.config.theme === 'auto') wrapperClasses.push('theme-auto');
    else wrapperClasses.push('theme-light');

    if (siteData.config.font_family === 'serif') {
      wrapperClasses.push('font-serif');
    } else if (siteData.config.font_family === 'monospace') {
      wrapperClasses.push('font-mono');
    } else {
      wrapperClasses.push('font-sans');
    }
    if (siteData.config.primary_color) {
      wrapperStyles['--primary-color'] = siteData.config.primary_color;
    }
  }
  
  // --- Render logic ---
  if (renderState === PageRenderState.Loading) {
    return <div className="container mx-auto px-4 py-8 flex justify-center items-center min-h-[300px]"><p>Loading content...</p></div>;
  }

  const siteHomeLinkForError = parsedPageIdentifier?.rawParam ? `/${parsedPageIdentifier.rawParam}` : '/';
  if (renderState === PageRenderState.Error || renderState === PageRenderState.NotFound) {
      return (
        <div className="container mx-auto px-4 py-8 sm:px-6 lg:px-8 text-center">
            <div className="flex flex-col items-center">
                <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
                <h1 className="text-2xl font-bold mb-2">{pageMetaTitle}</h1>
                <p className="text-muted-foreground max-w-md">
                    {errorMessage || "The requested content could not be loaded or found."}
                </p>
                <Button asChild variant="outline" className="mt-6">
                    <Link href={siteData ? siteHomeLinkForError : '/'}>
                        {siteData ? 'Go to Site Home' : 'Go to Dashboard'}
                    </Link>
                </Button>
            </div>
        </div>
      );
  }

  return (
    <div 
      className={cn(wrapperClasses)} 
      style={wrapperStyles}
      dangerouslySetInnerHTML={{ __html: pageHtmlContent }}
    />
  );
}

================================================================================

File: stores/useAppStore.ts
// src/stores/useAppStore.ts
import { create } from 'zustand';
import { AppState, LocalSiteData, SiteConfigFile, NavItem } from '@/types'; 
import * as localSiteFs from '@/lib/localSiteFs';

// This is a complex operation and will be a future enhancement.
// For now, we will rely on just updating the config.
const moveFileAndChildren = async (siteId: string, oldPath: string, newPath: string) => {
    console.warn(`File move from ${oldPath} to ${newPath} is not yet fully implemented.`);
    // In a real implementation:
    // 1. Get the file content from the old path.
    // 2. Save it to the new path.
    // 3. Delete the old file.
    // 4. Recursively do this for all children.
};

interface AppStore extends AppState {
  isInitialized: boolean;
  initialize: () => Promise<void>;
}

export const useAppStore = create<AppStore>()(
  (set, get) => ({
    sites: [], 
    isInitialized: false,

    initialize: async () => {
        if (get().isInitialized) return;
        try {
            const sites = await localSiteFs.loadAllSites();
            set({ sites, isInitialized: true });
        } catch (error) {
            console.error("Failed to initialize app store from localSiteFs:", error);
            set({ sites: [], isInitialized: true });
        }
    },

    addSite: async (newSiteData: LocalSiteData) => {
        try {
            await localSiteFs.saveSite(newSiteData);
            set((state) => ({ sites: [...state.sites, newSiteData] }));
        } catch (error) {
            console.error("Failed to add site:", error);
            throw error;
        }
    },

    updateSiteConfig: async (siteId: string, config: SiteConfigFile) => {
        try {
            await localSiteFs.saveSiteConfig(siteId, config);
            set((state) => ({
                sites: state.sites.map((s) => (s.siteId === siteId ? { ...s, config } : s)),
            }));
        } catch (error) {
            console.error(`Failed to update site config for ${siteId}:`, error);
            throw error;
        }
    },
    
    updateSiteStructure: async (siteId: string, newNavItems: NavItem[]) => {
      const site = get().sites.find(s => s.siteId === siteId);
      if (!site) return;
      
      const newConfig = { ...site.config, nav_items: newNavItems };
      await get().updateSiteConfig(siteId, newConfig);
    },

    addOrUpdateContentFile: async (siteId: string, filePath: string, rawMarkdownContent: string, isNewFile: boolean = false): Promise<boolean> => {
      try {
        const savedFile = await localSiteFs.saveContentFile(siteId, filePath, rawMarkdownContent);
        if (!savedFile) return false;

        set((state) => {
          const sitesWithUpdate = state.sites.map((s) => {
            if (s.siteId === siteId) {
              const contentFiles = [...s.contentFiles.filter(f => f.path !== filePath), savedFile];
              
              if (isNewFile) {
                const path = filePath.replace('content/', '').replace('.md', '');
                
                // Determine if this file is a collection item or a page
                const parentPath = path.substring(0, path.lastIndexOf('/'));
                const parentIsCollection = s.config.collections?.some(c => c.path === parentPath) ?? false;

                // Only add to nav_items if it's a Page, not a Collection Item.
                if (!parentIsCollection && !filePath.endsWith('index.md')) {
                  const newNavItem: NavItem = {
                    type: 'page',
                    path: path,
                    order: s.config.nav_items?.length || 0,
                  };
                  const newNavItems = [...(s.config.nav_items || []), newNavItem];
                  const newConfig = { ...s.config, nav_items: newNavItems };
                  
                  localSiteFs.saveSiteConfig(siteId, newConfig);
                  return { ...s, config: newConfig, contentFiles };
                }
              }
              
              return { ...s, contentFiles };
            }
            return s;
          });
          return { sites: sitesWithUpdate };
        });
        return true;
      } catch (error) {
        console.error(`Failed to add/update file ${filePath}:`, error);
        throw error;
      }
    },
    
    deleteSiteAndState: async (siteId: string) => {
        try {
            await localSiteFs.deleteSite(siteId);
            set(state => ({
                sites: state.sites.filter(s => s.siteId !== siteId),
            }));
        } catch (error) {
            console.error(`Failed to delete site ${siteId}:`, error);
            throw error;
        }
    },

    deleteContentFileAndState: async (siteId: string, filePath: string) => {
        try {
            await localSiteFs.deleteContentFile(siteId, filePath);
            // Also remove from nav_items if it exists
            const site = get().sites.find(s => s.siteId === siteId);
            if(site) {
                const pathToDelete = filePath.replace('content/', '').replace('.md', '');
                const newNavItems = site.config.nav_items?.filter(item => item.path !== pathToDelete);
                const newConfig = {...site.config, nav_items: newNavItems};
                await get().updateSiteConfig(siteId, newConfig);
            }
            set(state => ({
                sites: state.sites.map(s => {
                    if (s.siteId === siteId) {
                        return { ...s, contentFiles: s.contentFiles.filter(f => f.path !== filePath) };
                    }
                    return s;
                }),
            }));
        } catch (error) {
            console.error(`Failed to delete content file ${filePath} from site ${siteId}:`, error);
            throw error;
        }
    },

    getSiteById: (siteId: string): LocalSiteData | undefined => {
      return get().sites.find((s) => s.siteId === siteId);
    },
  })
);

================================================================================

File: components/publishing/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useEffect, useRef, useState } from 'react';
import { Textarea } from '@/components/ui/textarea';

interface MarkdownEditorProps {
  initialValue: string;
  onChange: (bodyContent: string) => void;
}

export default function MarkdownEditor({ initialValue, onChange }: MarkdownEditorProps) {
  const [currentValue, setCurrentValue] = useState(initialValue);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    // Only update if initialValue truly differs from currentValue to avoid cursor jumps
    // This is important if parent re-renders frequently but initialValue for editor hasn't changed
    if (initialValue !== currentValue) {
      setCurrentValue(initialValue);
    }
  }, [initialValue, currentValue]); // Added currentValue back as per ESLint, condition handles loops

  const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newValue = event.target.value;
    setCurrentValue(newValue);
    onChange(newValue); 
  };

  const handleKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (event.key === 'Tab' && !event.shiftKey) {
      event.preventDefault();
      const target = event.target as HTMLTextAreaElement;
      const { selectionStart, selectionEnd } = target;
      const tab = '  ';
      
      const newValue = currentValue.substring(0, selectionStart) + tab + currentValue.substring(selectionEnd);
      
      setCurrentValue(newValue);
      onChange(newValue);

      setTimeout(() => {
        if (textareaRef.current) {
          textareaRef.current.selectionStart = textareaRef.current.selectionEnd = selectionStart + tab.length;
        }
      }, 0);
    }
  };

  return (
    <Textarea
      ref={textareaRef}
      value={currentValue}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
      placeholder={
`# Your Main Heading

Start writing your Markdown content here.`}
      className="w-full flex-1 font-mono text-sm min-h-[calc(100%-50px)] 
                 p-4 border rounded-md shadow-sm 
                 focus-visible:ring-1 focus-visible:ring-ring"
      // Adjusted min-height assuming parent provides fixed height for overall editor area
    />
  );
}

================================================================================

File: components/publishing/NewCollectionDialog.tsx
// src/components/publishing/NewCollectionDialog.tsx
'use client';

import { useState, useEffect, type ReactNode } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';

interface NewCollectionDialogProps {
  children: ReactNode; // The trigger button
  existingCollectionPaths: string[];
  onSubmit: (name: string, slug: string) => Promise<void>;
}

export default function NewCollectionDialog({ children, existingCollectionPaths, onSubmit }: NewCollectionDialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');

  // Effect to auto-generate the slug from the collection name
  useEffect(() => {
    if (name) {
      const generatedSlug = slugify(name);
      setSlug(generatedSlug);
    } else {
      setSlug('');
    }
  }, [name]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !slug.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }
    if (existingCollectionPaths.includes(slug)) {
      toast.error(`A collection with the folder name "${slug}" already exists.`);
      return;
    }

    await onSubmit(name, slug);
    
    // Close and reset the dialog
    setIsOpen(false);
    setName('');
    setSlug('');
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
            <DialogHeader>
            <DialogTitle>Create New Collection</DialogTitle>
            <DialogDescription>
                Create a new folder to organize your content. This will appear in your site structure.
            </DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="name" className="text-right">
                Name
                </Label>
                <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="col-span-3"
                placeholder="e.g., Blog Posts"
                autoComplete="off"
                />
            </div>
            <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="slug" className="text-right">
                Folder Name
                </Label>
                <Input
                id="slug"
                value={slug}
                readOnly
                className="col-span-3 bg-muted"
                />
            </div>
            </div>
            <DialogFooter>
                <DialogClose asChild>
                    <Button type="button" variant="outline">Cancel</Button>
                </DialogClose>
                <Button type="submit">Create Collection</Button>
            </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: components/publishing/FileTree.tsx
// src/components/publishing/FileTree.tsx
'use client';

import React, { useState, useMemo } from 'react';
import Link from 'next/link';
import { type TreeNode } from '@/lib/fileTreeUtils';
import { Folder, FileText as FileTextIcon, PlusSquare, GripVertical, ChevronRight, FolderGit2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { DndContext, closestCenter, DragEndEvent } from '@dnd-kit/core';
import { SortableContext, useSortable, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

interface FileTreeProps {
  nodes: TreeNode[];
  baseEditPath: string;
  activePath?: string;
  onFileCreate: (parentPath: string) => void;
  onStructureChange: (nodes: TreeNode[]) => void;
}

interface FileTreeNodeProps extends FileTreeProps {
  node: TreeNode;
}

const SortableNode: React.FC<FileTreeNodeProps> = ({ node, nodes, baseEditPath, activePath, onFileCreate, onStructureChange }) => {
    const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: node.id });
    const [isOpen, setIsOpen] = useState(true);
    
    const style = { transform: CSS.Transform.toString(transform), transition };

    const isFolderType = node.type === 'folder' || node.type === 'collection';

    const href = node.type === 'collection'
        ? `${baseEditPath}/collection/${node.path.replace('content/', '')}`
        : node.type === 'file'
        ? `${baseEditPath}/content/${node.path.replace('content/', '').replace('.md', '')}`
        : '#';

    const isSelected = activePath === node.path || (isFolderType && activePath?.startsWith(node.path));
    const NodeIcon = node.type === 'collection' ? Folder : (node.type === 'folder' ? FolderGit2 : FileTextIcon);

    return (
        <div ref={setNodeRef} style={style} className="flex flex-col">
            <div className="flex items-center group w-full">
                <div {...attributes} {...listeners} className="p-1 cursor-grab touch-none">
                    <GripVertical className="h-4 w-4 text-muted-foreground/50" />
                </div>
                <div className={cn("flex-grow flex items-center py-1.5 pl-1 pr-1 rounded-md hover:bg-muted relative", isSelected && "bg-accent text-accent-foreground")}>
                    {isFolderType && (
                        <ChevronRight className={cn("h-4 w-4 mr-1 shrink-0 transition-transform duration-200 cursor-pointer", isOpen && "rotate-90", !node.children?.length && "invisible")} onClick={() => setIsOpen(!isOpen)} />
                    )}
                    <NodeIcon className={cn("h-4 w-4 shrink-0", isFolderType ? 'text-amber-500' : 'text-sky-500', !isFolderType && 'ml-5')} />
                    
                    <Link href={href} className="truncate flex-grow mx-1.5" title={node.name} onClick={(e) => { if (href === '#') e.preventDefault() }}>
                        {node.name}
                    </Link>

                    <div className="ml-auto hidden group-hover:flex items-center gap-0.5 absolute right-1 top-1/2 -translate-y-1/2 bg-muted p-0.5 rounded shadow-sm">
                        {isFolderType && (
                            <Button variant="ghost" size="icon" className="h-6 w-6" title="New File" onClick={(e) => { e.stopPropagation(); onFileCreate(node.path); }}>
                                <PlusSquare className="h-3.5 w-3.5" />
                            </Button>
                        )}
                    </div>
                </div>
            </div>
            {isFolderType && isOpen && node.children && node.children.length > 0 && (
                <div className="pl-6">
                    <FileTree nodes={node.children} baseEditPath={baseEditPath} activePath={activePath} onFileCreate={onFileCreate} onStructureChange={(newChildren) => {
                        const newParentNode = { ...node, children: newChildren };
                        const newNodes = nodes.map(n => n.id === node.id ? newParentNode : n);
                        onStructureChange(newNodes);
                    }} />
                </div>
            )}
        </div>
    );
};

export default function FileTree({ nodes, baseEditPath, activePath, onFileCreate, onStructureChange }: FileTreeProps) {
  const nodeIds = useMemo(() => nodes.map(n => n.id), [nodes]);

  if (!nodes || nodes.length === 0) {
    return <p className="p-2 text-sm text-muted-foreground">(No content files yet)</p>;
  }

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
        const oldIndex = nodeIds.indexOf(active.id as string);
        const newIndex = nodeIds.indexOf(over.id as string);
        if (oldIndex !== -1 && newIndex !== -1) {
            onStructureChange(arrayMove(nodes, oldIndex, newIndex));
        }
    }
  };

  return (
    <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
        <SortableContext items={nodeIds} strategy={verticalListSortingStrategy}>
            <div className="space-y-0.5">
                {nodes.map(node => (
                    <SortableNode key={node.id} node={node} nodes={nodes} baseEditPath={baseEditPath} activePath={activePath} onFileCreate={onFileCreate} onStructureChange={onStructureChange} />
                ))}
            </div>
        </SortableContext>
    </DndContext>
  );
}

================================================================================

File: components/publishing/SiteConfigForm.tsx
// src/components/publishing/SiteConfigForm.tsx
'use client';

import React, { useCallback } from 'react';
import { SiteConfigFile } from '@/types';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface SiteConfigFormProps {
  initialConfig: SiteConfigFile;
  onConfigChange: (config: SiteConfigFile) => void;
}

export default function SiteConfigForm({ initialConfig, onConfigChange }: SiteConfigFormProps) {
  
  // Generic handler for top-level config fields (including new style fields)
  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    onConfigChange({ 
      ...initialConfig, 
      [name]: value 
    });
  }, [initialConfig, onConfigChange]);

  // Specific handler for Select components which return value directly
  const handleSelectChange = useCallback((name: keyof SiteConfigFile, value: string) => {
    onConfigChange({
      ...initialConfig,
      [name]: value,
    });
  }, [initialConfig, onConfigChange]);


  // Handler specifically for the primary_color text input to ensure it also updates the color picker
  // and for the color picker to update the text input.
  const handlePrimaryColorChange = useCallback((value: string) => {
    onConfigChange({
        ...initialConfig,
        primary_color: value,
    });
  }, [initialConfig, onConfigChange]);


  const currentConfig = initialConfig;

  return (
    <form onSubmit={(e) => e.preventDefault()} className="space-y-6">
      <fieldset className="space-y-4 border p-4 rounded-md">
        <legend className="text-lg font-semibold px-1">General Information</legend>
        <div>
          <Label htmlFor="title" className="block text-sm font-medium text-foreground mb-1">Site Title *</Label>
          <Input
            id="title"
            name="title" // Corresponds to SiteConfigFile key
            value={currentConfig.title || ''}
            onChange={handleChange}
            placeholder="My Awesome Signum Blog"
            required
            className="mt-1 block w-full"
          />
          <p className="text-xs text-muted-foreground mt-1">The main title of your site.</p>
        </div>

        <div>
          <Label htmlFor="description" className="block text-sm font-medium text-foreground mb-1">Site Description</Label>
          <Textarea
            id="description"
            name="description" // Corresponds to SiteConfigFile key
            value={currentConfig.description || ''}
            onChange={handleChange}
            placeholder="A short and catchy description of what your site is about."
            rows={3}
            className="mt-1 block w-full"
          />
           <p className="text-xs text-muted-foreground mt-1">Used for summaries and search engine metadata.</p>
        </div>

        <div>
          <Label htmlFor="author" className="block text-sm font-medium text-foreground mb-1">Author Name</Label>
          <Input
            id="author"
            name="author" // Corresponds to SiteConfigFile key
            value={currentConfig.author || ''}
            onChange={handleChange}
            placeholder="John Doe"
            className="mt-1 block w-full"
          />
          <p className="text-xs text-muted-foreground mt-1">The name of the site author (optional).</p>
        </div>
      </fieldset>

      <fieldset className="space-y-4 border p-4 rounded-md">
        <legend className="text-lg font-semibold px-1">Appearance</legend>
        <div>
          <Label htmlFor="font_family" className="block text-sm font-medium text-foreground mb-1">Font Family</Label>
          <Select
            value={currentConfig.font_family || 'sans-serif'}
            onValueChange={(value) => handleSelectChange('font_family', value)}
          >
            <SelectTrigger id="font_family" className="w-full mt-1">
              <SelectValue placeholder="Select font family" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="sans-serif">Sans Serif (Default)</SelectItem>
              <SelectItem value="serif">Serif</SelectItem>
              <SelectItem value="monospace">Monospace</SelectItem>
            </SelectContent>
          </Select>
          <p className="text-xs text-muted-foreground mt-1">Choose the base font style for your site content.</p>
        </div>

        <div>
          <Label htmlFor="theme" className="block text-sm font-medium text-foreground mb-1">Color Theme</Label>
          <Select
            value={currentConfig.theme || 'light'}
            onValueChange={(value) => handleSelectChange('theme', value)}
          >
            <SelectTrigger id="theme" className="w-full mt-1">
              <SelectValue placeholder="Select color theme" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="light">Light (Default)</SelectItem>
              <SelectItem value="dark">Dark</SelectItem>
              <SelectItem value="auto">System Preference</SelectItem>
            </SelectContent>
          </Select>
          <p className="text-xs text-muted-foreground mt-1">Select the preferred color scheme. &apos;System&apos; will adapt to user&apos;s OS settings.</p>
        </div>
        
        <div>
          <Label htmlFor="primary_color_text_input" className="block text-sm font-medium text-foreground mb-1">Primary Accent Color</Label>
          <div className="flex items-center space-x-2 mt-1">
            <Input
              id="primary_color_text_input"
              name="primary_color" // Corresponds to SiteConfigFile key
              type="text"
              value={currentConfig.primary_color || '#007AFF'}
              onChange={(e) => handlePrimaryColorChange(e.target.value)} // Use dedicated handler
              placeholder="#007AFF"
              className="block w-full"
              pattern="^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$"
            />
            <Input
              id="primary_color_picker" // Different ID for the picker itself
              name="primary_color_picker_input" // Not directly tied to SiteConfigFile key
              type="color"
              value={currentConfig.primary_color || '#007AFF'}
              onChange={(e) => handlePrimaryColorChange(e.target.value)} // Use dedicated handler
              className="h-10 w-12 p-1 cursor-pointer border-input rounded-md"
            />
          </div>
          <p className="text-xs text-muted-foreground mt-1">Choose an accent color (e.g., for links). Use a hex value like #RRGGBB.</p>
        </div>
      </fieldset>
    </form>
  );
}

================================================================================

File: components/publishing/FrontmatterSidebar.tsx
// src/components/publishing/FrontmatterSidebar.tsx
'use client';

import React from 'react';
import type { MarkdownFrontmatter } from '@/types'; // Use 'type' import
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { slugify } from '@/lib/utils';

interface FrontmatterSidebarProps {
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: MarkdownFrontmatter) => void;
  isNewFileMode: boolean;
  proposedSlug: string;
  onProposedSlugChange?: (newSlug: string) => void;
}

export default function FrontmatterSidebar({
  frontmatter,
  onFrontmatterChange,
  isNewFileMode,
  proposedSlug,
  onProposedSlugChange,
}: FrontmatterSidebarProps) {
  
  const handleChange = (
    field: keyof MarkdownFrontmatter, 
    value: string | string[] | undefined // Allow undefined for optional fields like date
  ) => {
    const newFrontmatterData = { ...frontmatter, [field]: value };
    
    if (field === 'title' && isNewFileMode && onProposedSlugChange && typeof value === 'string') {
        onProposedSlugChange(slugify(value));
    }
    
    onFrontmatterChange(newFrontmatterData);
  };

  const handleTagsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const tagsString = e.target.value;
    const tagsArray = tagsString.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
    handleChange('tags', tagsArray);
  };

  return (
    <aside className="w-80 border-l bg-muted/20 p-4 space-y-6 overflow-y-auto h-full shrink-0">
      <h2 className="text-lg font-semibold border-b pb-2">Metadata</h2>

      <div>
        <Label htmlFor="fm-title" className="block text-sm font-medium mb-1">Title *</Label>
        <Input
          id="fm-title"
          type="text"
          value={frontmatter.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          placeholder="Enter post title"
          required
          className="mt-1"
        />
      </div>

      <div>
        <Label htmlFor="fm-slug" className="block text-sm font-medium mb-1">Slug (URL part)</Label>
        <Input
          id="fm-slug"
          type="text"
          value={proposedSlug}
          readOnly={!isNewFileMode || !onProposedSlugChange}
          onChange={(e) => isNewFileMode && onProposedSlugChange && onProposedSlugChange(e.target.value)}
          placeholder="auto-generated-from-title"
          className="mt-1 bg-muted/50 border-dashed"
        />
        {isNewFileMode && <p className="text-xs text-muted-foreground mt-1">Auto-generated. Editable before first save.</p>}
        {!isNewFileMode && <p className="text-xs text-muted-foreground mt-1">Slug is fixed after creation.</p>}
      </div>

      <div>
        <Label htmlFor="fm-date" className="block text-sm font-medium mb-1">Date</Label>
        <Input
          id="fm-date"
          type="date"
          value={frontmatter.date ? frontmatter.date.split('T')[0] : ''}
          onChange={(e) => handleChange('date', e.target.value ? new Date(e.target.value).toISOString().split('T')[0] : undefined)}
          className="mt-1"
        />
         <p className="text-xs text-muted-foreground mt-1">Format: YYYY-MM-DD. Defaults to today for new files.</p>
      </div>

      <div>
        <Label htmlFor="fm-status" className="block text-sm font-medium mb-1">Status</Label>
        <Select
          value={frontmatter.status || 'draft'}
          onValueChange={(value) => handleChange('status', value as 'draft' | 'published')}
        >
          <SelectTrigger id="fm-status" className="w-full mt-1">
            <SelectValue placeholder="Select status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="draft">Draft</SelectItem>
            <SelectItem value="published">Published</SelectItem>
          </SelectContent>
        </Select>
      </div>
      
      <div>
        <Label htmlFor="fm-summary" className="block text-sm font-medium mb-1">Summary</Label>
        <Textarea
          id="fm-summary"
          value={frontmatter.summary || ''}
          onChange={(e) => handleChange('summary', e.target.value)}
          placeholder="A brief summary of the content (optional)."
          rows={3}
          className="mt-1"
        />
      </div>

      <div>
        <Label htmlFor="fm-tags" className="block text-sm font-medium mb-1">Tags</Label>
        <Input
          id="fm-tags"
          type="text"
          value={(frontmatter.tags || []).join(', ')}
          onChange={handleTagsChange}
          placeholder="tag1, another-tag, keyword"
          className="mt-1"
        />
        <p className="text-xs text-muted-foreground mt-1">Comma-separated list of tags.</p>
      </div>
    </aside>
  );
}

================================================================================

File: components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: components/ui/link.tsx
/**
 * TODO: Update this component to use your client-side framework's link
 * component. We've provided examples of how to do this for Next.js, Remix, and
 * Inertia.js in the Catalyst documentation:
 *
 * https://catalyst.tailwindui.com/docs#client-side-router-integration
 */

import * as Headless from '@headlessui/react'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: { href: string } & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <a {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})


================================================================================

File: components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: components/core/Navbar.tsx
// src/components/core/Navbar.tsx
'use client';

import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation'; // Import useRouter
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input'; // Import Input
import React, { useState } from 'react';

// ... (NavLink component remains the same) ...
const NavLink: React.FC<{ href: string; label: string; icon?: React.ReactNode; }> = ({ href, label, icon }) => {
  const pathname = usePathname();
  const isActive = pathname === href || (href !== '/' && pathname.startsWith(href));
  return (
    <Button  className={`justify-start ${isActive ? 'bg-accent text-accent-foreground' : ''}`}>
      <Link href={href} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};


export default function Navbar() {
  const router = useRouter();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim()); // Basic URL validation
        // We need a way to signify this is a remote URL to our browsing pages.
        // Option 1: Special prefix for siteId, e.g., "remote::http://localhost:8080"
        // Option 2: A different route, e.g., /browse/remote?url=...
        // Option 3: Pass state via router.push (can be complex with SSR/layouts)

        // Let's use Option 1: Prefix the siteId with "remote@" or similar marker
        // and encode the URL. The browsing page will then decode it.
        const encodedUrl = encodeURIComponent(url.origin); // Use origin (scheme + hostname + port)
        router.push(`/remote@${encodedUrl}`); // Navigate to /remote@http%3A%2F%2Flocalhost%3A8080
        setRemoteUrl(''); // Clear input
      } catch (error) {
        alert("Invalid URL entered.");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        <Link href="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
        </Link>
        
        {/* Remote Site URL Input */}
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Signum site URL (e.g., http://localhost:8080)"
              className="pl-9" // Padding for the icon
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          <NavLink href="/" label="Dashboard" icon={<Home className="h-4 w-4" />} />
          {/* ... other links ... */}
        </nav>

        <div className="md:hidden">
          <Button  >
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: components/core/Footer.tsx
// src/components/core/Footer.tsx
import Link from 'next/link';
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p> {currentYear} Signum Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: components/core/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: components/browsing/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; // It uses `dangerouslySetInnerHTML`, making it client-side for this pattern.
              // Alternatively, HTML parsing can be done on the server and HTML passed as prop.

import { marked } from 'marked';
import { useEffect, useMemo } from 'react'; // useMemo for parsing, useEffect if parsing were async
// Optional: Add DOMPurify for sanitization if markdown source is not 100% trusted
// import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {
        // If running in an SSR context where marked might be called without DOMPurify (if used),
        // or if you want to ensure it's only parsed once.
        // However, for this component marked as 'use client', this check is less critical
        // as it primarily renders client-side.
    }
    const rawHtml = marked.parse(markdown) as string;
    // Example of sanitization if you were to use DOMPurify:
    // if (typeof window !== 'undefined') { // DOMPurify only runs in browser
    //   return DOMPurify.sanitize(rawHtml);
    // }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Signum, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: lib/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { GrayMatterOption, Input } from 'gray-matter'; // Import GrayMatterOption and Input
import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { MarkdownFrontmatter, ParsedMarkdownFile } from '@/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Signum focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: lib/pageResolver.ts
// src/lib/pageResolver.ts
import { LocalSiteData } from '@/types';
import { marked } from 'marked';
import { renderArticleContent } from '@/themes/default/partials/article';
import { renderCollectionListContent, type CollectionItemForTemplate } from '@/themes/default/partials/collection';

export enum PageType {
  SinglePage,
  CollectionListing,
  NotFound,
}

export interface PageResolutionResult {
  type: PageType;
  mainContentHtml?: string;
  pageTitle?: string;
  errorMessage?: string;
}

/**
 * Resolves a given path to its corresponding page type and rendered content.
 * This is the single source of truth for what content appears at a specific URL.
 *
 * @param siteData The full LocalSiteData object.
 * @param slugArray The URL path segments (e.g., ['blog', 'my-first-post']).
 * @returns A PageResolutionResult object containing the page type and its rendered HTML content.
 */
export function resolvePageContent(
  siteData: LocalSiteData,
  slugArray: string[]
): PageResolutionResult {
  const publicContentFiles = siteData.contentFiles.filter(
    (f) => !f.frontmatter.draft && f.frontmatter.status !== 'draft'
  );

  const currentSlugPath = slugArray.join('/');
  
  // 1. Check for a direct single page match (e.g., /about -> content/about.md)
  const singlePagePath = `content/${currentSlugPath || 'index'}.md`.toLowerCase();
  const directFileMatch = publicContentFiles.find(f => f.path.toLowerCase() === singlePagePath);
  if (directFileMatch) {
    return {
      type: PageType.SinglePage,
      mainContentHtml: renderArticleContent(directFileMatch),
      pageTitle: directFileMatch.frontmatter.title || directFileMatch.slug,
    };
  }

  // 2. If not a single page, check if the path corresponds to a configured collection
  const navItem = siteData.config.nav_items?.find(item => item.path === currentSlugPath);
  if (navItem && navItem.type === 'collection') {
    const collectionConfig = siteData.config.collections?.find(c => c.path === currentSlugPath);
    const collectionTitle = collectionConfig?.nav_label || currentSlugPath.charAt(0).toUpperCase() + currentSlugPath.slice(1);
    const collectionDescription = collectionConfig?.description ? marked.parse(collectionConfig.description) as string : undefined;

    const itemsInThisFolder = publicContentFiles.filter(
      f => f.path.toLowerCase().startsWith(`content/${currentSlugPath}/`.toLowerCase()) &&
           !f.path.toLowerCase().endsWith('/index.md')
    );

    // Sort items based on collection config
    itemsInThisFolder.sort((a, b) => {
        const sortBy = collectionConfig?.sort_by || 'date';
        const sortOrder = collectionConfig?.sort_order === 'asc' ? 1 : -1;
        
        if (sortBy === 'title') {
            return (a.frontmatter.title.localeCompare(b.frontmatter.title)) * sortOrder;
        }
        // Default to date sorting
        const dateA = new Date(a.frontmatter.date || 0).getTime();
        const dateB = new Date(b.frontmatter.date || 0).getTime();
        return (dateA - dateB) * sortOrder;
    });

    const mappedItems: CollectionItemForTemplate[] = itemsInThisFolder
      .map(file => {
          const itemPathSegment = file.path.replace(/^content\//i, '').replace(/\.md$/i, '');
          const summary = file.frontmatter.summary || (marked.parse((file.content || '').substring(0, 180) + '...') as string);
          return {
              ...file,
              itemLink: `./${itemPathSegment.split('/').pop()}.html`,
              summaryOrContentTeaser: summary,
          };
      });

    return {
      type: PageType.CollectionListing,
      // Pass the description from the config to the renderer
      mainContentHtml: renderCollectionListContent(collectionTitle, mappedItems, collectionDescription),
      pageTitle: collectionTitle,
    };
  }

  // 3. If no match, return NotFound
  return {
    type: PageType.NotFound,
    errorMessage: `Content not found at path: "${currentSlugPath || 'homepage'}"`,
  };
}

================================================================================

File: lib/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: lib/siteExporter.ts
// src/lib/siteExporter.ts
import { LocalSiteData } from '@/types';
import JSZip from 'jszip';
import { slugify } from './utils';
import { stringifyToMarkdown } from './markdownParser';
import { generateNavLinks } from './navigationUtils';
import { resolvePageContent, PageType } from './pageResolver';
import { renderPageLayout } from '@/themes/default/layout';
import { renderHeader } from '@/themes/default/partials/header';
import { renderFooter } from '@/themes/default/partials/footer';
import { Manifest } from '@/types';

const SIGNUM_DIR = '_signum';
const CSS_DIR_EXPORT = 'css';
const JS_DIR_EXPORT = 'js';

interface GeneratedFile {
  path: string;
  content: string | Uint8Array;
}

function escapeForXml(str: string | undefined): string {
    if (str === undefined || str === null) return '';
    return String(str).replace(/[<>&"']/g, function (match) {
        switch (match) {
            case '<': return '<';
            case '>': return '>';
            case '&': return '&';
            case '"': return '"';
            case "'": return "'";
            default: return match;
        }
    });
}

export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
  const zip = new JSZip();
  const generatedFiles: GeneratedFile[] = [];
  const siteRootPathForLinks = '/'; 

  console.log("[Exporter] Starting site export process...");

  const publicContentFiles = siteData.contentFiles.filter(
    (f) => !f.frontmatter.draft && f.frontmatter.status !== 'draft'
  );

  // --- Generate HTML pages ---
  const navLinks = generateNavLinks(siteData, { isStaticExport: true, siteRootPath: siteRootPathForLinks });
  const siteHeaderHtml = renderHeader(siteData.config, navLinks, siteRootPathForLinks);
  const siteFooterHtml = renderFooter(siteData.config);
  
  const pathsToRender = new Set<string>();
  publicContentFiles.forEach(file => {
      const path = file.path.replace(/^content\//, '').replace(/\.md$/, '');
      if (path === 'index') {
          pathsToRender.add(''); // Root index
      } else {
          pathsToRender.add(path); // Single page
          // Add parent collection path
          const segments = path.split('/');
          if (segments.length > 1) {
              pathsToRender.add(segments[0]);
          }
      }
  });

  for (const path of pathsToRender) {
    const slugArray = path.split('/').filter(Boolean);
    const resolution = resolvePageContent(siteData, slugArray);
    
    if (resolution.type === PageType.SinglePage || resolution.type === PageType.CollectionListing) {
        const fullHtml = renderPageLayout(
            siteData.config,
            resolution.pageTitle || 'Untitled',
            siteHeaderHtml,
            resolution.mainContentHtml || '',
            siteFooterHtml
        );
        const exportPath = path ? (resolution.type === PageType.CollectionListing ? `${path}/index.html` : `${path}.html`) : 'index.html';
        generatedFiles.push({ path: exportPath, content: fullHtml });
        console.log(`[Exporter] Generated HTML for: ${exportPath}`);
    }
  }

  // --- Asset Copying (CSS & JS) ---
  const themeStylePath = '/themes/default/style.css';
  try { 
    const styleCssResponse = await fetch(themeStylePath);
    if (styleCssResponse.ok) {
        generatedFiles.push({ path: `${CSS_DIR_EXPORT}/style.css`, content: await styleCssResponse.text() });
    }
  } catch (e) { console.warn(`[Exporter] CSS fetch error:`, e); }
  
  const themeScriptPath = '/themes/default/scripts.js';
  try { 
    const scriptsJsResponse = await fetch(themeScriptPath);
    if (scriptsJsResponse.ok) {
        generatedFiles.push({ path: `${JS_DIR_EXPORT}/scripts.js`, content: await scriptsJsResponse.text() });
    }
  } catch (e) { console.warn(`[Exporter] JS fetch error:`, e); }

  // --- _signum Data Packaging ---
  siteData.contentFiles.forEach(file => {
      const rawMarkdown = stringifyToMarkdown(file.frontmatter, file.content);
      generatedFiles.push({ path: `${SIGNUM_DIR}/${file.path}`, content: rawMarkdown });
  });

  // --- Manifest, RSS, Sitemap Generation ---
  const manifest: Manifest = {
    siteId: siteData.siteId.replace(/^remote-/, ''),
    generatorVersion: 'SignumClient/0.1.0',
    config: siteData.config,
    entries: publicContentFiles.map(file => {
      let htmlPath: string;
      const relativePathNoExt = file.path.replace(/^content\//i, '').replace(/\.md$/i, '');
      const pathParts = relativePathNoExt.split('/');
      if (relativePathNoExt === 'index') {
          htmlPath = 'index.html';
      } else if (file.path.toLowerCase().endsWith('/index.md')) {
          htmlPath = `${pathParts.slice(0, -1).join('/')}/index.html`;
      } else {
          htmlPath = `${relativePathNoExt}.html`;
      }
      return {
          type: file.path.toLowerCase().endsWith('/index.md') ? 'collection_index' : 'page',
          status: file.frontmatter.status || 'published',
          sourcePath: `${SIGNUM_DIR}/${file.path}`,
          htmlPath: htmlPath,
          url: `${siteRootPathForLinks}${htmlPath}`.replace(/\/\//g, '/'),
          title: file.frontmatter.title,
          date: file.frontmatter.date,
          slug: file.slug,
      };
    }),
  };
  generatedFiles.push({ path: `${SIGNUM_DIR}/manifest.json`, content: JSON.stringify(manifest, null, 2) });

  const signumIndexHtml = `<!DOCTYPE html><html><head><title>Signum Site Data</title></head><body><h1>Signum Site Data</h1><p>This directory contains raw source data for this website.</p></body></html>`;
  generatedFiles.push({ path: `${SIGNUM_DIR}/index.html`, content: signumIndexHtml });

  const siteBaseUrlForFeeds = `http://${slugify(siteData.config.title || 'example')}.com`;
  const rssItems = manifest.entries
      .filter(e => e.type === 'page' && e.date)
      .sort((a,b) => new Date(b.date || 0).getTime() - new Date(a.date || 0).getTime())
      .slice(0, 20)
      .map(entry => {
          const absoluteUrl = new URL(entry.url.replace(/^\//, ''), siteBaseUrlForFeeds).href;
          const fileData = siteData.contentFiles.find(f => f.slug === entry.slug);
          return `<item><title>${escapeForXml(entry.title)}</title><link>${escapeForXml(absoluteUrl)}</link><guid isPermaLink="true">${escapeForXml(absoluteUrl)}</guid><pubDate>${new Date(entry.date!).toUTCString()}</pubDate><description>${escapeForXml(fileData?.frontmatter.summary || '')}</description></item>`;
      }).join('');
  const rssFeed = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(siteData.config.title)}</title><link>${siteBaseUrlForFeeds}</link><description>${escapeForXml(siteData.config.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrlForFeeds).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;
  generatedFiles.push({ path: 'rss.xml', content: rssFeed });
  
  const sitemapUrls = manifest.entries.map(entry => `<url><loc>${new URL(entry.url.replace(/^\//, ''), siteBaseUrlForFeeds).href}</loc><lastmod>${(entry.date || new Date().toISOString()).split('T')[0]}</lastmod></url>`).join('');
  const sitemapXml = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
  generatedFiles.push({ path: 'sitemap.xml', content: sitemapXml });

  // --- Final Zip Generation ---
  generatedFiles.forEach(file => {
    zip.file(file.path, file.content);
  });

  return zip.generateAsync({ type: 'blob' });
}

================================================================================

File: lib/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: lib/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { LocalSiteData, ParsedMarkdownFile, SiteConfigFile, Manifest } from '@/types';
import { parseMarkdownString } from './markdownParser';

/**
 * Fetches the text content of a single file from a remote server.
 * This is a low-level helper for fetching manifest, content, etc.
 * @param baseUrl The base URL of the remote site (e.g., "http://example.com").
 * @param filePath The path to the file relative to the base URL (e.g., "_signum/manifest.json").
 * @returns A Promise that resolves to the text content of the file.
 * @throws An error if the network request fails or the server returns a non-2xx status.
 */
async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const cleanBaseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
  const cleanFilePath = filePath.startsWith('/') ? filePath.slice(1) : filePath;
  const url = `${cleanBaseUrl}/${cleanFilePath}`;
  
  console.log(`[RFS] Attempting: GET ${url}`);
  try {
    const response = await fetch(url, { cache: 'no-store', mode: 'cors' });
    console.log(`[RFS] Status for ${url}: ${response.status}`);

    if (!response.ok) {
      const errorText = await response.text().catch(() => "Could not read error response body");
      console.error(`[RFS] FAILED fetch ${url}. Status: ${response.status}. Body: ${errorText.substring(0, 200)}...`);
      throw new Error(`Fetch failed for ${url}: ${response.statusText} (${response.status})`);
    }
    const textContent = await response.text();
    console.log(`[RFS] SUCCESS fetch ${url}. Length: ${textContent.length}`);
    return textContent;
  } catch (networkError) {
    console.error(`[RFS] NETWORK ERROR fetching ${url}:`, networkError);
    throw networkError;
  }
}

/**
 * Fetches and reconstructs an entire remote Signum site into the LocalSiteData format.
 * It starts by fetching the manifest, then fetches all content files listed within it.
 * This is the primary function for viewing a remote site within the Signum client.
 * @param remoteSiteUrl The base URL of the remote Signum site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  console.log(`[RFS] >>> Starting fetchRemoteSiteData for URL: ${remoteSiteUrl}`);
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`[RFS] Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json. This is now the single entry point for site metadata.
    console.log(`[RFS] Fetching manifest.json...`);
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_signum/manifest.json');
    let manifest: Manifest;
    try {
      manifest = JSON.parse(manifestString);
      console.log(`[RFS] Parsed manifest:`, JSON.stringify(manifest, null, 2).substring(0, 500) + "...");
    } catch (e) {
      console.error(`[RFS] FAILED to parse manifest.json. Content: ${manifestString.substring(0,200)}...`, e);
      return null;
    }

    if (!manifest || !manifest.config || !manifest.entries || !Array.isArray(manifest.entries) || !manifest.siteId) {
        console.error("[RFS] Invalid manifest structure: 'config', 'entries' array, or 'siteId' is missing or invalid.", manifest);
        return null;
    }

    // 2. Get site config directly from the manifest. No need to fetch site.yaml anymore.
    const siteConfig: SiteConfigFile = manifest.config;
    // Fallback for title if it's missing in the config from the manifest.
    if (!siteConfig.title) {
      siteConfig.title = new URL(remoteSiteUrl).hostname || 'Remote Site';
    }
    console.log(`[RFS] Loaded siteConfig from manifest:`, siteConfig);
    
    // 3. Fetch all content files listed in the manifest's 'entries' array.
    const contentFilesPromises: Promise<ParsedMarkdownFile | null>[] = manifest.entries
      .filter(entry => entry.sourcePath && entry.sourcePath.startsWith('_signum/content/') && entry.sourcePath.endsWith('.md'))
      .map(async (entry) => {
        // The sourcePath is like `_signum/content/about.md`.
        // The file to fetch on the server is at the root, e.g., `http://site.com/content/about.md`.
        const filePathToFetch = entry.sourcePath.replace(/^_signum\//, '');
        console.log(`[RFS] Processing MD file from manifest entry: ${filePathToFetch}`);
        try {
          const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, filePathToFetch);
          const { frontmatter, content } = parseMarkdownString(rawMarkdown);
          // The path for LocalSiteData should be the path relative to the content root, e.g., 'content/about.md'.
          return { slug: entry.slug, path: filePathToFetch, frontmatter, content };
        } catch (mdError) {
          console.warn(`[RFS] FAILED to fetch or parse MD file ${filePathToFetch}:`, mdError);
          return null;
        }
      });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];
    console.log(`[RFS] Fetched and parsed ${validContentFiles.length} content files.`);

    if (!validContentFiles.some(f => f.path === 'content/index.md')) {
        console.warn(`[RFS] No 'content/index.md' found in remote site bundle. Site might be incomplete.`);
    }
    
    const appSpecificSiteId = `remote-${manifest.siteId}`; // Use siteId from manifest for app's internal tracking.

    const finalSiteData: LocalSiteData = {
      siteId: appSpecificSiteId,
      config: siteConfig,
      contentFiles: validContentFiles,
    };
    console.log(`[RFS] <<< Successfully constructed remote site data for ${appSpecificSiteId}`);
    return finalSiteData;

  } catch (error) {
    console.error(`[RFS] <<< CRITICAL ERROR in fetchRemoteSiteData for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

File: lib/fileTreeUtils.ts
// src/lib/fileTreeUtils.ts
import { ParsedMarkdownFile, SiteConfigFile, NavItem } from '@/types';

export interface TreeNode {
  id: string;
  name: string;
  type: 'file' | 'folder' | 'collection';
  path: string;
  children: TreeNode[];
}

const buildNode = (item: NavItem, allNavItems: NavItem[], config: SiteConfigFile, files: ParsedMarkdownFile[]): TreeNode => {
  if (item.type === 'page') {
    const fullPath = `content/${item.path}.md`;
    const file = files.find(f => f.path === fullPath);
    return {
      id: fullPath,
      name: file?.frontmatter.title || item.path.split('/').pop() || item.path,
      type: 'file',
      path: fullPath,
      children: [],
    };
  }

  // It's a folder or a collection
  const fullPath = `content/${item.path}`;
  const collectionConfig = config.collections?.find(c => c.path === item.path);
  
  // Find direct children in the nav_items structure for nested pages/folders
  const navChildren = allNavItems
    .filter(child => child.path.startsWith(`${item.path}/`) && child.path.split('/').length === item.path.split('/').length + 1)
    .sort((a, b) => a.order - b.order)
    .map(child => buildNode(child, allNavItems, config, files));
  
  // Find implicit children (collection items) from the file list
  const collectionItemChildren = files
    .filter(file => getParentPath(file.path) === fullPath && !file.path.endsWith('index.md'))
    .map(file => ({
        id: file.path,
        name: file.frontmatter.title || file.slug,
        type: 'file' as const,
        path: file.path,
        children: []
    }));

  return {
    id: fullPath,
    name: collectionConfig?.nav_label || item.path.split('/').pop() || item.path,
    type: item.type,
    path: fullPath,
    children: [...navChildren, ...collectionItemChildren],
  };
};

export function buildFileTree(config: SiteConfigFile, files: ParsedMarkdownFile[]): TreeNode[] {
  const navItems = config.nav_items || [];
  
  const topLevelItems = navItems
    .filter(item => !item.path.includes('/'))
    .sort((a, b) => a.order - b.order);
  
  return topLevelItems.map(item => buildNode(item, navItems, config, files));
}

export function getParentPath(path: string): string {
  if (!path.includes('/')) return 'content';
  return path.substring(0, path.lastIndexOf('/'));
}

================================================================================

File: lib/localSiteFs.ts
// src/lib/localSiteFs.ts
import { LocalSiteData, SiteConfigFile, ParsedMarkdownFile } from '@/types';
import { parseMarkdownString } from './markdownParser';
//import yaml from 'js-yaml';


const LOCAL_STORAGE_KEY = 'signum-sites-data';

function _isBrowser(): boolean {
  return typeof window !== 'undefined';
}

function _readAllSitesFromStorage(): LocalSiteData[] {
  if (!_isBrowser()) return [];
  try {
    const jsonData = localStorage.getItem(LOCAL_STORAGE_KEY);
    return jsonData ? JSON.parse(jsonData) : [];
  } catch (error) {
    console.error("Error reading sites from localStorage:", error);
    return [];
  }
}

function _writeAllSitesToStorage(sites: LocalSiteData[]): void {
  if (!_isBrowser()) return;
  try {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(sites));
  } catch (error) {
    console.error("Error writing sites to localStorage:", error);
  }
}

export async function loadAllSites(): Promise<LocalSiteData[]> {
  return Promise.resolve(_readAllSitesFromStorage());
}

/**
 * Gets a specific site by its ID from local storage.
 * Returns LocalSiteData or null if not found.
 */
export async function getSiteById(siteId: string): Promise<LocalSiteData | null> { // CHANGED RETURN TYPE
  const sites = _readAllSitesFromStorage();
  const site = sites.find(s => s.siteId === siteId);
  return Promise.resolve(site || null); // Ensure it returns null if not found
}

export async function saveSite(siteData: LocalSiteData): Promise<void> {
  const sites = _readAllSitesFromStorage();
  const existingSiteIndex = sites.findIndex(s => s.siteId === siteData.siteId);
  if (existingSiteIndex > -1) {
    sites[existingSiteIndex] = siteData;
  } else {
    sites.push(siteData);
  }
  _writeAllSitesToStorage(sites);
  return Promise.resolve();
}

export async function deleteSite(siteId: string): Promise<void> {
  let sites = _readAllSitesFromStorage();
  sites = sites.filter(s => s.siteId !== siteId);
  _writeAllSitesToStorage(sites);
  return Promise.resolve();
}

export async function saveSiteConfig(siteId: string, config: SiteConfigFile): Promise<void> {
  const sites = _readAllSitesFromStorage();
  const siteIndex = sites.findIndex(s => s.siteId === siteId);
  if (siteIndex > -1) {
    sites[siteIndex].config = config;
    _writeAllSitesToStorage(sites);
  } else {
    console.warn(`Site with ID ${siteId} not found for saving config.`);
  }
  return Promise.resolve();
}

export async function saveContentFile(siteId: string, path: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile | undefined> {
  const sites = _readAllSitesFromStorage();
  const siteIndex = sites.findIndex(s => s.siteId === siteId);
  if (siteIndex > -1) {
    try { // Add try-catch for parseMarkdownString
        const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
        const fileSlug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
        const newOrUpdatedFile: ParsedMarkdownFile = {
        slug: fileSlug,
        path: path,
        frontmatter: frontmatter,
        content: content,
        };
        const contentFileIndex = sites[siteIndex].contentFiles.findIndex(f => f.path === path);
        if (contentFileIndex > -1) {
        sites[siteIndex].contentFiles[contentFileIndex] = newOrUpdatedFile;
        } else {
        sites[siteIndex].contentFiles.push(newOrUpdatedFile);
        }
        _writeAllSitesToStorage(sites);
        return Promise.resolve(newOrUpdatedFile);
    } catch (parseError) {
        console.error(`Error parsing markdown for ${path} in site ${siteId}:`, parseError);
        // Potentially throw or return undefined to indicate failure at a higher level
        return Promise.resolve(undefined); 
    }
  } else {
    console.warn(`Site with ID ${siteId} not found for saving content file.`);
    return Promise.resolve(undefined);
  }
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
  const sites = _readAllSitesFromStorage();
  const siteIndex = sites.findIndex(s => s.siteId === siteId);
  if (siteIndex > -1) {
    sites[siteIndex].contentFiles = sites[siteIndex].contentFiles.filter(f => f.path !== filePath);
    _writeAllSitesToStorage(sites);
  } else {
    console.warn(`Site with ID ${siteId} not found for deleting content file.`);
  }
  return Promise.resolve();
}

export async function listSiteIds(): Promise<string[]> {
  const sites = _readAllSitesFromStorage();
  return Promise.resolve(sites.map(s => s.siteId));
}

================================================================================

File: lib/navigationUtils.ts
// src/lib/navigationUtils.ts
import { LocalSiteData, NavLinkItem, SiteConfigFile } from '@/types';

/**
 * Represents a user-configured navigation item in the site config.
 * It defines the type of link (page or collection), its path, and its display order.
 */
export interface NavConfigItem {
  type: 'page' | 'collection';
  path: string; // e.g., 'about' or 'posts'
  order: number;
}

/**
 * A new SiteConfigFile type that includes the user-configurable navigation items.
 * This will replace the old SiteConfigFile definition.
 */
export interface SiteConfigFileWithNav extends SiteConfigFile {
    nav_items?: NavConfigItem[];
}


/**
 * Generates the definitive navigation structure for a site based on its configuration.
 * This function is the single source of truth for both the live preview and the static site exporter.
 * It uses the 'nav_items' array in the site config to determine the order and content of the navigation.
 *
 * @param siteData The full LocalSiteData object for the site, using the updated config with nav_items.
 * @param options An object containing options for link generation.
 *                - isStaticExport: Determines if links should end in '.html'.
 *                - siteRootPath: The base path for all generated hrefs (e.g., '/').
 * @returns An array of NavLinkItem objects representing the final navigation.
 */
export function generateNavLinks(
  siteData: LocalSiteData,
  options: { isStaticExport: boolean; siteRootPath: string }
): NavLinkItem[] {
  const { isStaticExport, siteRootPath } = options;
  const config = siteData.config as SiteConfigFileWithNav;
  const navItemsConfig = config.nav_items || [];
  
  // Sort items based on the user-defined order
  const sortedNavItems = [...navItemsConfig].sort((a, b) => a.order - b.order);

  const navLinks: NavLinkItem[] = [];

  // Always add the Home link first. It is not part of the configurable nav_items.
  const homeHref = isStaticExport ? `${siteRootPath}index.html`.replace(/\/\//g, '/') : siteRootPath;
  navLinks.push({ href: homeHref, label: "Home", iconName: "home" });

  for (const item of sortedNavItems) {
    if (item.type === 'collection') {
      const collectionConfig = config.collections?.find(c => c.path === item.path);
      const href = isStaticExport 
        ? `${siteRootPath}${item.path}/index.html`.replace(/\/\//g, '/')
        : `${siteRootPath}${item.path}`.replace(/\/\//g, '/');
      
      navLinks.push({
        href,
        label: collectionConfig?.nav_label || item.path,
        iconName: "folder"
      });
    } else if (item.type === 'page') {
      const pageFile = siteData.contentFiles.find(
        f => f.path === `content/${item.path}.md`
      );
      // Only add the page to nav if the corresponding file actually exists
      if (pageFile) {
        const href = isStaticExport
          ? `${siteRootPath}${item.path}.html`.replace(/\/\//g, '/')
          : `${siteRootPath}${item.path}`.replace(/\/\//g, '/');
        
        navLinks.push({
          href,
          label: pageFile.frontmatter.title || item.path,
          iconName: "file-text"
        });
      }
    }
  }

  // Ensure no duplicate links (though with the new model this is less likely)
  return navLinks.filter((link, index, self) => 
    index === self.findIndex((l) => (l.href === link.href))
  );
}

================================================================================

File: themes/default/utils.ts
// src/themes/default/utils.ts
export function escapeHtml(unsafe: unknown): string {
  if (typeof unsafe === 'string') {
    return unsafe
      .replace(/&/g, "&")
      .replace(/</g, "<")
      .replace(/>/g, ">")
      .replace(/"/g, '"')
      .replace(/'/g, "'");
  }
  if (unsafe === null || unsafe === undefined) {
      return '';
  }
  // If it's not a string but is some other type (like a number), convert it to a string and then escape.
  return String(unsafe)
      .replace(/&/g, "&")
      .replace(/</g, "<")
      .replace(/>/g, ">")
      .replace(/"/g, '"')
      .replace(/'/g, "'");
}

================================================================================

File: themes/default/templates.ts
// src/themes/default/templates.ts
import type { SiteConfigFile, ParsedMarkdownFile, NavLinkItem } from '@/types';

/**
 * A type-safe function to escape HTML special characters.
 * It now correctly handles the 'unknown' type by first checking if the
 * input is a string before attempting to use string methods.
 * @param unsafe The input value, which can be of any type.
 * @returns A string with HTML special characters replaced by their entities.
 */
function escapeHtml(unsafe: unknown): string {
  if (typeof unsafe === 'string') {
    return unsafe
      .replace(/&/g, "&")
      .replace(/</g, "<")
      .replace(/>/g, ">")
      .replace(/"/g, '"')
      .replace(/'/g, "'");
  }
  if (unsafe === null || unsafe === undefined) {
      return '';
  }
  // If it's not a string but is some other type (like a number), convert it to a string and then escape.
  return String(unsafe)
      .replace(/&/g, "&")
      .replace(/</g, "<")
      .replace(/>/g, ">")
      .replace(/"/g, '"')
      .replace(/'/g, "'");
}

export function renderHeader(siteConfig: SiteConfigFile, navLinks: NavLinkItem[], siteRootPath: string): string {
  const siteTitle = escapeHtml(siteConfig?.title || 'Signum Site');
  const navItemsHtml = navLinks.map(link => `
    <li class="${link.isActive ? 'active' : ''}">
      <a href="${escapeHtml(link.href)}" title="${escapeHtml(link.label)}">
        <span>${escapeHtml(link.label)}</span>
      </a>
    </li>
  `).join('');

  return `
    <header class="site-header">
      <div class="container">
        <a href="${escapeHtml(siteRootPath)}" class="site-title-link">
          <h1 class="site-title">${siteTitle}</h1>
        </a>
        <nav class="site-nav">
          <ul>
            ${navItemsHtml}
          </ul>
        </nav>
      </div>
    </header>
  `;
}

export function renderFooter(siteConfig: SiteConfigFile): string {
  const year = new Date().getFullYear();
  const author = siteConfig.author ? `<p>By ${escapeHtml(siteConfig.author)}</p>` : '';
  return `
    <footer class="site-footer">
      <div class="container">
        ${author}
        <p> ${year} ${escapeHtml(siteConfig.title || 'Signum Site')}. Powered by Signum.</p>
      </div>
    </footer>
  `;
}

export function renderPageLayout(
  siteConfig: SiteConfigFile,
  fullBodyContentHtml: string, 
  pageTitle: string,
): string {
  const siteTitle = escapeHtml(siteConfig?.title || 'Signum Site');
  const effectivePageTitle = pageTitle ? `${escapeHtml(pageTitle)} | ${siteTitle}` : siteTitle;

  let htmlClass = '';
  if (siteConfig.theme === 'dark') htmlClass = 'theme-dark';
  if (siteConfig.theme === 'auto') htmlClass = 'theme-auto';

  let htmlStyle = '';
  if (siteConfig.font_family) {
    htmlStyle += `font-family: "${siteConfig.font_family.replace(/"/g, '\\"')}";`;
  }
  if (siteConfig.primary_color) {
    htmlStyle += `--primary-color: ${escapeHtml(siteConfig.primary_color)};`;
  }

  return `
<!DOCTYPE html>
<html lang="en"${htmlClass ? ` class="${htmlClass}"` : ''}${htmlStyle ? ` style="${htmlStyle}"` : ''}>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${effectivePageTitle}</title>
  <meta name="description" content="${escapeHtml(siteConfig.description || '')}">
  ${siteConfig.author ? `<meta name="author" content="${escapeHtml(siteConfig.author)}">` : ''}
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div class="site-container">
    ${fullBodyContentHtml}
  </div>
  <script src="/js/scripts.js"></script>
</body>
</html>
  `;
}

export function renderArticle(fileData: ParsedMarkdownFile): string {
  const title = escapeHtml(fileData.frontmatter.title || 'Untitled Page');
  const date = fileData.frontmatter.date 
    ? new Date(fileData.frontmatter.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) 
    : '';
  const bodyHtmlPlaceholder = `<!-- SSG will render markdown body here -->`;

  return `
    <article class="post">
      <header class="post-header">
        <h1>${title}</h1>
        ${date ? `<p class="post-date">Published on: ${date}</p>` : ''}
        ${fileData.frontmatter.summary ? `<p class="post-summary">${escapeHtml(fileData.frontmatter.summary)}</p>` : ''}
      </header>
      <div class="post-content">
        ${bodyHtmlPlaceholder}
      </div>
    </article>
  `;
}

interface CollectionListItemForTemplate extends Omit<ParsedMarkdownFile, 'frontmatter'> {
  frontmatter: ParsedMarkdownFile['frontmatter'] & {
    date?: string;
    title: string;
  };
  itemLink: string;
}

export function renderCollectionItem(item: CollectionListItemForTemplate): string {
  const title = escapeHtml(item.frontmatter.title || 'Untitled Item');
  const date = item.frontmatter.date 
    ? new Date(item.frontmatter.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
    : '';
  const summary = escapeHtml(item.frontmatter.summary || item.content.substring(0, 150).replace(/#.*$/gm, '').replace(/[\*\`\[\]]/g, '').trim() + '...');

  return `
    <li class="collection-item">
      <article>
        <h2 class="collection-item-title"><a href="${escapeHtml(item.itemLink)}">${title}</a></h2>
        ${date ? `<p class="collection-item-date">${date}</p>` : ''}
        ${summary ? `<p class="collection-item-summary">${summary}</p>` : ''}
        <a href="${escapeHtml(item.itemLink)}" class="collection-item-readmore">Read More</a>
      </article>
    </li>
  `;
}

export function renderCollectionList(
  collectionTitle: string, 
  items: CollectionListItemForTemplate[]
): string {
  const itemsHtml = items.map(item => renderCollectionItem(item)).join('');

  return `
    <section class="collection">
      <header class="collection-header">
        <h1>${escapeHtml(collectionTitle)}</h1>
      </header>
      ${items.length > 0 ? `<ul class="collection-list">${itemsHtml}</ul>` : '<p>No items in this collection.</p>'}
    </section>
  `;
}

================================================================================

File: themes/default/layout.ts
// src/themes/default/layout.ts
import { SiteConfigFile } from '@/types';
import { renderHead } from './partials/head'; // Assuming head.ts is in the same directory or correct path
import { escapeHtml } from './utils';     // Assuming utils.ts is in ../

export function renderPageLayout(
  siteConfig: SiteConfigFile,
  pageTitle: string,
  headerHtml: string,
  mainContentHtml: string, // This will be the output of renderArticleContent or renderCollectionListContent
  footerHtml: string
): string {
  
  const htmlClassesArray: string[] = [];
  const htmlStylesArray: string[] = [];

  // Theme Class
  if (siteConfig.theme === 'dark') htmlClassesArray.push('theme-dark');
  else if (siteConfig.theme === 'auto') htmlClassesArray.push('theme-auto');
  else htmlClassesArray.push('theme-light'); // Default if not specified or invalid

  // Font Stack Class & CSS Variable
  if (siteConfig.font_family === 'serif') {
    htmlClassesArray.push('font-serif');
    // --font-stack-active is now primarily set via class in style.css, 
    // but can be overridden here if needed or for browsers not fully supporting complex :root var inheritance.
    // htmlStylesArray.push(`--font-stack-active: var(--font-stack-serif);`); 
  } else if (siteConfig.font_family === 'monospace') {
    htmlClassesArray.push('font-mono');
    // htmlStylesArray.push(`--font-stack-active: var(--font-stack-mono);`);
  } else { // Default to sans-serif
    htmlClassesArray.push('font-sans');
    // htmlStylesArray.push(`--font-stack-active: var(--font-stack-sans);`);
  }
  
  // Primary Color CSS Variable
  if (siteConfig.primary_color) {
    // This variable is defined on :root in style.css, this inline style overrides it.
    htmlStylesArray.push(`--primary-color: ${escapeHtml(siteConfig.primary_color)};`);
  }

  const htmlClassAttribute = htmlClassesArray.length > 0 ? ` class="${htmlClassesArray.join(' ')}"` : '';
  const htmlStyleAttribute = htmlStylesArray.length > 0 ? ` style="${htmlStylesArray.join(' ')}"` : '';

  const headContent = renderHead(siteConfig, pageTitle);

  return `<!DOCTYPE html>
<html lang="en"${htmlClassAttribute}${htmlStyleAttribute}>
${headContent}
<body>
  <div class="site-container"> {/* This class is styled by theme.css */}
    ${headerHtml}
    <main class="site-content"> {/* This class is styled by theme.css */}
      ${mainContentHtml} {/* This will already have .prose if it's article/collection */}
    </main>
    ${footerHtml}
  </div>
  <script src="/js/scripts.js"></script> {/* Path in exported bundle */}
</body>
</html>
  `;
}

================================================================================

File: themes/default/scripts.js
// src/themes/default/scripts.js
// This file will be used for the *exported static site*.
// It can contain JavaScript for simple interactions like a mobile menu toggle.

// Example: Mobile menu toggle
// (This is a very basic example and assumes specific HTML structure from templates)
document.addEventListener('DOMContentLoaded', () => {
  // const menuToggle = document.querySelector('.mobile-menu-toggle'); // Hypothetical selector
  // const siteNav = document.querySelector('.site-nav ul');          // Hypothetical selector

  // if (menuToggle && siteNav) {
  //   menuToggle.addEventListener('click', () => {
  //     siteNav.classList.toggle('active');
  //   });
  // }
  console.log("Signum default theme scripts loaded.");
});

================================================================================

File: themes/default/style.css
/* src/themes/default/style.css */
/* This file will be used for the *exported static site*. */
/* The live client preview uses globals.css and Tailwind. */

:root {
  /* Default primary color, overridden by <html style="--primary-color: #..."> if set in site config */
  --primary-color: #007AFF; 
  --text-color: #333;
  --background-color: #fff;
  --link-color: var(--primary-color);
  --header-bg: #f4f4f4;
  --header-text: #333;
  --footer-text: #777;
  --border-color: #ddd;
  --muted-text: #666;
}

/* Example: Applying dark theme styles if a class is added to <html> by renderPageLayout */
html.theme-dark { /* Class set by renderPageLayout if siteConfig.theme is 'dark' */
  --text-color: #f0f0f0;
  --background-color: #222;
  --link-color: #6cb6ff; /* Lighter blue for dark mode */
  --primary-color: #6cb6ff; /* Ensure primary color also adapts or is distinct */
  --header-bg: #333;
  --header-text: #f0f0f0;
  --footer-text: #aaa;
  --border-color: #555;
  --muted-text: #bbb;
}

/* System preference can also be handled via prefers-color-scheme */
@media (prefers-color-scheme: dark) {
  html.theme-auto { /* Class set by renderPageLayout if siteConfig.theme is 'auto' */
    --text-color: #f0f0f0;
    --background-color: #222;
    --link-color: #6cb6ff;
    --primary-color: #6cb6ff;
    --header-bg: #333;
    --header-text: #f0f0f0;
    --footer-text: #aaa;
    --border-color: #555;
    --muted-text: #bbb;
  }
}


body {
  /* font-family is set directly on <html> tag by renderPageLayout */
  line-height: 1.65;
  margin: 0;
  padding: 0;
  background-color: var(--background-color);
  color: var(--text-color);
  font-size: 16px; /* Base font size */
}

.site-container {
  max-width: 800px; /* Adjust as needed */
  margin: 0 auto;
  padding: 20px 20px 40px 20px; /* Added more bottom padding */
}

.site-header {
  background-color: var(--header-bg);
  padding: 1rem 0;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 30px; /* Increased spacing */
}

.site-header .container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 800px; /* Match .site-container */
  margin: 0 auto;
  padding: 0 20px;
}

.site-title {
  font-size: 1.8em;
  margin: 0;
  font-weight: 700;
}
.site-title-link {
  text-decoration: none;
  color: var(--header-text);
}
.site-title-link:hover {
  color: var(--primary-color);
}

.site-nav ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
}

.site-nav li {
  margin-left: 20px; /* Increased spacing */
}

.site-nav a {
  text-decoration: none;
  color: var(--header-text);
  font-weight: 500;
  padding-bottom: 4px; /* For border alignment */
  border-bottom: 2px solid transparent;
  transition: color 0.2s ease, border-color 0.2s ease;
}
.site-nav a:hover {
  color: var(--primary-color);
  border-bottom-color: var(--primary-color);
}
.site-nav li.active a { /* Assuming 'active' class is set by JS or template */
  font-weight: 700;
  color: var(--primary-color);
  border-bottom-color: var(--primary-color);
}

.site-content {
  /* Main content area placeholder */
}

.site-footer {
  text-align: center;
  padding: 30px 0;
  margin-top: 50px; /* Increased spacing */
  border-top: 1px solid var(--border-color);
  font-size: 0.9em;
  color: var(--footer-text);
}
.site-footer p {
    margin: 0.5em 0;
}

/* General Content Typography & Elements */
a {
  color: var(--link-color);
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 1.8em;
  margin-bottom: 0.8em;
  line-height: 1.3;
  font-weight: 700;
}
h1 { font-size: 2.2em; }
h2 { font-size: 1.8em; }
h3 { font-size: 1.5em; }
h4 { font-size: 1.2em; }

p {
  margin-bottom: 1.2em;
}

ul, ol {
  margin-bottom: 1.2em;
  padding-left: 1.8em;
}
li {
  margin-bottom: 0.5em;
}

blockquote {
  margin: 1.5em 0;
  padding: 0.5em 1.5em;
  border-left: 4px solid var(--primary-color);
  background-color: var(--header-bg); /* Slight background for blockquotes */
  color: var(--muted-text);
  font-style: italic;
}
blockquote p {
    margin-bottom: 0.5em;
}

pre {
  background-color: #f9f9f9; /* Keep code blocks light even in dark mode for readability, or adjust */
  color: #333;
  padding: 1em;
  overflow-x: auto;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 0.9em;
  margin: 1.5em 0;
}
html.theme-dark pre, html.theme-auto:has(body[style*="dark"]) pre { /* Example of specific dark mode for pre */
    background-color: #2d2d2d;
    color: #ccc;
    border-color: #444;
}


code { /* Inline code */
  font-family: monospace; /* Ensure this matches selected monospace if user chose that */
  background-color: rgba(0,0,0,0.05);
  padding: 0.2em 0.4em;
  border-radius: 3px;
  font-size: 0.9em;
}
html.theme-dark code, html.theme-auto:has(body[style*="dark"]) code {
    background-color: rgba(255,255,255,0.1);
}

pre code { /* Code inside pre blocks should not have extra background */
  background-color: transparent;
  padding: 0;
  font-size: inherit; /* Inherit pre's font size */
}

hr {
    border: none;
    border-top: 1px solid var(--border-color);
    margin: 2em 0;
}

/* Post specific styles */
.post {
  margin-bottom: 40px;
}
.post-header {
    margin-bottom: 1.5em;
    padding-bottom: 1em;
    border-bottom: 1px solid var(--border-color);
}
.post-header h1 {
  font-size: 2.5em; /* Larger for post titles */
  margin-top: 0; /* No top margin for main post title */
  margin-bottom: 0.2em;
}
.post-date {
  color: var(--muted-text);
  font-size: 0.9em;
  margin-bottom: 1em;
}
.post-summary {
  font-style: italic;
  color: var(--muted-text);
  margin-bottom: 1.5em;
  font-size: 1.1em;
}
.post-content {
  /* Typography above generally applies */
}


/* Collection list styles */
.collection {
  /* Styles for collection container */
}
.collection-header h1 {
  font-size: 2.2em; /* Consistent with post title */
  margin-bottom: 1em;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.5em;
}
.collection-index-content { /* For content/collection/index.md body */
    margin-bottom: 2em;
}

.collection-list {
  list-style: none;
  padding: 0;
}
.collection-item {
  margin-bottom: 30px;
  padding-bottom: 20px;
  border-bottom: 1px dotted var(--border-color);
}
.collection-item:last-child {
    border-bottom: none;
}
.collection-item-title {
  font-size: 1.6em;
  margin-bottom: 0.3em;
  font-weight: 600;
}
.collection-item-title a {
  text-decoration: none;
  color: var(--text-color); /* Use main text color for titles */
}
.collection-item-title a:hover {
  color: var(--primary-color);
}
.collection-item-date {
  font-size: 0.85em;
  color: var(--muted-text);
  margin-bottom: 0.5em;
}
.collection-item-summary {
  font-size: 0.95em;
  color: var(--text-color); /* Regular text color for summary */
  opacity: 0.9;
  margin-bottom: 1em;
}
.collection-item-readmore {
  display: inline-block;
  font-size: 0.9em;
  text-decoration: none;
  font-weight: 600;
  color: var(--primary-color);
}
.collection-item-readmore:hover {
    text-decoration: underline;
}

/* Prose styles for markdown content - can be basic or more elaborate */
.prose {
    /* Basic prose styling can go here if not relying on Tailwind's @tailwindcss/typography in the exported site */
}

================================================================================

File: themes/default/partials/article.ts
// src/themes/default/partials/article.ts
import { ParsedMarkdownFile } from '@/types';
import { escapeHtml } from '../utils';
import { marked } from 'marked';

export function renderArticleContent(fileData: ParsedMarkdownFile): string {
  const title = escapeHtml(fileData.frontmatter.title || 'Untitled Page');
  const date = fileData.frontmatter.date 
    ? new Date(fileData.frontmatter.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) 
    : '';
  const markdownBodyHtml = marked.parse(fileData.content || '') as string;

  // The .prose class will provide Tailwind-like typography for elements within.
  return `
<article class="post prose"> <!-- Added .prose class here -->
  <header class="post-header"> <!-- Specific styling for post headers in theme.css -->
    <h1>${title}</h1> <!-- Will be styled by .prose h1 -->
    ${date ? `<p class="post-date">${date}</p>` : ''}
    ${fileData.frontmatter.summary ? `<p class="post-summary">${escapeHtml(fileData.frontmatter.summary)}</p>` : ''}
  </header>
  <div class="post-content"> <!-- This div is mostly for semantic grouping if needed -->
    ${markdownBodyHtml} <!-- Markdown elements (p, ul, etc.) will be styled by .prose -->
  </div>
</article>
  `;
}

================================================================================

File: themes/default/partials/collection.ts
// src/themes/default/partials/collection.ts
import { ParsedMarkdownFile } from '@/types';
import { escapeHtml } from '../utils';

// This interface is used by renderCollectionListContent when preparing items
export interface CollectionItemForTemplate extends Omit<ParsedMarkdownFile, 'frontmatter' | 'content'> {
  frontmatter: ParsedMarkdownFile['frontmatter'] & {
    date?: string;
    title: string;
  };
  itemLink: string;
  summaryOrContentTeaser: string;
}

// Renders a single item in a list - this itself doesn't need .prose, but its contents will be.
export function renderCollectionItemContent(item: CollectionItemForTemplate): string {
  const title = escapeHtml(item.frontmatter.title || 'Untitled Item');
  const date = item.frontmatter.date 
    ? new Date(item.frontmatter.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
    : '';

  return `
<li class="collection-item"> <!-- Styled by theme.css -->
  <article>
    <h2 class="collection-item-title"><a href="${escapeHtml(item.itemLink)}">${title}</a></h2>
    ${date ? `<p class="collection-item-date">${date}</p>` : ''}
    ${item.summaryOrContentTeaser ? `<div class="collection-item-summary prose-sm">${item.summaryOrContentTeaser}</div>` : ''} <!-- Wrap teaser in a div with prose styling if it's HTML -->
    <a href="${escapeHtml(item.itemLink)}" class="collection-item-readmore">Read More </a>
  </article>
</li>
  `;
}

// Renders the overall list of collection items.
export function renderCollectionListContent(
  collectionTitle: string, 
  items: CollectionItemForTemplate[], 
  collectionIndexContentHtml?: string // HTML from the collection's own index.md page
): string {
  const itemsHtml = items.map(item => renderCollectionItemContent(item)).join('');

  return `
<section class="collection prose"> <!-- Added .prose class here for overall styling -->
  <header class="collection-header">
    <h1>${escapeHtml(collectionTitle)}</h1> <!-- Styled by .prose h1 -->
  </header>
  ${collectionIndexContentHtml ? `<div class="collection-index-content">${collectionIndexContentHtml}</div>` : ''} <!-- Content from collection's index.md -->
  ${items.length > 0 ? `<ul class="collection-list">${itemsHtml}</ul>` : '<p>No items in this collection.</p>'}
</section>
  `;
}

================================================================================

File: themes/default/partials/head.ts
// src/themes/default/partials/head.ts
import { SiteConfigFile } from '@/types';
import { escapeHtml } from '../utils';

export function renderHead(siteConfig: SiteConfigFile, pageTitle: string): string {
  const siteTitle = escapeHtml(siteConfig.title || 'Signum Site');
  const effectivePageTitle = pageTitle ? `${escapeHtml(pageTitle)} | ${siteTitle}` : siteTitle;

  // Note: The actual classes (font-*, theme-*) and style variables (--primary-color, --font-stack-active)
  // are applied to the <html> tag by renderPageLayout in layout.ts.
  // This head template just includes meta tags and the CSS link.

  return `
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${effectivePageTitle}</title>
  <meta name="description" content="${escapeHtml(siteConfig.description || '')}">
  ${siteConfig.author ? `<meta name="author" content="${escapeHtml(siteConfig.author)}">` : ''}
  <link rel="stylesheet" href="/css/style.css"> {/* Path in exported bundle */}
</head>
  `;
}

================================================================================

File: themes/default/partials/footer.ts
// src/themes/default/partials/footer.ts
import { SiteConfigFile } from '@/types';
import { escapeHtml } from '../utils';

export function renderFooter(siteConfig: SiteConfigFile): string {
  const year = new Date().getFullYear();
  // CORRECTED: Changed 'site.author' to 'siteConfig.author'
  const author = siteConfig.author ? `<p class="site-author">By ${escapeHtml(siteConfig.author)}</p>` : '';
  return `
<footer class="site-footer">
  <div class="container"> <!-- .container class defined in theme.css -->
    ${author}
    <p> ${year} ${escapeHtml(siteConfig.title || 'Signum Site')}. Powered by Signum.</p>
  </div>
</footer>
  `;
}

================================================================================

File: themes/default/partials/header.ts
// src/themes/default/partials/header.ts
import { SiteConfigFile, NavLinkItem } from '@/types';
import { escapeHtml } from '../utils';

/**
 * Recursively renders navigation list items, creating nested <ul> for children.
 * @param navLinks An array of NavLinkItem objects.
 * @returns An HTML string of <li> elements.
 */
function renderNavList(navLinks: NavLinkItem[]): string {
  if (!navLinks || navLinks.length === 0) return '';
  
  return navLinks.map(link => `
    <li class="${link.isActive ? 'active' : ''} ${link.children && link.children.length > 0 ? 'has-dropdown' : ''}">
      <a href="${escapeHtml(link.href)}" title="${escapeHtml(link.label)}">
        <span>${escapeHtml(link.label)}</span>
      </a>
      ${link.children && link.children.length > 0 ? `
        <ul class="dropdown">
          ${renderNavList(link.children)}
        </ul>
      ` : ''}
    </li>
  `).join('');
}

export function renderHeader(siteConfig: SiteConfigFile, navLinks: NavLinkItem[], siteRootPath: string): string {
  const siteTitle = escapeHtml(siteConfig.title || 'Signum Site');
  
  const navItemsHtml = renderNavList(navLinks);

  return `
<header class="site-header">
  <div class="container">
    <a href="${escapeHtml(siteRootPath)}" class="site-title-link">
      <span class="site-title">${siteTitle}</span>
    </a>
    <nav class="site-nav">
      <ul>
        ${navItemsHtml}
      </ul>
    </nav>
  </div>
</header>
  `;
}

================================================================================

