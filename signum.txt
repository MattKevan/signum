FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: ios, node_modules, public
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html, *.json, *.hbs
================================================================================

File: types/index.ts
// src/types/index.ts

/**
 * Represents a node in the site's hierarchical structure, as defined in `manifest.json`.
 * Every node is a page, which can have child pages nested under it.
 * Whether a page acts as a "Collection Page" is determined by its frontmatter,
 * not by a property on this node.
 */
export interface StructureNode {
  type: 'page'; // The 'type' is now always 'page'.
  title: string;
  menuTitle?: string;
  path: string; // The full path to the .md file (e.g., 'content/blog.md').
  slug: string; // The URL-friendly version of the path (e.g., 'blog').
  navOrder?: number;
  children?: StructureNode[];
  [key: string]: unknown;
}

/**
 * Represents the theme configuration saved in the manifest, including
 * the theme's name and any user-defined overrides.
 */
export interface ThemeConfig {
  name: string;
  config: {
    [key: string]: string | boolean | number;
  };
}

/**
 * Represents metadata for a layout asset, used for populating UI selectors.
 */
export interface LayoutInfo {
  id: string;
  name: string;
  type: 'page' | 'list' | 'item';
  path: string;
  description?: string;
}

/**
 * Represents metadata for a theme asset, used for populating UI selectors.
 */
export interface ThemeInfo {
  id: string;
  name: string;
  path: string;
}

/**
 * Defines the structure for a remote data source query (future feature).
 */
export interface DataSourceConfig {
  url: string;
  format: 'json' | 'csv';
  array_path?: string; // e.g., "results.items" for nested JSON
}



export interface CollectionConfig {
  item_layout: string;
  item_page_layout: string; 
  sort_by?: string;
  sort_order?: 'asc' | 'desc';
  items_per_page?: number;
  // Future: filter config
}


/**
 * Represents the fields within a content file's YAML frontmatter.
 */
export interface MarkdownFrontmatter {
  title: string;
  layout: string; 
  collection?: CollectionConfig;
  homepage?: boolean;
  [key: string]: unknown;
}

/**
 * Represents a raw markdown file that has been parsed from storage into its constituent parts.
 */
export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

/**
 * Represents a generic raw file (e.g., theme CSS, layout JSON) read from storage.
 */
export interface RawFile {
  path: string;
  content: string;
}

/**
 * Represents the data required for rendering pager controls.
 */
export interface PaginationData {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    hasPrevPage: boolean;
    hasNextPage: boolean;
    prevPageUrl?: string;
    nextPageUrl?: string;
}

/**
 * Represents the main `manifest.json` file for a single site. This is the
 * top-level configuration and site map.
 */
export interface Manifest {
  siteId: string;
  generatorVersion: string;
  title: string;
  description: string;
  author?: string;
  baseUrl?: string;
  theme: ThemeConfig;
  structure: StructureNode[];
  layouts?: LayoutInfo[];
  themes?: ThemeInfo[];
  logo?: ImageRef;
  favicon?: ImageRef;
  settings?: {
    imageService?: 'local' | 'cloudinary';
    cloudinary?: {
      cloudName?: string;
    },
    [key: string]: unknown; 
  };
}

/**
 * Represents the complete data for a single site when held in the application's memory.
 */
export interface LocalSiteData {
  siteId: string;
  manifest: Manifest;
  contentFiles?: ParsedMarkdownFile[];
  layoutFiles?: RawFile[];
  themeFiles?: RawFile[];
  secrets?: SiteSecrets;
  // Future: viewFiles?: RawFile[]
}

/**
 * Represents a link used for rendering navigation menus.
 * This is a derived type, not part of the core manifest data.
 */
export interface NavLinkItem {
  href: string;
  label: string;
  isActive?: boolean;
  children?: NavLinkItem[];
}

/**
 * An enum to clearly distinguish the outcome of a page resolution attempt.
 */
export enum PageType {
  SinglePage,
  NotFound,
}

/**
 * Represents the complete, resolved data package for a single page render.
 * This object is the output of the pageResolver and the input for the themeEngine.
 */
export type PageResolutionResult = {
  type: PageType.SinglePage;
  pageTitle: string;
  contentFile: ParsedMarkdownFile;
  layoutPath: string;
  collectionItems?: ParsedMarkdownFile[]; 
  pagination?: PaginationData;
} | {
  type: PageType.NotFound;
  errorMessage: string;
};


/** The storable reference to an uploaded image. This goes in frontmatter. */
export interface ImageRef {
  serviceId: 'local' | 'cloudinary';
  src: string;
  alt?: string;
  width?: number;
  height?: number;
}

/** Transformation options requested by a template's image helper. */
export interface ImageTransformOptions {
  width?: number;
  height?: number;
  // --- FIX: Adopt Cloudinary's 'crop' and 'gravity' terminology ---
  crop?: 'fill' | 'fit' | 'scale'; // 'scale' is a simple resize, 'fit' is letterbox, 'fill' is crop
  gravity?: 'center' | 'north' | 'south' | 'east' | 'west' | 'auto';
  format?: 'webp' | 'avif' | 'jpeg';
}

/** The interface/contract that all image services must implement. */
export interface ImageService {
  id: string;
  name: string;
  upload(file: File, siteId: string): Promise<ImageRef>;
  getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions, isExport: boolean): Promise<string>;
  getExportableAssets(siteId: string, allImageRefs: ImageRef[]): Promise<{ path: string; data: Blob; }[]>;
}

// Define the shape of the secrets object for a site.

export interface SiteSecrets {
  cloudinary?: {
    uploadPreset?: string;
  };
}

================================================================================

File: core/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/state/uiStore.ts
// src/core/state/uiStore.ts

import { create, StateCreator } from 'zustand';
import { ReactNode } from 'react';

// --- Helper for screen size ---
const isDesktopView = () => typeof window !== 'undefined' && window.innerWidth >= 1024;

// --- Type Definitions for the store structure ---

// Defines the shape of the data in the sidebar slice
interface SidebarState {
  isLeftOpen: boolean;
  isRightOpen: boolean;
  isLeftAvailable: boolean;
  isRightAvailable: boolean;
  leftSidebarContent: ReactNode | null;
  rightSidebarContent: ReactNode | null;
}

// Defines the actions available in the sidebar slice
interface SidebarActions {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  setLeftAvailable: (available: boolean) => void;
  setRightAvailable: (available: boolean) => void;
  setRightOpen: (isOpen: boolean) => void;
  setLeftSidebarContent: (content: ReactNode | null) => void;
  setRightSidebarContent: (content: ReactNode | null) => void;
}

// Defines the shape of the data in the screen slice
interface ScreenState {
  isDesktop: boolean;
  isInitialized: boolean;
}

// Defines the actions available in the screen slice
interface ScreenActions {
    initializeScreenSize: () => void;
}

// The full store shape, combining state and actions
type UIState = {
    sidebar: SidebarState & SidebarActions;
    screen: ScreenState & ScreenActions;
}

// --- Store Slice Implementations ---

// Creates the sidebar slice of the store
const createSidebarSlice: StateCreator<UIState, [], [], { sidebar: SidebarState & SidebarActions }> = (set, get) => ({
  sidebar: {
    isLeftOpen: isDesktopView(),
    isRightOpen: isDesktopView(),
    isLeftAvailable: false,
    isRightAvailable: false,
    leftSidebarContent: null,
    rightSidebarContent: null,
    toggleLeftSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isLeftOpen: !state.sidebar.isLeftOpen, 
            // On mobile, opening one sidebar closes the other
            isRightOpen: !get().screen.isDesktop && !state.sidebar.isLeftOpen ? false : state.sidebar.isRightOpen 
        }
    })),
    toggleRightSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isRightOpen: !state.sidebar.isRightOpen, 
            isLeftOpen: !get().screen.isDesktop && !state.sidebar.isRightOpen ? false : state.sidebar.isLeftOpen 
        }
    })),
    setLeftAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isLeftAvailable: available }})),
    setRightAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isRightAvailable: available }})),
    setRightOpen: (isOpen) => set(state => ({ sidebar: { ...state.sidebar, isRightOpen: isOpen }})),
    setLeftSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, leftSidebarContent: content }})),
    setRightSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, rightSidebarContent: content }})),

  }
});

// Creates the screen slice of the store
const createScreenSlice: StateCreator<UIState, [], [], { screen: ScreenState & ScreenActions }> = (set, get) => ({
    screen: {
        isDesktop: isDesktopView(),
        isInitialized: false, // Initialize the flag to false
        initializeScreenSize: () => {
          // Add a guard clause to prevent running more than once
          if (get().screen.isInitialized) return;

          // Set the flag to true immediately to block re-entry
          set(state => ({
            screen: { ...state.screen, isInitialized: true }
          }));

          if (typeof window === 'undefined') return;

          const handleResize = () => {
            const desktop = isDesktopView();
            if (desktop !== get().screen.isDesktop) {
              set({
                  screen: { ...get().screen, isDesktop: desktop },
                  sidebar: { ...get().sidebar, isLeftOpen: desktop, isRightOpen: desktop }
                });
            }
          };
          window.addEventListener('resize', handleResize);
          handleResize();
        },
    }
});


// Combine the slices to create the final store
export const useUIStore = create<UIState>()((...a) => ({
    ...createSidebarSlice(...a),
    ...createScreenSlice(...a),
}));

================================================================================

File: core/state/useAppStore.ts
// src/core/state/useAppStore.ts
import { create, StoreApi } from 'zustand';
import { enableMapSet } from 'immer';
import { SiteSlice, createSiteSlice } from './slices/siteSlice';
import { ContentSlice, createContentSlice } from './slices/contentSlice';
import { SecretsSlice, createSecretsSlice } from './slices/secretsSlice';

// Enable Immer for Map and Set support, which is good practice with Zustand.
enableMapSet();

/**
 * The full, combined type for the application's global store.
 * It's an intersection of all slice types plus root-level state.
 */
type AppStore = SiteSlice & ContentSlice & SecretsSlice & {
  isInitialized: boolean;
  initialize: () => void;
  activeSiteId: string | null;
  setActiveSiteId: (siteId: string | null) => void;
};

/**
 * The main application store, built with Zustand.
 * It combines multiple "slices" of state for better organization.
 */
export const useAppStore = create<AppStore>()((set, get, api) => ({
  // --- Root State Properties ---
  isInitialized: false,
  activeSiteId: null,

  // --- Root State Actions ---

  /**
   * Initializes the application state. This should only be called once when the app loads.
   * It prevents re-initialization and triggers the hydration of sites from local storage.
   */
  initialize: () => {
    if (get().isInitialized) {
      return;
    }

    console.log('[AppStore] Initializing application state...');
    
    // Call the hydration action to load sites from storage.
    get().initializeSites().then(() => {
        set({ isInitialized: true });
        console.log('[AppStore] State initialized.');
    });
  },

  /**
   * Sets the currently active site ID for the application.
   * @param siteId The ID of the site to set as active, or null to clear it.
   */
  setActiveSiteId: (siteId) => {
    set({ activeSiteId: siteId });
  },

  // --- Slices ---
  // The store is composed of smaller, focused slices of state.
  // --- FIX: Pass all three arguments (set, get, api) to each slice creator. ---
  // This satisfies the StateCreator type contract and resolves the build errors.
  ...createSiteSlice(set, get, api as StoreApi<AppStore>),
  ...createContentSlice(set, get, api as StoreApi<AppStore>),
  ...createSecretsSlice(set, get, api as StoreApi<AppStore>),
}));

================================================================================

File: core/state/slices/contentSlice.ts
// src/core/state/slices/contentSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { toast } from 'sonner';
import { ParsedMarkdownFile, StructureNode } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import {
  findAndRemoveNode,
  updatePathsRecursively,
  findNodeByPath,
  getNodeDepth,
} from '@/core/services/fileTree.service';
import { SiteSlice } from '@/core/state/slices/siteSlice';
import { stringifyToMarkdown, parseMarkdownString } from '@/lib/markdownParser';

// Helper function remains the same.
const updateContentFilePaths = (files: ParsedMarkdownFile[], pathsToMove: { oldPath: string; newPath:string }[]): ParsedMarkdownFile[] => {
    const pathMap = new Map(pathsToMove.map(p => [p.oldPath, p.newPath]));
    return files.map(file => {
        if (pathMap.has(file.path)) {
            const newPath = pathMap.get(file.path)!;
            const newSlug = newPath.split('/').pop()?.replace('.md', '') ?? '';
            return { ...file, path: newPath, slug: newSlug };
        }
        return file;
    });
};

export interface ContentSlice {
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string) => Promise<boolean>;
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;
  repositionNode: (siteId: string, activeNodePath: string, newParentPath: string | null, newIndex: number) => Promise<void>;
  updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile) => Promise<void>;
}

export const createContentSlice: StateCreator<SiteSlice & ContentSlice, [], [], ContentSlice> = (set, get) => ({

  updateContentFileOnly: async (siteId, savedFile) => {
    await localSiteFs.saveContentFile(siteId, savedFile.path, stringifyToMarkdown(savedFile.frontmatter, savedFile.content));
    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (siteToUpdate?.contentFiles) {
        const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
        if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
        else siteToUpdate.contentFiles.push(savedFile);
      }
    }));
  },

  addOrUpdateContentFile: async (siteId, filePath, rawMarkdownContent) => {
    const site = get().getSiteById(siteId);
    if (!site) return false;

    const isFirstFile = site.manifest.structure.length === 0 && !site.contentFiles?.some(f => f.path === filePath);
    let { frontmatter } = parseMarkdownString(rawMarkdownContent);
    const { content } = parseMarkdownString(rawMarkdownContent);

    if (isFirstFile) {
        toast.info("First page created. It has been set as the permanent homepage.");
        frontmatter = { ...frontmatter, homepage: true };
        rawMarkdownContent = stringifyToMarkdown(frontmatter, content);
    }
    
    const savedFile = await localSiteFs.saveContentFile(siteId, filePath, rawMarkdownContent);
    const isNewFileInStructure = !findNodeByPath(site.manifest.structure, filePath);

    const newManifest = produce(site.manifest, draft => {
      if (isNewFileInStructure) {
        const newNode: StructureNode = {
          type: 'page',
          title: savedFile.frontmatter.title,
          menuTitle: typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined,
          path: filePath,
          slug: savedFile.slug,
          navOrder: draft.structure.length,
          children: [],
        };
        draft.structure.push(newNode);
      } else {
        const findAndUpdate = (nodes: StructureNode[]): void => {
          for (const node of nodes) {
            if (node.path === filePath) {
              node.title = savedFile.frontmatter.title;
              node.menuTitle = typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined;
              return;
            }
            if (node.children) findAndUpdate(node.children);
          }
        };
        findAndUpdate(draft.structure);
      }
    });

    await get().updateManifest(siteId, newManifest);

    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          if (!siteToUpdate.contentFiles) siteToUpdate.contentFiles = [];
          const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
          if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
          else siteToUpdate.contentFiles.push(savedFile);
        }
      }));
    return true;
  },
    
  deleteContentFileAndState: async (siteId, filePath) => {
    const site = get().getSiteById(siteId);
    if (!site) return;
    const fileToDelete = site.contentFiles?.find(f => f.path === filePath);
    if (fileToDelete?.frontmatter.homepage === true) {
      toast.error("Cannot delete the homepage.", { description: "The first page of a site is permanent." });
      return;
    }
    const newManifest = produce(site.manifest, draft => {
      const filterStructure = (nodes: StructureNode[]): StructureNode[] => nodes.filter(node => {
        if (node.path === filePath) return false;
        if (node.children) node.children = filterStructure(node.children);
        return true;
      });
      draft.structure = filterStructure(draft.structure);
    });
    await Promise.all([
      localSiteFs.deleteContentFile(siteId, filePath),
      get().updateManifest(siteId, newManifest),
    ]);
    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate?.contentFiles) {
          siteToUpdate.contentFiles = siteToUpdate.contentFiles.filter(f => f.path !== filePath);
        }
      }));
    toast.success(`Page "${fileToDelete?.frontmatter.title || 'file'}" deleted.`);
  },
    
  repositionNode: async (siteId, activeNodePath, newParentPath, newIndex) => {
    const site = get().getSiteById(siteId);
    if (!site?.contentFiles || !site.manifest) {
      toast.error("Site data not ready. Cannot move page.");
      return;
    }

    const structure = site.manifest.structure;
    const homepagePath = structure[0]?.path;

    if (activeNodePath === homepagePath) {
      toast.error("The homepage cannot be moved.");
      return;
    }

    const nodeToMove = findNodeByPath(structure, activeNodePath);
    if (newParentPath && nodeToMove?.children && nodeToMove.children.length > 0) {
      toast.error("Cannot nest a page that already has its own child pages.", {
        description: "This would create too many levels of nesting."
      });
      return;
    }
    
    if (newParentPath) {
      const parentNode = findNodeByPath(structure, newParentPath);
      if (!parentNode) {
        toast.error("Target parent page for nesting not found.");
        return;
      }
      
      // --- FIX: Update depth check to allow nesting up to 3 levels total. ---
      // A parent can be at depth 0 or 1. A page at depth 2 cannot be a parent.
      const parentDepth = getNodeDepth(structure, newParentPath);
      if (parentDepth >= 2) {
        toast.error("Nesting is limited to two levels deep (3 levels total).");
        return;
      }
      
      const parentFile = site.contentFiles.find(f => f.path === newParentPath);
      if (parentFile?.frontmatter.collection) {
        toast.error("Pages cannot be nested under a Collection Page.");
        return;
      }
    }

    const { found: activeNode, tree: treeWithoutActive } = findAndRemoveNode([...structure], activeNodePath);
    if (!activeNode) return;

    const newParentDir = newParentPath ? newParentPath.replace(/\.md$/, '') : 'content';
    const finalActiveNode = updatePathsRecursively(activeNode, newParentDir);
    
    const pathsToMove: { oldPath: string; newPath: string }[] = [];
    const collectPaths = (newNode: StructureNode, oldNode: StructureNode) => {
        if (newNode.path !== oldNode.path) pathsToMove.push({ oldPath: oldNode.path, newPath: newNode.path });
        if (newNode.children && oldNode.children) newNode.children.forEach((child, i) => collectPaths(child, oldNode.children![i]));
    };
    collectPaths(finalActiveNode, activeNode);
    
    const finalTree = produce(treeWithoutActive, draft => {
        if (newParentPath) {
            const parent = findNodeByPath(draft, newParentPath);
            if (parent) {
                parent.children = parent.children || [];
                parent.children.splice(newIndex, 0, finalActiveNode);
            }
        } else {
            draft.splice(newIndex, 0, finalActiveNode);
        }
    });
    
    try {
      if (pathsToMove.length > 0) await localSiteFs.moveContentFiles(siteId, pathsToMove);
      const newManifest = { ...site.manifest, structure: finalTree };
      const updatedContentFiles = updateContentFilePaths(site.contentFiles, pathsToMove);
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = newManifest;
          siteToUpdate.contentFiles = updatedContentFiles;
        }
      }));
      await localSiteFs.saveManifest(siteId, newManifest);
      toast.success("Site structure updated successfully.");
    } catch (error) {
      console.error("Failed to reposition node:", error);
      toast.error("An error occurred while updating the site structure. Reverting changes.");
      get().loadSite(siteId);
    }
  },
});

================================================================================

File: core/state/slices/siteSlice.ts
// src/core/state/slices/siteSlice.ts

import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { LocalSiteData, Manifest } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { loadSiteSecretsFromDb } from '@/core/services/siteSecrets.service';
import { toast } from 'sonner';

export interface SiteSlice {
  sites: LocalSiteData[];
  loadingSites: Set<string>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
  loadSite: (siteId: string) => Promise<void>;
  addSite: (siteData: LocalSiteData) => Promise<void>;
  updateManifest: (siteId: string, manifest: Manifest) => Promise<void>;
  deleteSiteAndState: (siteId: string) => Promise<void>;
  initializeSites: () => Promise<void>;
}

export const createSiteSlice: StateCreator<SiteSlice, [], [], SiteSlice> = (set, get) => ({
  sites: [],
  loadingSites: new Set(),
  getSiteById: (siteId) => get().sites.find(s => s.siteId === siteId),

  initializeSites: async () => {
    // ... (this function is correct, no changes needed)
    try {
      const manifests = await localSiteFs.loadAllSiteManifests();
      const initialSites: LocalSiteData[] = manifests.map(manifest => ({
        siteId: manifest.siteId,
        manifest: manifest,
      }));
      set({ sites: initialSites });
    } catch (error) {
      console.error("Failed to initialize sites from storage:", error);
      toast.error("Could not load your sites. Storage might be corrupted.");
    }
  },

  loadSite: async (siteId) => {
    // --- FIX: This logic is now non-destructive ---
    if (get().loadingSites.has(siteId)) return;
    
    const existingSite = get().getSiteById(siteId);
    // Only fetch if core content files aren't already loaded.
    if (existingSite && existingSite.contentFiles) return;
    
    set(produce(draft => { draft.loadingSites.add(siteId); }));

    try {
      const manifest = await localSiteFs.getManifestById(siteId);
      if (!manifest) throw new Error(`Failed to load manifest for siteId: ${siteId}`);
      
      const [contentFiles, layoutFiles, themeFiles, secrets] = await Promise.all([
        localSiteFs.getSiteContentFiles(siteId),
        localSiteFs.getSiteLayoutFiles(siteId),
        localSiteFs.getSiteThemeFiles(siteId),
        loadSiteSecretsFromDb(siteId)
      ]);

      const loadedData = { manifest, contentFiles, layoutFiles, themeFiles, secrets };

      set(produce((draft: SiteSlice) => {
        const siteIndex = draft.sites.findIndex(s => s.siteId === siteId);
        if (siteIndex > -1) {
          // Instead of replacing, we MERGE the loaded data into the existing object.
          // This preserves any other data that might already be in the in-memory state.
          draft.sites[siteIndex] = { ...draft.sites[siteIndex], ...loadedData };
        } else {
          // If it's a new site being loaded, add it.
          draft.sites.push({ siteId, ...loadedData });
        }
      }));
    } catch (error) {
      toast.error(`Could not load site data for ID: ${siteId}`);
      console.error(`[AppStore.loadSite] Error during load for ${siteId}:`, error);
    } finally {
      set(produce(draft => { draft.loadingSites.delete(siteId); }));
    }
  },
  
  // --- This action is now safe to use because loadSite is no longer destructive ---
  updateManifest: async (siteId, newManifest) => {
    await localSiteFs.saveManifest(siteId, newManifest);
    set(produce((draft: SiteSlice) => {
      const site = draft.sites.find(s => s.siteId === siteId);
      if (site) site.manifest = newManifest;
    }));
  },

  // ... (addSite and deleteSiteAndState remain the same)
  addSite: async (newSiteData) => {
    await localSiteFs.saveSite(newSiteData);
    set(produce((draft: SiteSlice) => {
      const siteIndex = draft.sites.findIndex(s => s.siteId === newSiteData.siteId);
      if (siteIndex > -1) {
        draft.sites[siteIndex] = newSiteData;
      } else {
        draft.sites.push(newSiteData);
      }
    }));
  },

  deleteSiteAndState: async (siteId) => {
    await localSiteFs.deleteSite(siteId);
    set(produce((draft: SiteSlice) => {
      draft.sites = draft.sites.filter(s => s.siteId !== siteId);
    }));
  },
});

================================================================================

File: core/state/slices/secretsSlice.ts
// src/core/state/slices/secretsSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { SiteSlice } from './siteSlice';
import { SiteSecrets, saveSiteSecretsToDb } from '@/core/services/siteSecrets.service';
import { toast } from 'sonner';

export interface SecretsSlice {
  /**
   * Updates the secrets for a site, persisting them to storage first
   * and then updating the in-memory state.
   * @param siteId The ID of the site to update.
   * @param secrets The new secrets object to save.
   */
  updateSiteSecrets: (siteId: string, secrets: SiteSecrets) => Promise<void>;
}

export const createSecretsSlice: StateCreator<SiteSlice & SecretsSlice, [], [], SecretsSlice> = (set) => ({
  updateSiteSecrets: async (siteId, newSecrets) => {
    try {
      await saveSiteSecretsToDb(siteId, newSecrets);
      set(produce((draft: SiteSlice) => {
        const site = draft.sites.find(s => s.siteId === siteId);
        if (site) {
          site.secrets = newSecrets;
        }
      }));
      toast.success("Secret settings saved successfully!");
    } catch (error) {
      console.error("Failed to save site secrets:", error);
      toast.error("Could not save secret settings.");
      throw error;
    }
  },
});

================================================================================

File: core/components/Navbar.tsx
// src/components/core/Navbar.tsx
'use client';

import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation'; // Import useRouter
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { Button } from '@/core/components/ui/button';
import { Input } from '@/core/components/ui/input'; // Import Input
import React, { useState } from 'react';

// ... (NavLink component remains the same) ...
const NavLink: React.FC<{ href: string; label: string; icon?: React.ReactNode; }> = ({ href, label, icon }) => {
  const pathname = usePathname();
  const isActive = pathname === href || (href !== '/' && pathname.startsWith(href));
  return (
    <Button  className={`justify-start ${isActive ? 'bg-accent text-accent-foreground' : ''}`}>
      <Link href={href} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};


export default function Navbar() {
  const router = useRouter();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim()); // Basic URL validation
        // We need a way to signify this is a remote URL to our browsing pages.
        // Option 1: Special prefix for siteId, e.g., "remote::http://localhost:8080"
        // Option 2: A different route, e.g., /browse/remote?url=...
        // Option 3: Pass state via router.push (can be complex with SSR/layouts)

        // Let's use Option 1: Prefix the siteId with "remote@" or similar marker
        // and encode the URL. The browsing page will then decode it.
        const encodedUrl = encodeURIComponent(url.origin); // Use origin (scheme + hostname + port)
        router.push(`/remote@${encodedUrl}`); // Navigate to /remote@http%3A%2F%2Flocalhost%3A8080
        setRemoteUrl(''); // Clear input
      } catch (error) {
        alert("Invalid URL entered.");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        <Link href="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
        </Link>
        
        {/* Remote Site URL Input */}
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Signum site URL (e.g., http://localhost:8080)"
              className="pl-9" // Padding for the icon
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          <NavLink href="/" label="Dashboard" icon={<Home className="h-4 w-4" />} />
          {/* ... other links ... */}
        </nav>

        <div className="md:hidden">
          <Button  >
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: core/components/HashLink.tsx
// src/core/components/ui/HashLink.tsx
'use client';

import { AnchorHTMLAttributes, FC, forwardRef } from 'react';
import { cn } from '@/lib/utils';

interface HashLinkProps extends AnchorHTMLAttributes<HTMLAnchorElement> {
  // 'to' will be the path without the hash, e.g., "/sites/123"
  to: string;
}

export const HashLink: FC<HashLinkProps> = forwardRef<HTMLAnchorElement, HashLinkProps>(
  ({ to, children, className, ...props }, ref) => {
    // The href is constructed with the required # prefix.
    // We remove a leading slash from 'to' if it exists, as the # acts as the root.
    const href = `#${to.startsWith('/') ? to : `/${to}`}`;
    return (
      <a href={href} className={cn(className)} ref={ref} {...props}>
        {children}
      </a>
    );
  }
);
HashLink.displayName = 'HashLink';

================================================================================

File: core/components/Footer.tsx
// src/components/core/Footer.tsx
import Link from 'next/link';
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p>Â© {currentYear} Signum Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: core/components/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: core/components/ErrorBoundary.tsx
// src/components/core/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/core/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    // Update state so the next render will show the fallback UI.
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // You can also log the error to an error reporting service
    console.error("Uncaught error:", error, errorInfo);
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: undefined });
    // Optionally, you could try to trigger a reload or navigate home
    // window.location.assign('/'); 
  }

  public render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center bg-destructive/10 border border-destructive rounded-lg">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h1 className="text-2xl font-bold text-destructive-foreground">Something went wrong.</h1>
          <p className="text-muted-foreground mt-2 mb-4">
            An unexpected error occurred. Please try refreshing the page.
          </p>
          {this.state.error && (
            <details className="w-full max-w-lg text-left bg-background p-2 rounded border mb-4">
                <summary className="cursor-pointer text-sm font-medium">Error Details</summary>
                <pre className="mt-2 text-xs text-muted-foreground whitespace-pre-wrap break-all">
                    {this.state.error.message}
                </pre>
            </details>
          )}
          <Button onClick={() => window.location.reload()} variant="destructive">
            Refresh Page
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

================================================================================

File: core/components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/components/ui/link.tsx
import * as Headless from '@headlessui/react'
import NextLink, { type LinkProps } from 'next/link'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: LinkProps & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <NextLink {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})

================================================================================

File: core/components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: core/components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: core/components/ui/accordion.tsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0 data-[state=closed]:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex border-b">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 text-xs font-semibold uppercase tracking-wider text-muted-foreground transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 py-2 px-2",
          className
        )}
        {...props}
      >
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0 transition-transform duration-200 mr-1" />
        {children}
        
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm py-4 px-3"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================

File: core/components/ui/switch.tsx
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


================================================================================

File: core/components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: core/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: core/components/ui/dropdown-menu.tsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


================================================================================

File: core/components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: core/components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: core/components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: core/hooks/useAutosave.ts
// src/hooks/useAutosave.ts
'use client';

import { useEffect, useRef } from 'react';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';

interface AutosaveParams<TData> {
  /** The generic data to be saved. */
  dataToSave: TData;
  /** A flag indicating if there are pending changes. */
  hasUnsavedChanges: boolean;
  /** A flag to prevent saving if the content isn't in a saveable state. */
  isSaveable: boolean;
  /** The function that performs the save operation with the generic data. */
  onSave: (data: TData) => Promise<void>;
}

/**
 * A generic custom hook to handle autosaving content after a specified delay.
 * It encapsulates the timer logic and effect management for saving drafts.
 */
export function useAutosave<TData>({ dataToSave, hasUnsavedChanges, isSaveable, onSave }: AutosaveParams<TData>) {
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (autosaveTimeoutRef.current) {
      clearTimeout(autosaveTimeoutRef.current);
    }

    if (hasUnsavedChanges && isSaveable) {
      autosaveTimeoutRef.current = setTimeout(() => {
        onSave(dataToSave);
      }, AUTOSAVE_DELAY);
    }

    return () => {
      if (autosaveTimeoutRef.current) {
        clearTimeout(autosaveTimeoutRef.current);
      }
    };
  }, [dataToSave, hasUnsavedChanges, isSaveable, onSave]);
}

================================================================================

File: core/hooks/useInitialiseUIStore.ts
'use client';

import { useUIStore } from '@/core/state/uiStore';
import { useEffect } from 'react';

export function useInitialiseUIStore() {
  const initialize = useUIStore((state) => state.screen.initializeScreenSize);
  const isInitialized = useUIStore((state) => state.screen.isInitialized);

  useEffect(() => {
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);
}   

================================================================================

File: core/hooks/useHashNavigation.ts
// src/core/hooks/useHashNavigation.ts
'use client';

import { useState, useEffect } from 'react';

// A helper to safely get the hash and clean it up.
function getCleanHash() {
  if (typeof window === 'undefined') return '/';
  // Get the hash, remove the leading #, and ensure it starts with a /
  const hash = window.location.hash.substring(1);
  return hash.startsWith('/') ? hash : `/${hash}`;
}

export function useHashNavigation() {
  const [currentPath, setCurrentPath] = useState(getCleanHash());

  useEffect(() => {
    const handleHashChange = () => {
      setCurrentPath(getCleanHash());
    };

    // Listen for changes to the hash
    window.addEventListener('hashchange', handleHashChange);
    // Set the initial path when the component mounts
    handleHashChange();

    return () => {
      window.removeEventListener('hashchange', handleHashChange);
    };
  }, []);

  return currentPath;
}

================================================================================

File: core/services/theme.service.ts
// src/core/services/theme.service.ts
import { getJsonAsset, ThemeManifest } from './configHelpers.service';
import { RJSFSchema } from '@rjsf/utils';
import { ThemeConfig } from '@/types';

function getDefaultsFromSchema(schema: RJSFSchema | undefined): Record<string, any> {
  if (!schema || !schema.properties) return {};
  const defaults: Record<string, any> = {};
  for (const key in schema.properties) {
    const property = schema.properties[key];
    if (typeof property === 'object' && 'default' in property) {
      defaults[key] = property.default;
    }
  }
  return defaults;
}

/**
 * Gets the complete, merged data needed to initialize a form or render a page.
 * It fetches the latest schema and defaults from the theme file, then intelligently
 * merges them with the user's saved configuration from the manifest.
 */
export async function getMergedThemeDataForForm(
  themeName: string,
  userSavedConfig: ThemeConfig['config']
): Promise<{
  schema: RJSFSchema | null;
  initialConfig: ThemeConfig['config'];
}> {
  const mockSiteData = { manifest: { theme: { name: themeName } } };
  const themeManifest = await getJsonAsset<ThemeManifest>(
    mockSiteData as any, 'theme', themeName, 'theme.json'
  );
  
  // [THE FIX] The optional chaining `?.` correctly produces `undefined`, which is what
  // getDefaultsFromSchema expects. We no longer convert this to `null`.
  const schema = themeManifest?.appearanceSchema;

  const defaults = getDefaultsFromSchema(schema);
  const initialConfig = { ...defaults, ...userSavedConfig };
  
  return { schema: schema || null, initialConfig };
}

================================================================================

File: core/services/configHelpers.service.ts
// src/core/services/configHelpers.service.ts

import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { CORE_LAYOUTS, CORE_THEMES, BASE_SCHEMA } from '@/config/editorConfig';
import {
    LocalSiteData,
    Manifest,
    LayoutInfo,
    ThemeInfo,
    RawFile,
} from '@/types';

// --- Type Definitions ---

export type StrictUiSchema = UiSchema & { 'ui:groups'?: { title: string; fields: string[] }[] };

export type AssetFileType =
  | 'manifest'
  | 'base'
  | 'template'
  | 'partial'
  | 'stylesheet'
  | 'script'
  | 'asset';

export interface AssetFile {
  path: string;
  type: AssetFileType;
  name?: string;
}

/** The base properties shared by all asset manifests. */
export interface BaseAssetManifest {
  name: string;
  version: string;
  description?: string;
  icon?: string;
  files: AssetFile[];
}

/** The structure of a theme.json file. */
export interface ThemeManifest extends BaseAssetManifest {
  appearanceSchema?: RJSFSchema;
}

/** The structure of a layout.json file. */
export interface LayoutManifest extends BaseAssetManifest {
  id: string;
  layoutType: 'page' | 'list' | 'item';
  schema?: RJSFSchema;
  uiSchema?: StrictUiSchema;
}

export type SiteDataForAssets = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;

// --- Helper Functions ---

const fileContentCache = new Map<string, Promise<string | null>>();

// --- FIX: Exported the helper functions for use in siteBackup.service ---
/**
 * Checks if a given theme path corresponds to a core (built-in) theme.
 * @param path The path/ID of the theme (e.g., 'default').
 * @returns {boolean} True if the theme is a core theme.
 */
export const isCoreTheme = (path: string) => CORE_THEMES.some((t: ThemeInfo) => t.path === path);

/**
 * Checks if a given layout path corresponds to a core (built-in) layout.
 * @param path The path/ID of the layout (e.g., 'page', 'listing').
 * @returns {boolean} True if the layout is a core layout.
 */
export const isCoreLayout = (path: string) => CORE_LAYOUTS.some((l: LayoutInfo) => l.id === path);

/**
 * Provides a base schema for all content, ensuring common fields are available.
 * @returns An object containing the base RJSFSchema and UiSchema.
 */
function getBaseSchema(): { schema: RJSFSchema, uiSchema: UiSchema } {
    return BASE_SCHEMA;
}

/**
 * Fetches the raw string content of a theme or layout asset.
 * It intelligently fetches from either the `/public` directory (for core assets)
 * or the `LocalSiteData` object (for user-provided custom assets), with caching.
 */
export async function getAssetContent(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<string | null> {
    const isCore = assetType === 'theme' ? isCoreTheme(path) : isCoreLayout(path);
    const sourcePath = `/${assetType}s/${path}/${fileName}`;

    if (isCore) {
      if (fileContentCache.has(sourcePath)) {
        return fileContentCache.get(sourcePath)!;
      }
      const promise = fetch(sourcePath)
        .then(res => res.ok ? res.text() : null)
        .catch(() => null);
      fileContentCache.set(sourcePath, promise);
      return promise;
    } else {
      const fileStore: RawFile[] | undefined =
          assetType === 'theme' ? siteData.themeFiles
          : assetType === 'layout' ? siteData.layoutFiles
          : undefined;

      const fullPath = `${assetType}s/${path}/${fileName}`;
      return fileStore?.find(f => f.path === fullPath)?.content ?? null;
    }
}

/**
 * A generic function to fetch and parse any JSON asset manifest (theme, layout).
 */
export async function getJsonAsset<T>(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<T | null> {
    const content = await getAssetContent(siteData, assetType, path, fileName);
    if (!content) return null;
    try {
      return JSON.parse(content) as T;
    } catch (e) {
      console.error(`Failed to parse JSON from ${assetType}/${path}/${fileName}:`, e);
      return null;
    }
}

/**
 * Merges a layout's specific schema with the universal base schema.
 */
function mergeSchemas(base: RJSFSchema, specific?: RJSFSchema): RJSFSchema {
    if (!specific) return { ...base };
    return {
        ...base,
        ...specific,
        properties: { ...(base.properties || {}), ...(specific.properties || {}) },
        required: [...new Set([...(base.required || []), ...(specific.required || [])])]
    };
}

// --- Public API ---

/**
 * Gets a list of all available themes (core and custom).
 */
export function getAvailableThemes(manifest?: Manifest): ThemeInfo[] {
  const available = [...CORE_THEMES];
  if (manifest?.themes) {
    const customThemes = manifest.themes.filter(ct => !available.some(coreT => coreT.path === ct.path));
    available.push(...customThemes);
  }
  return available;
}

/**
 * Fetches and processes the manifest for a specific layout, merging its
 * schema with the base content schema.
 */
export async function getLayoutManifest(siteData: SiteDataForAssets, layoutPath: string): Promise<LayoutManifest | null> {
    const layoutManifest = await getJsonAsset<LayoutManifest>(siteData, 'layout', layoutPath, 'layout.json');
    const baseSchemaData = getBaseSchema();

    if (!layoutManifest) {
      // Fallback for a missing layout.json.
      return {
          id: layoutPath,
          name: layoutPath,
          version: '1.0.0',
          layoutType: 'page',
          files: [],
          schema: baseSchemaData.schema,
          uiSchema: baseSchemaData.uiSchema,
      }
    }

    layoutManifest.schema = mergeSchemas(baseSchemaData.schema, layoutManifest.schema);
    layoutManifest.uiSchema = { ...baseSchemaData.uiSchema, ...(layoutManifest.uiSchema || {}) };

    if (layoutManifest.schema?.properties) {
      delete layoutManifest.schema.properties.title;
      delete layoutManifest.schema.properties.description;
      delete layoutManifest.schema.properties.slug;
    }

    return { ...layoutManifest, id: layoutPath };
}

/**
 * Gets a list of the full manifest objects for all available layouts,
 * optionally filtered by a specific layout type.
 */
export async function getAvailableLayouts(
  siteData: SiteDataForAssets,
  type?: LayoutManifest['layoutType']
): Promise<LayoutManifest[]> {
  const coreLayoutIds = CORE_LAYOUTS.map(l => l.id);
  const customLayoutIds = siteData.manifest.layouts?.map(l => l.id) || [];
  const allLayoutIds = [...new Set([...coreLayoutIds, ...customLayoutIds])];

  const manifestPromises = allLayoutIds.map(layoutId =>
    getLayoutManifest(siteData, layoutId)
  );

  const allManifests = (await Promise.all(manifestPromises))
    .filter((m): m is LayoutManifest => m !== null);

  if (type) {
    return allManifests.filter(m => m.layoutType === type);
  }

  return allManifests;
}

================================================================================

File: core/services/blocknote.service.ts
// src/core/services/blocknote.service.ts
import { Block, BlockNoteEditor } from '@blocknote/core';

/**
 * Converts a Markdown string into an array of Blocknote `Block` objects.
 * This works by creating a headless editor and using the `tryParseMarkdownToBlocks`
 * instance method.
 *
 * @param markdown The Markdown string to convert.
 * @returns A promise that resolves to an array of Blocks.
 */
export async function markdownToBlocks(markdown: string): Promise<Block[]> {
  // If the incoming markdown is empty, return an empty array to avoid
  // creating an unnecessary editor instance.
  if (!markdown || markdown.trim() === '') {
    return [];
  }
  
  const editor = await BlockNoteEditor.create();
  const blocks = await editor.tryParseMarkdownToBlocks(markdown);
  
  return blocks;
}

/**
 * Converts an array of Blocknote `Block` objects into a Markdown string.
 * This works by creating a headless editor pre-populated with the blocks
 * and then using its instance method to serialize them to Markdown.
 *
 * @param blocks The array of Blocks to convert.
 * @returns A promise that resolves to a Markdown string.
 */
export async function blocksToMarkdown(blocks: Block[]): Promise<string> {
  // If the blocks array is empty or undefined, return an empty string immediately.
  if (!blocks || blocks.length === 0) {
    return "";
  }
  
  // Only create an editor instance if there are blocks to process.
  const editor = await BlockNoteEditor.create({
    initialContent: blocks,
  });
  
  const markdown = await editor.blocksToMarkdownLossy();

  return markdown;
}

================================================================================

File: core/services/siteExporter.service.ts
// src/core/services/siteExporter.service.ts
import JSZip from 'jszip';
import { LocalSiteData, ParsedMarkdownFile, StructureNode, ImageRef, ThemeConfig } from '@/types';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { flattenTree, FlattenedNode } from './fileTree.service';
import { resolvePageContent } from './pageResolver.service';
import { PageType } from '@/types';
import { render } from './theme-engine/themeEngine.service';
import { getUrlForNode } from './urlUtils.service';
import { getAssetContent, getJsonAsset, ThemeManifest, LayoutManifest } from './configHelpers.service';
import { getActiveImageService } from '@/core/services/images/images.service';
import { getMergedThemeDataForForm } from './theme.service';

/**
 * Escapes special XML characters in a string to make it safe for RSS/Sitemap feeds.
 * @param {unknown} str - The input string to escape.
 * @returns {string} The escaped string.
 */
function escapeForXml(str: unknown): string {
    if (str === undefined || str === null) return '';
    return String(str).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/'/g, "'");
}

/**
 * A helper function to bundle all files for a given asset (theme or layout)
 * into a specified ZIP folder. It reads the asset's manifest to determine which files to include.
 * @param {JSZip} zip - The root JSZip instance.
 * @param {LocalSiteData} siteData - The complete site data.
 * @param {'theme' | 'layout'} assetType - The type of asset to bundle.
 * @param {string} assetId - The ID of the asset (e.g., 'default', 'listing').
 */
async function bundleAsset(zip: JSZip, siteData: LocalSiteData, assetType: 'theme' | 'layout', assetId: string) {
    const assetFolder = zip.folder('_signum')?.folder(`${assetType}s`)?.folder(assetId);
    if (!assetFolder) return;

    const manifestFileName = assetType === 'theme' ? 'theme.json' : 'layout.json';
    const manifest = await getJsonAsset<ThemeManifest | LayoutManifest>(siteData, assetType, assetId, manifestFileName);

    if (!manifest || !manifest.files) {
        console.warn(`Asset manifest for ${assetType}/${assetId} is missing or has no 'files' array. Skipping bundle.`);
        return;
    }

    for (const file of manifest.files) {
        const content = await getAssetContent(siteData, assetType, assetId, file.path);
        if (content) {
            assetFolder.file(file.path, content);
        } else {
            console.warn(`Could not find content for declared file: ${assetType}s/${assetId}/${file.path}`);
        }
    }
}

/**
 * Recursively finds all unique ImageRef objects within a site's manifest and content files.
 * @param {LocalSiteData} siteData - The site data to search through.
 * @returns {ImageRef[]} An array of all unique ImageRef objects found.
 */
function findAllImageRefs(siteData: LocalSiteData): ImageRef[] {
  const refs = new Set<ImageRef>();
  const visited = new Set<object>();

  function find(obj: unknown) {
    if (!obj || typeof obj !== 'object' || visited.has(obj)) return;
    visited.add(obj);

    if ('serviceId' in obj && 'src' in obj) {
        refs.add(obj as ImageRef);
    }
    Object.values(obj).forEach(value => find(value));
  }

  find(siteData.manifest);
  siteData.contentFiles?.forEach(file => find(file.frontmatter));
  return Array.from(refs);
}

/**
 * Compiles a full Signum site into a downloadable ZIP archive, ready for static deployment.
 *
 * This function follows the "Merge on Export" principle. It takes the user's saved manifest,
 * fetches the latest defaults from the canonical theme file, and merges them to create a
 * final, up-to-date configuration for the exported site.
 *
 * @param {LocalSiteData} siteData - The site data from the global store.
 * @returns {Promise<Blob>} A promise that resolves to the generated ZIP file as a Blob.
 */
export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
    const zip = new JSZip();
    
    // --- "Merge on Export" Logic ---
     const savedThemeConfig = siteData.manifest.theme;
    
    // [FIX] Call the correct function to get the fully merged config.
    const { initialConfig: finalMergedConfig } = await getMergedThemeDataForForm(
        savedThemeConfig.name, 
        savedThemeConfig.config
    );
    
    const synchronizedManifest = { 
        ...siteData.manifest, 
        theme: { ...savedThemeConfig, config: finalMergedConfig }
    };
    const synchronizedSiteData = { ...siteData, manifest: synchronizedManifest };
    const { contentFiles } = synchronizedSiteData;
    // ---

    if (!contentFiles) {
        throw new Error("Cannot export site: content files are not loaded.");
    }
    
    const allRenderableNodes: FlattenedNode[] = flattenTree(synchronizedManifest.structure, contentFiles);

    // --- 1. Generate All HTML Pages ---
    for (const node of allRenderableNodes) {
        // ... no changes to this loop ...
        const initialResolution = resolvePageContent(synchronizedSiteData, node.slug.split('/'));
        if (initialResolution.type === PageType.NotFound) continue;

        const isPaginated = !!(initialResolution.pagination && initialResolution.pagination.totalPages > 1);
        if (isPaginated) {
            const totalPages = initialResolution.pagination!.totalPages;
            for (let i = 1; i <= totalPages; i++) {
                const resolutionForPage = resolvePageContent(synchronizedSiteData, node.slug.split('/'), i);
                if (resolutionForPage.type === PageType.NotFound) continue;
                const outputPath = getUrlForNode(node, synchronizedManifest, true, i);
                const depth = (outputPath.match(/\//g) || []).length;
                const relativePrefix = '../'.repeat(depth > 0 ? depth - 1 : 0);
                const finalHtml = await render(synchronizedSiteData, resolutionForPage, { siteRootPath: '/', isExport: true, relativeAssetPath: relativePrefix });
                zip.file(outputPath, finalHtml);
            }
        } else {
            const outputPath = getUrlForNode(node, synchronizedManifest, true);
            const depth = (outputPath.match(/\//g) || []).length;
            const relativePrefix = '../'.repeat(depth > 0 ? depth - 1 : 0);
            const finalHtml = await render(synchronizedSiteData, initialResolution, { siteRootPath: '/', isExport: true, relativeAssetPath: relativePrefix });
            zip.file(outputPath, finalHtml);
        }
    }

    // --- 2. Add _signum Source Content and Asset Files ---
    const signumFolder = zip.folder('_signum');
    if (signumFolder) {
        signumFolder.file('manifest.json', JSON.stringify(synchronizedManifest, null, 2));
        contentFiles.forEach(file => {
            signumFolder.file(file.path, stringifyToMarkdown(file.frontmatter, file.content));
        });
    }

    const allImageRefs = findAllImageRefs(synchronizedSiteData);
    if (allImageRefs.length > 0) {
        const imageService = getActiveImageService(synchronizedManifest);
        const assetsToBundle = await imageService.getExportableAssets(synchronizedSiteData.siteId, allImageRefs);
        for (const asset of assetsToBundle) {
            zip.file(asset.path, asset.data);
        }
    }

    const layoutIds = new Set<string>();
    contentFiles.forEach(file => {
        if (file.frontmatter.layout) layoutIds.add(file.frontmatter.layout);
        if (file.frontmatter.collection?.item_layout) layoutIds.add(file.frontmatter.collection.item_layout);
    });

    await bundleAsset(zip, synchronizedSiteData, 'theme', synchronizedManifest.theme.name);
    for (const layoutId of Array.from(layoutIds)) {
        await bundleAsset(zip, synchronizedSiteData, 'layout', layoutId);
    }

    // --- 3. Generate RSS Feed and Sitemap ---
    const siteBaseUrl = synchronizedManifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
    
    const rssItems = allRenderableNodes
        .map(node => ({ node, file: contentFiles.find(f => f.path === node.path) }))
        // [THE FIX] The type predicate now correctly uses FlattenedNode and asserts
        // that `file` is of type ParsedMarkdownFile, not undefined.
        .filter((item): item is { node: FlattenedNode; file: ParsedMarkdownFile } => 
            !!item.file && !!item.file.frontmatter.date && !item.file.frontmatter.collection
        )
        // With the fix above, TypeScript now knows `a.file` and `b.file` are defined.
        .sort((a, b) => new Date(b.file.frontmatter.date as string).getTime() - new Date(a.file.frontmatter.date as string).getTime())
        .slice(0, 20)
        // And it knows `item.file` is defined here as well.
        .map(item => {
            const relativeUrl = getUrlForNode(item.node, synchronizedManifest, false);
            const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
            return `<item><title>${escapeForXml(item.node.title)}</title><link>${escapeForXml(absoluteUrl)}</link><guid isPermaLink="true">${escapeForXml(absoluteUrl)}</guid><pubDate>${new Date(item.file.frontmatter.date as string).toUTCString()}</pubDate><description>${escapeForXml(item.file.frontmatter.description)}</description></item>`;
        }).join('');

    const rssFeed = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(synchronizedManifest.title)}</title><link>${siteBaseUrl}</link><description>${escapeForXml(synchronizedManifest.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrl).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;
    zip.file('rss.xml', rssFeed);

    const sitemapUrls = allRenderableNodes.map(node => {
        const file = contentFiles.find(f => f.path === node.path);
        const relativeUrl = getUrlForNode(node, synchronizedManifest, false);
        const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
        const lastMod = (file?.frontmatter.date as string || new Date().toISOString()).split('T')[0];
        return `<url><loc>${escapeForXml(absoluteUrl)}</loc><lastmod>${lastMod}</lastmod></url>`;
    }).join('');
    const sitemapXml = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
    zip.file('sitemap.xml', sitemapXml);

    return zip.generateAsync({ type: 'blob' });
}

================================================================================

File: core/services/urlUtils.service.ts
// src/core/services/urlUtils.service.ts
import { Manifest } from '@/types';

/**
 * Generates a URL for a given site node based on its position and context.
 * This is a critical utility for both the live preview and the final static site export.
 *
 * It implements the "First Page is Homepage" rule:
 * - The very first page in the site's root structure (`manifest.structure[0]`) is
 *   always treated as the homepage and mapped to the root URL (`/` or `index.html`).
 * - All other pages are mapped to subdirectories based on their slug for clean URLs
 *   (e.g., a page with slug 'about' becomes '/about/').
 *
 * @param node - The `StructureNode` object for which to generate a URL. It must have `path` and `slug`.
 * @param manifest - The complete site manifest. This is required to identify the homepage by its position.
 * @param isExport - A boolean indicating if the URL is for a static export (e.g., `about/index.html`) or a live preview (e.g., `/about`).
 * @param pageNumber - An optional page number for generating paginated links (e.g., `/blog/page/2`).
 * @returns A string representing the final URL segment or filename.
 */
export function getUrlForNode(
  node: { path: string; slug: string },
  manifest: Manifest,
  isExport: boolean,
  pageNumber?: number,
): string {
  // --- Homepage Check ---
  // The homepage is defined as the first node in the root of the manifest's structure array.
  // The optional chaining `?.` safely handles an empty structure for a brand new site.
  const isDesignatedHomepage = manifest.structure[0]?.path === node.path;

  if (isDesignatedHomepage) {
    // --- Homepage URL Logic ---
    if (isExport) {
      // For a paginated homepage, page 2 and beyond go into a subdirectory.
      // e.g., /page/2/index.html
      if (pageNumber && pageNumber > 1) {
        return `page/${pageNumber}/index.html`;
      }
      // The homepage itself is always the root index.html file.
      return 'index.html';
    } else {
      // Live Preview URL
      if (pageNumber && pageNumber > 1) {
        return `page/${pageNumber}`;
      }
      // For the live preview, the root URL is represented by an empty string,
      // which the browser/router interprets as '/'.
      return '';
    }
  }

  // --- Logic for All Other Pages ---
  const baseSlug = node.slug;

  if (isExport) {
    // Paginated collection pages, e.g., blog/page/2/index.html
    if (pageNumber && pageNumber > 1) {
      return `${baseSlug}/page/${pageNumber}/index.html`;
    }
    // All other pages are placed in their own directory with an index.html
    // to create clean URLs, e.g., /about-us/
    return `${baseSlug}/index.html`;
  } else {
    // Live Preview URLs for other pages
    if (pageNumber && pageNumber > 1) {
      return `${baseSlug}/page/${pageNumber}`;
    }
    // A standard page preview URL is just its slug, e.g., /about-us
    return baseSlug;
  }
}

================================================================================

File: core/services/siteBackup.service.ts
// src/core/services/siteBackup.service.ts
import JSZip from 'jszip';
import {
  LocalSiteData,
  SiteSecrets,
  Manifest,
  ParsedMarkdownFile,
  RawFile,
} from '@/types';
import { stringifyToMarkdown, parseMarkdownString } from '@/lib/markdownParser';
import { isCoreTheme, isCoreLayout } from './configHelpers.service';
import * as localSiteFs from './localFileSystem.service';

const SIGNUM_FOLDER = '_signum';

/**
 * Exports a complete backup of a Signum site's source data into a ZIP archive.
 * This function's logic is sound and does not require changes.
 */
export async function exportSiteBackup(siteData: LocalSiteData): Promise<Blob> {
  const zip = new JSZip();
  const signumFolder = zip.folder(SIGNUM_FOLDER);

  if (!signumFolder) {
    throw new Error("Failed to create root backup folder in ZIP archive.");
  }

  signumFolder.file('manifest.json', JSON.stringify(siteData.manifest, null, 2));
  signumFolder.file('secrets.json', JSON.stringify(siteData.secrets || {}, null, 2));

  const contentFolder = signumFolder.folder('content');
  siteData.contentFiles?.forEach(file => {
    contentFolder?.file(
      file.path.replace('content/', ''),
      stringifyToMarkdown(file.frontmatter, file.content)
    );
  });
  
  const imagesFolder = signumFolder.folder('assets/images');
  const imageAssets = await localSiteFs.getAllImageAssetsForSite(siteData.siteId);
  for (const [path, blob] of Object.entries(imageAssets)) {
      const filename = path.split('/').pop();
      if (filename) imagesFolder?.file(filename, blob);
  }

  if (siteData.themeFiles?.length) {
    const themeName = siteData.manifest.theme.name;
    if (!isCoreTheme(themeName)) {
      const themeFolder = signumFolder.folder(`themes/${themeName}`);
      siteData.themeFiles.forEach(file => {
        const relativePath = file.path.substring(`themes/${themeName}/`.length);
        themeFolder?.file(relativePath, file.content);
      });
    }
  }
  
  if (siteData.layoutFiles?.length) {
    const layoutsFolder = signumFolder.folder('layouts');
    const seenLayouts = new Set<string>();
    siteData.contentFiles?.forEach(cf => {
      const layoutId = cf.frontmatter.layout;
      if (layoutId && !isCoreLayout(layoutId) && !seenLayouts.has(layoutId)) {
        const layoutFolder = layoutsFolder?.folder(layoutId);
        const layoutFiles = siteData.layoutFiles?.filter(lf => lf.path.startsWith(`layouts/${layoutId}/`));
        layoutFiles?.forEach(file => {
          const relativePath = file.path.substring(`layouts/${layoutId}/`.length);
          layoutFolder?.file(relativePath, file.content);
        });
        seenLayouts.add(layoutId);
      }
    });
  }

  return zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 9 } });
}

/**
 * Parses a ZIP backup file and reconstructs the site data in memory.
 * This function now uses the correct asynchronous pattern for reading files from the archive.
 */
export async function importSiteFromZip(zipFile: File): Promise<LocalSiteData & { imageAssetsToSave?: { [path: string]: Blob } }> {
    const zip = await JSZip.loadAsync(zipFile);
    const signumFolder = zip.folder(SIGNUM_FOLDER);

    if (!signumFolder) throw new Error("Invalid backup file: _signum folder not found.");
    
    const manifestFile = signumFolder.file('manifest.json');
    if (!manifestFile) throw new Error("Invalid backup file: manifest.json is missing.");
    const manifest: Manifest = JSON.parse(await manifestFile.async('string'));

    const secretsFile = signumFolder.file('secrets.json');
    const secrets: SiteSecrets = secretsFile ? JSON.parse(await secretsFile.async('string')) : {};

    const contentFiles: ParsedMarkdownFile[] = [];
    const contentFolder = signumFolder.folder('content');
    if (contentFolder) {
        for (const relativePath in contentFolder.files) {
            const file = contentFolder.files[relativePath];
            if (!file.dir && typeof file.name === 'string') {
                const fullPath = file.name.replace(`${SIGNUM_FOLDER}/`, '');
                const rawContent = await file.async('string');
                const { frontmatter, content } = parseMarkdownString(rawContent);
                const slug = fullPath.substring(fullPath.lastIndexOf('/') + 1).replace('.md', '');
                contentFiles.push({ path: fullPath, slug, frontmatter, content });
            }
        }
    }

    // --- FIX: Use Promise.all with JSZip's forEach callback for async operations ---
    const themePromises: Promise<RawFile>[] = [];
    signumFolder.folder('themes')?.forEach((relativePath, fileObject) => {
        if (!fileObject.dir) {
            const promise = fileObject.async('string').then(content => ({
                path: fileObject.name.replace(`${SIGNUM_FOLDER}/`, ''),
                content: content,
            }));
            themePromises.push(promise);
        }
    });
    const themeFiles = await Promise.all(themePromises);

    const layoutPromises: Promise<RawFile>[] = [];
    signumFolder.folder('layouts')?.forEach((relativePath, fileObject) => {
        if (!fileObject.dir) {
            const promise = fileObject.async('string').then(content => ({
                path: fileObject.name.replace(`${SIGNUM_FOLDER}/`, ''),
                content: content,
            }));
            layoutPromises.push(promise);
        }
    });
    const layoutFiles = await Promise.all(layoutPromises);

    const imageAssets: { [path: string]: Blob } = {};
    const imagesFolder = signumFolder.folder('assets/images');
    if (imagesFolder) {
        for (const filename in imagesFolder.files) {
            const file = imagesFolder.files[filename];
            if (!file.dir) {
                const path = `assets/images/${file.name.split('/').pop()}`;
                imageAssets[path] = await file.async('blob');
            }
        }
    }

    return {
        siteId: manifest.siteId,
        manifest,
        secrets,
        contentFiles,
        themeFiles,
        layoutFiles,
        imageAssetsToSave: imageAssets,
    };
}

================================================================================

File: core/services/relativePaths.service.ts
// src/lib/pathUtils.ts

/**
 * Calculates the relative path from one file to another.
 * This is essential for creating portable HTML that works on any server
 * or directly from the local file system.
 *
 * @example
 * // from 'index.html' to 'about.html' -> './about.html'
 * getRelativePath('index.html', 'about.html');
 *
 * @example
 * // from 'posts/post1.html' to 'index.html' -> '../index.html'
 * getRelativePath('posts/post1.html', 'index.html');
 *
 * @example
 * // from 'posts/post1.html' to 'tags/tech.html' -> '../tags/tech.html'
 * getRelativePath('posts/post1.html', 'tags/tech.html');
 *
 * @param {string} fromPath - The path of the file containing the link.
 * @param {string} toPath - The path of the file being linked to.
 * @returns {string} The calculated relative path.
 */
export function getRelativePath(fromPath: string, toPath: string): string {
  if (fromPath === toPath) {
    return toPath.split('/').pop() || '';
  }

  const fromParts = fromPath.split('/').slice(0, -1); // Path without filename
  const toParts = toPath.split('/');

  // Find the common path segment
  let commonLength = 0;
  while (
    commonLength < fromParts.length &&
    commonLength < toParts.length &&
    fromParts[commonLength] === toParts[commonLength]
  ) {
    commonLength++;
  }

  const upLevels = fromParts.length - commonLength;
  const upPath = '../'.repeat(upLevels) || './';

  const downPath = toParts.slice(commonLength).join('/');

  return upPath + downPath;
}

================================================================================

File: core/services/localFileSystem.service.ts
// src/lib/localSiteFs.ts
import { LocalSiteData, Manifest, ParsedMarkdownFile, RawFile } from '@/types'; // Ensure RawFile is imported
import localforage from 'localforage';
import { stringifyToMarkdown, parseMarkdownString } from '@/lib/markdownParser';

const DB_NAME = 'SignumDB';

const siteManifestsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteManifests',
});

const siteContentFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteContentFiles',
});

const siteLayoutFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteLayoutFiles',
});

const siteThemeFilesStore = localforage.createInstance({
    name: DB_NAME,
    storeName: 'siteThemeFiles',
});

const siteImageAssetsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteImageAssets',
});

// --- Function to load only manifests for a fast initial load ---
export async function loadAllSiteManifests(): Promise<Manifest[]> {
  const manifests: Manifest[] = [];
  await siteManifestsStore.iterate((value: Manifest) => {
    manifests.push(value);
  });
  return manifests;
}

/**
 * Fetches the manifest for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<Manifest | null>} A Promise that resolves to the Manifest object, or null if not found.
 */
export async function getManifestById(siteId: string): Promise<Manifest | null> {
  const manifest = await siteManifestsStore.getItem<Manifest>(siteId);
  return manifest ?? null;
}

/**
 * Fetches the content files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<ParsedMarkdownFile[]>} A Promise that resolves to an array of parsed markdown files.
 */
export async function getSiteContentFiles(siteId: string): Promise<ParsedMarkdownFile[]> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId);
    return contentFiles ?? [];
}

/**
 * Fetches the custom layout files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw layout files.
 */
export async function getSiteLayoutFiles(siteId: string): Promise<RawFile[]> {
    const layoutFiles = await siteLayoutFilesStore.getItem<RawFile[]>(siteId);
    return layoutFiles ?? [];
}

/**
 * Fetches the custom theme files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw theme files.
 */
export async function getSiteThemeFiles(siteId: string): Promise<RawFile[]> {
    const themeFiles = await siteThemeFilesStore.getItem<RawFile[]>(siteId);
    return themeFiles ?? [];
}

export async function saveSite(siteData: LocalSiteData): Promise<void> {
  await Promise.all([
    siteManifestsStore.setItem(siteData.siteId, siteData.manifest),
    siteContentFilesStore.setItem(siteData.siteId, siteData.contentFiles ?? []),
    siteLayoutFilesStore.setItem(siteData.siteId, siteData.layoutFiles ?? []),
    siteThemeFilesStore.setItem(siteData.siteId, siteData.themeFiles ?? []),
  ]);
}

export async function deleteSite(siteId: string): Promise<void> {
  await Promise.all([
    siteManifestsStore.removeItem(siteId),
    siteContentFilesStore.removeItem(siteId),
    siteLayoutFilesStore.removeItem(siteId),
    siteThemeFilesStore.removeItem(siteId),
  ]);
}

export async function saveManifest(siteId: string, manifest: Manifest): Promise<void> {
    await siteManifestsStore.setItem(siteId, manifest);
}

export async function saveContentFile(siteId: string, filePath: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];

    const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
    const fileSlug = filePath.replace(/^content\//, '').replace(/\.md$/, '');
    const savedFile: ParsedMarkdownFile = { slug: fileSlug, path: filePath, frontmatter, content };

    const fileIndex = contentFiles.findIndex(f => f.path === filePath);
    if (fileIndex > -1) {
      contentFiles[fileIndex] = savedFile;
    } else {
      contentFiles.push(savedFile);
    }

    await siteContentFilesStore.setItem(siteId, contentFiles);
    return savedFile;
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const updatedContentFiles = contentFiles.filter(f => f.path !== filePath);
    await siteContentFilesStore.setItem(siteId, updatedContentFiles);
}

export async function getContentFileRaw(siteId: string, filePath: string): Promise<string | null> {
    const allFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const fileData = allFiles.find(f => f.path === filePath);
    if (!fileData) return null;
    
    return stringifyToMarkdown(fileData.frontmatter, fileData.content);
}

/**
 * Moves a set of content files from old paths to new paths in a single transaction.
 * @param {string} siteId - The ID of the site.
 * @param {{oldPath: string, newPath: string}[]} pathsToMove - An array of path mapping objects.
 * @returns {Promise<void>}
 */
export async function moveContentFiles(siteId: string, pathsToMove: { oldPath: string, newPath: string }[]): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    
    const updatedFiles = contentFiles.map(file => {
        const moveInstruction = pathsToMove.find(p => p.oldPath === file.path);
        if (moveInstruction) {
            const newSlug = moveInstruction.newPath.split('/').pop()?.replace('.md', '') || '';
            return { ...file, path: moveInstruction.newPath, slug: newSlug };
        }
        return file;
    });
    
    await siteContentFilesStore.setItem(siteId, updatedFiles);
}

/**
 * Saves a binary image asset (as a Blob) to storage for a specific site.
 * @param siteId The ID of the site.
 * @param imagePath The relative path to the image (e.g., 'assets/images/foo.jpg').
 * @param imageData The image data as a Blob.
 */
export async function saveImageAsset(siteId: string, imagePath: string, imageData: Blob): Promise<void> {
  const imageMap = await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId) || {};
  imageMap[imagePath] = imageData;
  await siteImageAssetsStore.setItem(siteId, imageMap);
}

/**
 * Retrieves a binary image asset (as a Blob) from storage for a specific site.
 * @param siteId The ID of the site to look within.
 * @param imagePath The relative path of the image to retrieve.
 * @returns A Promise that resolves to the image Blob, or null if not found.
 */
export async function getImageAsset(siteId: string, imagePath: string): Promise<Blob | null> {
  // <-- FIX: This is now much more efficient and correct.
  // 1. Get the image map for the specific site.
  const imageMap = await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId);
  if (!imageMap) {
    return null; // The site has no images.
  }
  // 2. Return the image from the map, or null if it doesn't exist.
  return imageMap[imagePath] || null;
}

/**
 * Retrieves the entire map of image paths to image Blobs for a given site.
 * @param siteId The ID of the site.
 * @returns A promise that resolves to a record mapping image paths to their Blob data.
 */
export async function getAllImageAssetsForSite(siteId: string): Promise<Record<string, Blob>> {
    return await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId) || {};
}

/**
 * Saves a complete map of image assets for a site.
 * This is used during the site import process to restore all images at once.
 * @param siteId The ID of the site to save images for.
 * @param assets A record mapping image paths to their Blob data.
 */
export async function saveAllImageAssetsForSite(siteId: string, assets: Record<string, Blob>): Promise<void> {
  await siteImageAssetsStore.setItem(siteId, assets);
}

================================================================================

File: core/services/navigationStructure.service.ts
// src/core/services/navigationStructure.service.ts
import { LocalSiteData, NavLinkItem, StructureNode } from '@/types';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { getRelativePath } from '@/core/services/relativePaths.service';
import { RenderOptions } from '@/core/services/theme-engine/themeEngine.service';

/**
 * Recursively builds a navigation link structure with context-aware paths.
 * @param siteData - The full site data, needed for URL generation.
 * @param nodes - The site structure nodes to build links from.
 * @param currentPagePath - The path of the page being currently rendered.
 * @param options - The render options, containing isExport and siteRootPath.
 * @returns An array of navigation link objects.
 */
function buildNavLinks(
    siteData: LocalSiteData, 
    nodes: StructureNode[], 
    currentPagePath: string, 
    options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  return nodes
    .filter(node => node.type === 'page' && node.navOrder !== undefined)
    .sort((a, b) => (a.navOrder || 0) - (b.navOrder || 0))
    .map(node => {
      let href: string;
      // --- FIX: Pass siteData.manifest instead of the whole siteData object ---
      const urlSegment = getUrlForNode(node, siteData.manifest, options.isExport);

      if (options.isExport) {
        href = getRelativePath(currentPagePath, urlSegment);
      } else {
        const path = `/${urlSegment}`.replace(/\/$/, '') || '/';
        href = `${options.siteRootPath}${path === '/' ? '' : path}`;
      }

      const children = (node.children && node.children.length > 0)
        ? buildNavLinks(siteData, node.children, currentPagePath, options)
        : [];

      return {
        href: href,
        label: node.menuTitle || node.title,
        children: children,
      };
    });
}

/**
 * Generates the complete navigation structure for a given page.
 */
export function generateNavLinks(
  siteData: LocalSiteData,
  currentPagePath: string,
  options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  const { structure } = siteData.manifest;
  return buildNavLinks(siteData, structure, currentPagePath, options);
}

================================================================================

File: core/services/pageResolver.service.ts
// src/core/services/pageResolver.service.ts

import {
    LocalSiteData,
    ParsedMarkdownFile,
    CollectionConfig,
    PaginationData,
    PageResolutionResult,
    PageType,
    StructureNode,
} from '@/types';
// --- FIX: The import is now valid as findChildNodes exists in the target module ---
import { findNodeByPath, findChildNodes } from './fileTree.service';
import { getUrlForNode } from './urlUtils.service';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

/**
 * Executes a declarative query for a Collection Page.
 * This pure function takes the config and site data, finds all child pages
 * in the structure, fetches their content, and returns a fully sorted array.
 *
 * @param {CollectionConfig} collectionConfig - The configuration object from the page's frontmatter.
 * @param {StructureNode} collectionNode - The structure node for the Collection Page itself.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @returns {ParsedMarkdownFile[]} A sorted array of all content files that are children of the collection page.
 */
function executeCollectionQuery(
    collectionConfig: CollectionConfig,
    collectionNode: StructureNode,
    siteData: LocalSiteData,
): ParsedMarkdownFile[] {
    if (!siteData.contentFiles) {
        return [];
    }

    // Find all direct child nodes of the collection page in the site's structure.
    const childNodes = findChildNodes(siteData.manifest.structure, collectionNode.path);
    const childPaths = new Set(childNodes.map(child => child.path));

    // Filter the site's content files to get only the ones that are children.
    const items = siteData.contentFiles.filter(file => childPaths.has(file.path));

    const sortBy = collectionConfig.sort_by || 'date';
    const sortOrder = collectionConfig.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    return [...items].sort((a, b) => {
        const valA = a.frontmatter[sortBy];
        const valB = b.frontmatter[sortBy];

        if (sortBy === 'date' && valA && valB) {
            const dateA = new Date(valA as string).getTime();
            const dateB = new Date(valB as string).getTime();
            if (isNaN(dateA) || isNaN(dateB)) return 0;
            return (dateA - dateB) * orderModifier;
        }

        if (typeof valA === 'string' && typeof valB === 'string') {
            return valA.localeCompare(valB) * orderModifier;
        }

        if (typeof valA === 'number' && typeof valB === 'number') {
            return (valA - valB) * orderModifier;
        }
        return 0;
    });
}

/**
 * Finds the correct page to render based on a URL slug path.
 * If the page is a Collection Page, this function executes the query, handles pagination,
 * and attaches the results to the final resolution object.
 *
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {string[]} slugArray - The URL segments used for path matching.
 * @param {number} [pageNumber=1] - The current page number for pagination.
 * @returns {PageResolutionResult} An object containing all data needed to render the page or a not-found error.
 */
export function resolvePageContent(
    siteData: LocalSiteData,
    slugArray: string[],
    pageNumber: number = 1,
): PageResolutionResult {
    // Determine the homepage by finding the file with `homepage: true`.
    const homepageFile = siteData.contentFiles?.find(f => f.frontmatter.homepage === true);
    
    // If the slug is empty, we are trying to render the homepage.
    const isHomepageRequest = slugArray.length === 0 || (slugArray.length === 1 && slugArray[0] === '');
    const pathFromSlug = `content/${slugArray.join('/')}.md`;

    // Determine the target path. If it's a homepage request, use the homepage file's path.
    const targetNodePath = isHomepageRequest ? homepageFile?.path : pathFromSlug;
    
    if (!targetNodePath) {
        return {
            type: PageType.NotFound,
            errorMessage: "No homepage has been designated for this site.",
        };
    }

    const targetNode = findNodeByPath(siteData.manifest.structure, targetNodePath);
    if (!targetNode) {
        return {
            type: PageType.NotFound,
            errorMessage: `No page found in site structure for path: ${targetNodePath}`,
        };
    }

    const contentFile = siteData.contentFiles?.find(f => f.path === targetNode.path);
    if (!contentFile) {
        return {
            type: PageType.NotFound,
            errorMessage: `Manifest references "${targetNode.path}" but its content file is missing.`,
        };
    }

    let collectionItems: ParsedMarkdownFile[] | undefined = undefined;
    let pagination: PaginationData | undefined = undefined;

    const collectionConfig = contentFile.frontmatter.collection;
    if (collectionConfig) {
        const allItems = executeCollectionQuery(collectionConfig, targetNode, siteData);
        const itemsPerPage = collectionConfig.items_per_page;

        if (itemsPerPage && itemsPerPage > 0) {
            const totalItems = allItems.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const currentPage = Math.max(1, Math.min(pageNumber, totalPages));
            const startIndex = (currentPage - 1) * itemsPerPage;
            collectionItems = allItems.slice(startIndex, startIndex + itemsPerPage);

            const pageUrlSegment = getUrlForNode(targetNode, siteData.manifest, false);
            const baseUrl = pageUrlSegment ? `/${pageUrlSegment}` : '';
            
            pagination = {
                currentPage,
                totalPages,
                totalItems,
                hasPrevPage: currentPage > 1,
                hasNextPage: currentPage < totalPages,
                prevPageUrl: currentPage > 1 ? (currentPage === 2 ? baseUrl || '/' : `${baseUrl}/page/${currentPage - 1}`) : undefined,
                nextPageUrl: currentPage < totalPages ? `${baseUrl}/page/${currentPage + 1}` : undefined,
            };

        } else {
            collectionItems = allItems;
        }
    }

    return {
        type: PageType.SinglePage,
        pageTitle: contentFile.frontmatter.title,
        contentFile: contentFile,
        layoutPath: contentFile.frontmatter.layout || DEFAULT_PAGE_LAYOUT_PATH,
        collectionItems: collectionItems,
        pagination: pagination,
    };
}

================================================================================

File: core/services/siteSecrets.service.ts
// src/core/services/siteSecrets.service.ts
import localforage from 'localforage';

const DB_NAME = 'SignumDB';

// This store is NEVER included in the site export.
const siteSecretsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteSecrets',
});

// --- FIX: Add the 'export' keyword to make the interface available for import ---
/**
 * Defines the shape of the sensitive, non-public data for a site.
 * This data is stored separately and is not included in public site exports.
 */
export interface SiteSecrets {
  cloudinary?: {
    uploadPreset?: string;
  };
}

/**
 * Loads the secrets object for a specific site from the database.
 * @param siteId The ID of the site.
 * @returns A promise that resolves to the SiteSecrets object, or an empty object.
 */
export async function loadSiteSecretsFromDb(siteId: string): Promise<SiteSecrets> {
  return (await siteSecretsStore.getItem<SiteSecrets>(siteId)) || {};
}

/**
 * Saves the complete secrets object for a specific site to the database.
 * @param siteId The ID of the site.
 * @param secrets The SiteSecrets object to save.
 */
export async function saveSiteSecretsToDb(siteId: string, secrets: SiteSecrets): Promise<void> {
  await siteSecretsStore.setItem(siteId, secrets);
}

================================================================================

File: core/services/fileTree.service.ts
// src/core/services/fileTree.service.ts
import type { ParsedMarkdownFile, StructureNode } from '@/types';

/**
 * A flattened representation of a StructureNode, including its depth and parent.
 * It also includes the frontmatter for easier access in UI components.
 */
export interface FlattenedNode extends StructureNode {
  parentId: string | null;
  depth: number;
  index: number;
  collapsed?: boolean;
  frontmatter?: ParsedMarkdownFile['frontmatter'];
}

/**
 * Recursively traverses a tree of StructureNodes and flattens it into an array.
 * It now also merges frontmatter data into each node.
 */
function flatten(
  nodes: StructureNode[],
  contentFiles: ParsedMarkdownFile[],
  parentId: string | null = null,
  depth = 0
): FlattenedNode[] {
  return nodes.reduce<FlattenedNode[]>((acc, item, index) => {
    const file = contentFiles.find(f => f.path === item.path);
    return [
      ...acc,
      { ...item, parentId, depth, index, frontmatter: file?.frontmatter },
      ...(item.children ? flatten(item.children, contentFiles, item.path, depth + 1) : []),
    ];
  }, []);
}

/**
 * Public facing function to flatten the entire site structure tree.
 */
export function flattenTree(nodes: StructureNode[], contentFiles: ParsedMarkdownFile[]): FlattenedNode[] {
  return flatten(nodes, contentFiles);
}

/**
 * Reconstructs a nested tree structure from a flat array of nodes.
 */
export function buildTree(flattenedNodes: FlattenedNode[]): StructureNode[] {
  const root: StructureNode & { children: StructureNode[] } = {
    path: 'root', slug: 'root', title: 'root', type: 'page', children: []
  };
  const nodes: Record<string, StructureNode> = { [root.path]: root };

  const items = flattenedNodes.map(item => ({ ...item, children: [] as StructureNode[] }));

  for (const item of items) {
    const { path } = item;
    const parentId = item.parentId ?? root.path;
    
    nodes[path] = item;
    const parent = nodes[parentId];

    if (parent) {
      parent.children = parent.children ?? [];
      parent.children.push(item);
    }
  }
  
  return root.children ?? [];
}

// --- NEW FUNCTION: A simple utility to get a flat list of all nodes ---
/**
 * Recursively traverses a tree of StructureNodes and returns a simple flat array.
 * This is used when only the node data is needed, without depth or parent context.
 * @param {StructureNode[]} nodes - The tree of nodes to flatten.
 * @returns {StructureNode[]} A flat array of all nodes in the tree.
 */
export function flattenStructure(nodes: StructureNode[]): StructureNode[] {
  let allNodes: StructureNode[] = [];
  for (const node of nodes) {
    allNodes.push(node);
    if (node.children) {
      allNodes = allNodes.concat(flattenStructure(node.children));
    }
  }
  return allNodes;
}

/**
 * Finds a node in a structure tree by its exact `path`.
 */
export function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) return node;
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) return found;
    }
  }
  return undefined;
}

// --- FIX: Re-added the exported findChildNodes function ---
/**
 * Finds all direct child nodes of a given parent node path.
 * This is a simple utility used by the page resolver for collection pages.
 * @param {StructureNode[]} nodes - The entire site structure tree.
 * @param {string} parentPath - The path of the parent node whose children are needed.
 * @returns {StructureNode[]} An array of child nodes, or an empty array if not found.
 */
export function findChildNodes(nodes: StructureNode[], parentPath: string): StructureNode[] {
    const parentNode = findNodeByPath(nodes, parentPath);
    return parentNode?.children || [];
}


/**
 * Finds and removes a node from a tree structure immutably.
 */
export function findAndRemoveNode(nodes: StructureNode[], path: string): { found: StructureNode | null, tree: StructureNode[] } {
    let found: StructureNode | null = null;
    const filterRecursively = (currentNodes: StructureNode[]): StructureNode[] => {
      return currentNodes.reduce<StructureNode[]>((acc, node) => {
        if (node.path === path) {
          found = node;
          return acc;
        }
        const newNode = { ...node };
        if (newNode.children) {
          newNode.children = filterRecursively(newNode.children);
        }
        acc.push(newNode);
        return acc;
      }, []);
    };
    const newTree = filterRecursively(nodes);
    return { found, tree: newTree };
  }
  
/**
 * Recursively updates the path of a node and all of its descendants.
 */
export function updatePathsRecursively(node: StructureNode, newParentDir: string): StructureNode {
    const fileName = node.path.substring(node.path.lastIndexOf('/') + 1);
    const newPath = `${newParentDir}/${fileName}`.replace('//', '/');
    const newSlug = newPath.replace(/^content\//, '').replace(/\.md$/, '');
    const updatedNode: StructureNode = { ...node, path: newPath, slug: newSlug };
    if (updatedNode.children) {
      const newChildsParentPath = newPath.replace(/\.md$/, '');
      updatedNode.children = updatedNode.children.map(child =>
        updatePathsRecursively(child, newChildsParentPath)
      );
    }
    return updatedNode;
}
  
/**
 * Recursively calculates the depth of a specific node within the tree.
 */
export function getNodeDepth(nodes: StructureNode[], path: string, currentDepth = 0): number {
    for (const node of nodes) {
        if (node.path === path) {
            return currentDepth;
        }
        if (node.children) {
            const depth = getNodeDepth(node.children, path, currentDepth + 1);
            if (depth !== -1) {
                return depth;
            }
        }
    }
    return -1;
}
  
/**
 * Recursively traverses a node tree and returns a flat array of all node paths (IDs).
 */
export function getDescendantIds(nodes: StructureNode[]): string[] {
    return nodes.flatMap(node => [
      node.path,
      ...(node.children ? getDescendantIds(node.children) : []),
    ]);
}

================================================================================

File: core/services/images/images.service.ts
// src/core/services/images/images.service.ts

// <-- FIX: Import all necessary types from the central types file.
import { ImageService, Manifest } from '@/types';

import { localImageService } from './localImage.service';
import { cloudinaryImageService } from './cloudinaryImage.service';

const services: Record<string, ImageService> = {
  local: localImageService,
  cloudinary: cloudinaryImageService,
};

export function getActiveImageService(manifest: Manifest): ImageService {
  // This now correctly type-checks against the updated Manifest interface.
  const serviceId = manifest.settings?.imageService || 'local';
  return services[serviceId] || localImageService;
}

================================================================================

File: core/services/images/types.ts
// src/core/services/theme-engine/helpers/types.ts
import { LocalSiteData } from '@/types';
import Handlebars from 'handlebars';

/**
 * Defines the function signature for a Handlebars helper function within Signum.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
export type SignumHelperFunction = (
  // FIX: Using 'unknown' is a safer alternative to 'any' for the 'this' context.
  this: unknown,
  // FIX: Using 'unknown[]' ensures arguments are type-checked if used.
  ...args: unknown[]
) => string | Handlebars.SafeString | boolean | Promise<Handlebars.SafeString>;

/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 */
export type SignumHelper = (siteData: LocalSiteData) => Record<string, SignumHelperFunction>;

================================================================================

File: core/services/images/localImage.service.ts
// src/core/services/images/localImage.service.ts

import { ImageService, ImageRef, ImageTransformOptions, Manifest } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { slugify } from '@/lib/utils';
import { getCachedDerivative, setCachedDerivative, getAllCacheKeys } from './derivativeCache.service';
import imageCompression from 'browser-image-compression';

/**
 * This service manages images stored locally within the browser's IndexedDB.
 * It handles uploading, generating transformed "derivatives" (e.g., thumbnails),
 * caching those derivatives for performance, and bundling all necessary assets for a static site export.
 */

// In-memory caches to reduce redundant processing and DB reads within a session.
const sourceImageCache = new Map<string, Blob>();
const processingPromises = new Map<string, Promise<Blob>>();

/**
 * A strongly-typed interface for the options passed to the browser-image-compression library.
 * This improves type safety and code clarity.
 */
interface CompressionOptions {
  maxSizeMB: number;
  initialQuality: number;
  useWebWorker: boolean;
  exifOrientation: number;
  maxWidthOrHeight?: number;
  maxWidth?: number;
  maxHeight?: number;
}

/**
 * A utility function to get the dimensions of an image from its Blob data.
 * @param blob The image Blob.
 * @returns A promise that resolves to the image's width and height.
 */
const getImageDimensions = (blob: Blob): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
      URL.revokeObjectURL(url);
    };
    img.onerror = (err) => {
      reject(err);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });
};

/**
 * Implements the ImageService interface for handling images stored locally
 * within the site's data in the browser (IndexedDB).
 */
class LocalImageService implements ImageService {
  id = 'local';
  name = 'Store in Site Bundle';

  public async upload(file: File, siteId: string): Promise<ImageRef> {
    const extIndex = file.name.lastIndexOf('.');
    if (extIndex === -1) {
      throw new Error("Uploaded file is missing an extension.");
    }
    const baseName = file.name.substring(0, extIndex);
    const extension = file.name.substring(extIndex);
    const slugifiedBaseName = slugify(baseName);
    const fileName = `${Date.now()}-${slugifiedBaseName}${extension}`;
    const relativePath = `assets/images/${fileName}`;

    await localSiteFs.saveImageAsset(siteId, relativePath, file as Blob);

    // For SVGs, width/height can be 0, which is acceptable.
    const { width, height } = await getImageDimensions(file as Blob);

    return {
      serviceId: 'local',
      src: relativePath,
      alt: file.name,
      width,
      height,
    };
  }

  public async getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions, isExport: boolean): Promise<string> {

    // Check if the image is an SVG. If so, bypass all derivative processing.
    const isSvg = ref.src.toLowerCase().endsWith('.svg');
    if (isSvg) {
      if (isExport) {
        // For static exports, simply return the original, relative path.
        return ref.src;
      }
      // For live preview display, get the original SVG blob and create a temporary object URL.
      const sourceBlob = await this.getSourceBlob(manifest.siteId, ref.src);
      return URL.createObjectURL(sourceBlob);
    }
    // --- END SVG FIX ---

    const { width, height, crop = 'scale', gravity = 'center' } = options;
    const extIndex = ref.src.lastIndexOf('.');
    if (extIndex === -1) throw new Error("Source image has no extension.");
    
    const pathWithoutExt = ref.src.substring(0, extIndex);
    const ext = ref.src.substring(extIndex);

    // This is the public-facing filename for the generated derivative.
    const derivativeFileName = `${pathWithoutExt}_w${width || 'auto'}_h${height || 'auto'}_c-${crop}_g-${gravity}${ext}`;

    // --- FIX #1: SCOPED CACHE KEY ---
    // The key used for the IndexedDB cache is now namespaced with the siteId.
    const cacheKey = `${manifest.siteId}/${derivativeFileName}`;

    const finalBlob = await this.getOrProcessDerivative(manifest.siteId, ref.src, cacheKey, options);
    
    // For export, return the relative filename. For display, create a temporary URL.
    return isExport ? derivativeFileName : URL.createObjectURL(finalBlob);
  }

  /**
   * Core processing pipeline. It checks caches and processes the image
   * only if necessary, preventing race conditions and improving quality.
   */
  private async getOrProcessDerivative(siteId: string, srcPath: string, cacheKey: string, options: ImageTransformOptions): Promise<Blob> {
    const cachedBlob = await getCachedDerivative(cacheKey);
    if (cachedBlob) return cachedBlob;

    if (processingPromises.has(cacheKey)) return processingPromises.get(cacheKey)!;
    
    const processingPromise = (async (): Promise<Blob> => {
      try {
        const sourceBlob = await this.getSourceBlob(siteId, srcPath);
        
        // Get original dimensions to prevent upscaling.
        const sourceDimensions = await getImageDimensions(sourceBlob);

        const compressionOptions: CompressionOptions = {
            maxSizeMB: 1.5,
            initialQuality: 0.85, // Increased from 0.8 for better quality.
            useWebWorker: true,
            exifOrientation: -1,
        };

        const { width, height, crop } = options;

        // Cap requested dimensions at the source's dimensions to prevent upscaling and pixelation.
        const targetWidth = width ? Math.min(width, sourceDimensions.width) : undefined;
        const targetHeight = height ? Math.min(height, sourceDimensions.height) : undefined;

        if (crop === 'fill' && targetWidth && targetHeight) {
          compressionOptions.maxWidth = targetWidth;
          compressionOptions.maxHeight = targetHeight;
        } else {
          const maxDim = Math.max(targetWidth || 0, targetHeight || 0);
          // Only set maxWidthOrHeight if a dimension was actually requested.
          if (maxDim > 0) {
            compressionOptions.maxWidthOrHeight = maxDim;
          }
        }
        // --- END IMAGE QUALITY FIX ---

        console.log(`[ImageService] Processing new derivative: ${cacheKey}`);
        const derivativeBlob = await imageCompression(sourceBlob as File, compressionOptions);
        
        await setCachedDerivative(cacheKey, derivativeBlob);
        
        return derivativeBlob;
      } finally {
        processingPromises.delete(cacheKey);
      }
    })();

    processingPromises.set(cacheKey, processingPromise);
    return processingPromise;
  }

  private async getSourceBlob(siteId: string, srcPath: string): Promise<Blob> {
    let sourceBlob = sourceImageCache.get(srcPath);
    if (!sourceBlob) {
        const blobData = await localSiteFs.getImageAsset(siteId, srcPath);
        if (!blobData) throw new Error(`Source image not found in local storage: ${srcPath}`);
        sourceBlob = blobData;
        sourceImageCache.set(srcPath, sourceBlob);
    }
    return sourceBlob;
  }

  public async getExportableAssets(siteId: string, allImageRefs: ImageRef[]): Promise<{ path: string; data: Blob; }[]> {
    const exportableMap = new Map<string, Blob>();
    
    // 1. Add all original source images for this site to the export map.
    for (const ref of allImageRefs) {
      if (ref.serviceId === 'local' && !exportableMap.has(ref.src)) {
        const sourceBlob = await localSiteFs.getImageAsset(siteId, ref.src);
        if (sourceBlob) {
          exportableMap.set(ref.src, sourceBlob);
        }
      }
    }
    
    // 2. Get derivative keys ONLY for the current siteId.
    const derivativeKeys = await getAllCacheKeys(siteId);

    // 3. Add all of this site's derivatives to the export map.
    for (const key of derivativeKeys) {
      // The key is in the format "siteId/path/to/image.jpg"
      // The filename for the ZIP archive should only be "path/to/image.jpg"
      const filename = key.substring(siteId.length + 1);

      if (!exportableMap.has(filename)) {
        const derivativeBlob = await getCachedDerivative(key);
        if (derivativeBlob) {
          exportableMap.set(filename, derivativeBlob);
        }
      }
    }
    // --- END SCOPED EXPORT FIX ---
    
    return Array.from(exportableMap.entries()).map(([path, data]) => ({ path, data }));
  }
}

export const localImageService = new LocalImageService();

================================================================================

File: core/services/images/derivativeCache.service.ts
// src/core/services/images/derivativeCache.service.ts
import localforage from 'localforage';

/**
 * Manages the storage and retrieval of generated image "derivatives" (e.g., thumbnails, resized images).
 * This service acts as a persistent cache in the browser's IndexedDB to avoid re-processing
 * images unnecessarily between sessions, which significantly improves performance.
 *
 */

// A single, global IndexedDB store is used for all derivatives.
// Scoping is handled by prefixing keys with the site's ID.
const derivativeCacheStore = localforage.createInstance({
  name: 'SignumDB',
  storeName: 'derivativeCacheStore',
});

/**
 * Retrieves a cached image derivative from IndexedDB by its full, namespaced key.
 * @param key The unique key for the derivative, including the `siteId` prefix (e.g., "site-abc/assets/images/foo_w100.jpg").
 * @returns A promise that resolves to the derivative Blob, or null if not found.
 */
export async function getCachedDerivative(key: string): Promise<Blob | null> {
  return derivativeCacheStore.getItem<Blob>(key);
}

/**
 * Stores an image derivative Blob in IndexedDB using its full, namespaced key.
 * @param key The unique key for the derivative, including the `siteId` prefix.
 * @param blob The derivative image data as a Blob to be cached.
 */
export async function setCachedDerivative(key: string, blob: Blob): Promise<void> {
  await derivativeCacheStore.setItem(key, blob);
}

/**
 * Retrieves all cache keys that belong to a specific site.
 * This is crucial for the site exporter to find and bundle all generated images for a single site.
 * @param siteId The ID of the site whose cache keys are needed.
 * @returns A promise that resolves to an array of all keys (strings) for the specified site.
 */
export async function getAllCacheKeys(siteId: string): Promise<string[]> {
  // 1. Get all keys from the store.
  const allKeys = await derivativeCacheStore.keys();
  
  // 2. Filter the keys to return only those that start with the required "siteId/" prefix.
  const sitePrefix = `${siteId}/`;
  return allKeys.filter(key => key.startsWith(sitePrefix));
}

================================================================================

File: core/services/images/imageCache.service.ts
// src/core/services/images/derivativeCache.service.ts
import localforage from 'localforage';

const derivativeCacheStore = localforage.createInstance({
  name: 'SignumDB',
  storeName: 'derivativeCacheStore',
});

/**
 * Retrieves a cached image derivative from IndexedDB by its key.
 * @param key The unique key for the derivative.
 * @returns A promise that resolves to the derivative Blob, or null if not found.
 */
export async function getCachedDerivative(key: string): Promise<Blob | null> {
  return derivativeCacheStore.getItem<Blob>(key);
}

/**
 * Stores an image derivative Blob in IndexedDB.
 * @param key The unique key for the derivative.
 * @param blob The derivative image data as a Blob.
 */
export async function setCachedDerivative(key: string, blob: Blob): Promise<void> {
  await derivativeCacheStore.setItem(key, blob);
}

/**
 * Retrieves all keys currently stored in the derivative cache.
 * @returns A promise that resolves to an array of all keys (strings).
 */
export async function getAllCacheKeys(): Promise<string[]> {
  return derivativeCacheStore.keys();
}

================================================================================

File: core/services/images/cloudinaryImage.service.ts
// src/core/services/images/cloudinaryImage.service.ts
import { ImageService, ImageRef, ImageTransformOptions, Manifest } from '@/types';
import { useAppStore } from '@/core/state/useAppStore';
import { Cloudinary } from "@cloudinary/url-gen";
import { fill, fit, scale } from "@cloudinary/url-gen/actions/resize";
import { Gravity } from "@cloudinary/url-gen/qualifiers/gravity";
import { format, quality } from "@cloudinary/url-gen/actions/delivery";

// --- FIX: Added types for Cloudinary upload widget for type safety ---
interface UploadWidgetResultInfo {
  public_id: string;
  version: number;
  format: string;
  width: number;
  height: number;
  original_filename?: string;
}

interface UploadWidgetResult {
  event: 'success';
  info: UploadWidgetResultInfo;
}

interface UploadWidgetError {
  message: string;
}

declare const cloudinary: {
  createUploadWidget: (
    options: object,
    callback: (error: UploadWidgetError | null, result: UploadWidgetResult | null) => void
  ) => { open: () => void; close: () => void; };
};

class CloudinaryImageService implements ImageService {
  id = 'cloudinary';
  name = 'Upload to Cloudinary';

  async upload(file: File, siteId: string): Promise<ImageRef> {
    const site = useAppStore.getState().getSiteById(siteId);
    if (!site) throw new Error(`Site with ID "${siteId}" not found in state.`);

    const cloudName = site.manifest?.settings?.cloudinary?.cloudName;
    const uploadPreset = site.secrets?.cloudinary?.uploadPreset;

    if (!cloudName || !uploadPreset) throw new Error("Cloudinary Cloud Name and Upload Preset must be configured.");

    return new Promise((resolve, reject) => {
      const widget = cloudinary.createUploadWidget(
        { cloudName, uploadPreset, sources: ['local', 'url', 'camera'], multiple: false },
        (error, result) => {
          if (error) {
            console.error('Cloudinary Upload Error:', error);
            widget.close();
            return reject(new Error(error.message || 'Image upload failed. Please try again.'));
          }

          if (result && result.event === 'success') {
            // FIX: Removed unused `version` and `format` variables.
            const { public_id, width, height } = result.info;
            const srcPath = public_id;
            
            widget.close();
            resolve({
              serviceId: 'cloudinary', src: srcPath,
              alt: result.info.original_filename || 'Uploaded image', width, height,
            });
          }
        }
      );
      widget.open();
    });
  }

  // FIX: Removed unused `isExport` parameter.
  async getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions): Promise<string> {
    const cloudName = manifest.settings?.cloudinary?.cloudName;
    if (!cloudName) return ''; // Return empty string or a placeholder if not configured
    
    const cld = new Cloudinary({ cloud: { cloudName: cloudName } });
    const cldImage = cld.image(ref.src);

    const { width, height, crop = 'scale', gravity } = options;

    switch (crop) {
        case 'fill':
            const fillResize = fill(width, height);
            if (gravity === 'auto') fillResize.gravity(Gravity.autoGravity());
            else if (gravity && ['north', 'south', 'east', 'west'].includes(gravity)) fillResize.gravity(Gravity.compass(gravity));
            else if (gravity === 'center') fillResize.gravity(Gravity.xyCenter());
            cldImage.resize(fillResize);
            break;
        case 'fit': cldImage.resize(fit(width, height)); break;
        case 'scale': default: cldImage.resize(scale(width, height)); break;
    }

    cldImage.delivery(format('auto')).delivery(quality('auto'));
    return cldImage.toURL();
  }

  // FIX: Removed unused `siteId` and `allImageRefs` parameters.
  async getExportableAssets(): Promise<{ path: string; data: Blob; }[]> {
    // Cloudinary assets are remote, so there are no local files to export.
    return Promise.resolve([]);
  }
}

export const cloudinaryImageService = new CloudinaryImageService();

================================================================================

File: core/services/theme-engine/themeEngine.service.ts
// src/core/services/theme-engine/themeEngine.service.ts

import Handlebars from 'handlebars';
import {
    LocalSiteData,
    PageResolutionResult,
    PageType,
    ThemeConfig,
} from '@/types';
import {
    getJsonAsset,
    getAvailableLayouts,
    ThemeManifest,
    AssetFile,
    getAssetContent,
} from '@/core/services/configHelpers.service';
import { coreHelpers } from './helpers';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { generateNavLinks } from '@/core/services/navigationStructure.service';
import { getActiveImageService } from '@/core/services/images/images.service';
import { getMergedThemeDataForForm } from '@/core/services/theme.service';

/**
 * The core rendering engine for Signum. It orchestrates the entire
 * process of converting raw site data into a final, viewable HTML page.
 * It is designed to be resilient and always work with the most current data.
 *
 * --- Core Rendering Pipeline ---
 *
 * 1.  **"Sync on Load":** Before any rendering occurs, it calls `syncAndHydrateTheme`.
 *     This non-destructively merges the user's saved settings with the very latest
 *     version of the theme's schema and defaults. This ensures that if a theme author
 *     adds a new setting, it becomes available immediately without data loss.
 *
 * 2.  **Helper & Template Caching:** It registers all necessary Handlebars helpers
 *     (e.g., `{{formatDate}}`, `{{{image}}}`) and pre-compiles all available theme
 *     partials and layout templates for high-performance rendering.
 *
 * 3.  **Data Resolution:** It resolves all dynamic data needed for the page, such
 *     as navigation links and image URLs, using the synchronized manifest.
 *
 * 4.  **Style Generation:** It generates a dynamic, inline `<style>` block by
 *     converting the synchronized theme configuration into CSS variables.
 *
 * 5.  **Final Render:** It renders the main content layout and then injects that
 *     HTML into the theme's base shell (`base.hbs`) to produce the final,
 *     complete HTML document.
 */

// --- Type Definitions ---
export interface RenderOptions {
  siteRootPath: string;
  isExport: boolean;
  relativeAssetPath?: string;
}

// --- Helper Functions ---

/**
 * Registers all core Handlebars helpers. Uses a simple flag on the Handlebars
 * object to ensure this only happens once per application lifecycle.
 * @param {LocalSiteData} siteData - The complete site data, passed to helper factories.
 */
function registerCoreHelpers(siteData: LocalSiteData) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((Handlebars as any)._helpersRegistered) return;

    for (const helperFactory of coreHelpers) {
        const helperMap = helperFactory(siteData);
        for (const helperName in helperMap) {
            Handlebars.registerHelper(helperName, helperMap[helperName]);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Handlebars as any)._helpersRegistered = true;
}

/**
 * Pre-compiles and caches all available layout and theme partials in Handlebars.
 * This is crucial for performance and enables synchronous access to templates
 * during rendering (e.g., via the `render_layout_for_item` helper).
 * @param {LocalSiteData} siteData - The complete site data.
 */
async function cacheAllTemplates(siteData: LocalSiteData) {
    for (const partial in Handlebars.partials) {
        if (Object.prototype.hasOwnProperty.call(Handlebars.partials, partial)) {
            Handlebars.unregisterPartial(partial);
        }
    }

    const { manifest } = siteData;
    const allLayouts = await getAvailableLayouts(siteData);

    const layoutPromises = allLayouts.map(async (layoutManifest) => {
        if (!layoutManifest?.files) return;
        const templateFile = layoutManifest.files.find((f: AssetFile) => f.type === 'template');
        if (templateFile) {
            const templateSource = await getAssetContent(siteData, 'layout', layoutManifest.id, templateFile.path);
            if (templateSource) {
                Handlebars.registerPartial(layoutManifest.id, templateSource);
            }
        }
    });

    const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', manifest.theme.name, 'theme.json');
    const themePartialPromises = (themeManifest?.files || [])
        .filter((file: AssetFile) => file.type === 'partial' && file.name)
        .map(async (partial) => {
            const templateSource = await getAssetContent(siteData, 'theme', manifest.theme.name, partial.path);
            if (templateSource) {
                Handlebars.registerPartial(partial.name!, templateSource);
            }
        });

    await Promise.all([...layoutPromises, ...themePartialPromises]);
}

/**
 * Generates an inline <style> block from the site's theme configuration.
 * It directly converts snake_case keys from the config (e.g., "color_primary")
 * into --kebab-case CSS variables (e.g., "--color-primary") for the browser.
 * @param {ThemeConfig['config']} themeConfig - The complete theme configuration object.
 * @returns {string} A string containing a complete <style> tag.
 */
function generateStyleOverrides(themeConfig: ThemeConfig['config']): string {
  if (!themeConfig || Object.keys(themeConfig).length === 0) return '';

  const variables = Object.entries(themeConfig)
    .map(([key, value]) => {
      if (value) {
        const cssVariable = `--${key.replace(/_/g, '-')}`;
        return `  ${cssVariable}: ${value};`;
      }
      return null;
    })
    .filter(Boolean)
    .join('\n');

  if (!variables) return '';

  return `<style id="signum-style-overrides">\n:root {\n${variables}\n}\n</style>`;
}

/**
 * Renders a resolved page into a full HTML string based on the active theme and assets.
 * @param {LocalSiteData} siteData - The original site data from the store.
 * @param {PageResolutionResult} resolution - The resolved content for the current page.
 * @param {RenderOptions} options - Rendering options (e.g., for export or live preview).
 * @returns {Promise<string>} A promise that resolves to the final HTML string.
 */
export async function render(
  siteData: LocalSiteData, 
  resolution: PageResolutionResult, 
  options: RenderOptions
): Promise<string> {
    if (resolution.type === PageType.NotFound) {
      return `<h1>404 - Not Found</h1><p>${resolution.errorMessage}</p>`;
    }

    // --- STEP 1: "Merge on Render" ---
    const savedThemeConfig = siteData.manifest.theme;
    
    const { initialConfig: finalMergedConfig } = await getMergedThemeDataForForm(
        savedThemeConfig.name, 
        savedThemeConfig.config
    );    

    
    // Create a temporary, fully up-to-date manifest and siteData for this render cycle.
     const synchronizedManifest = { 
        ...siteData.manifest, 
        theme: { ...savedThemeConfig, config: finalMergedConfig }
    };
    const synchronizedSiteData = { ...siteData, manifest: synchronizedManifest };
    // ---

    // Register helpers and cache templates using the synchronized data.
    registerCoreHelpers(synchronizedSiteData);
    await cacheAllTemplates(synchronizedSiteData);

    const themePath = synchronizedManifest.theme.name;
    const pageLayoutPath = resolution.layoutPath;

    // --- STEP 2: Render the main body content ---
    const pageLayoutSource = Handlebars.partials[pageLayoutPath];
    if (!pageLayoutSource) {
        return `Error: Page layout template "${pageLayoutPath}" not found.`;
    }
    const pageLayoutTemplate = Handlebars.compile(pageLayoutSource);
    const bodyHtml = await pageLayoutTemplate({ ...resolution, options });

    // --- STEP 3: Resolve all top-level dynamic data ---
    const currentPageExportPath = getUrlForNode(resolution.contentFile, synchronizedManifest, true);
    const navLinks = generateNavLinks(synchronizedSiteData, currentPageExportPath, options);
    const siteBaseUrl = synchronizedManifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
    const canonicalUrl = new URL(currentPageExportPath, siteBaseUrl).href;
    const baseUrl = options.isExport ? (options.relativeAssetPath ?? '') : (typeof window !== 'undefined' ? window.location.origin : '');

    const imageService = getActiveImageService(synchronizedManifest);
    let logoUrl: string | undefined;
    if (synchronizedManifest.logo) {
      try {
          logoUrl = await imageService.getDisplayUrl(synchronizedManifest, synchronizedManifest.logo, { height: 32 }, options.isExport);
      } catch (e) { console.warn("Could not generate logo URL:", e); }
    }
  
    let faviconUrl: string | undefined;
    if (synchronizedManifest.favicon) {
        try {
            faviconUrl = await imageService.getDisplayUrl(synchronizedManifest, synchronizedManifest.favicon, { width: 32, height: 32 }, options.isExport);
        } catch (e) { console.warn("Could not generate favicon URL:", e); }
    }

    // Generate style overrides from the final merged config.
    const styleOverrides = generateStyleOverrides(synchronizedManifest.theme.config);

    // --- STEP 4: Render the final document in the base theme shell ---
    const themeManifest = await getJsonAsset<ThemeManifest>(synchronizedSiteData, 'theme', themePath, 'theme.json');
    if (!themeManifest) return 'Error: Could not load theme manifest.';
    const baseTemplateFile = themeManifest.files.find((f: AssetFile) => f.type === 'base');
    if (!baseTemplateFile) return 'Error: Theme manifest is missing a file with type "base".';
  
    const baseTemplateSource = await getAssetContent(synchronizedSiteData, 'theme', themePath, baseTemplateFile.path);
    if (!baseTemplateSource) return 'Error: Could not load base template source.';
    const baseTemplate = Handlebars.compile(baseTemplateSource);

    const finalContext = {
      manifest: synchronizedManifest,
      navLinks,
      year: new Date().getFullYear(),
      headContext: {
          pageTitle: resolution.pageTitle,
          manifest: synchronizedManifest,
          contentFile: resolution.contentFile,
          canonicalUrl: canonicalUrl,
          baseUrl: baseUrl,
          styleOverrides: new Handlebars.SafeString(styleOverrides),
          faviconUrl: faviconUrl,
      },
      body: new Handlebars.SafeString(bodyHtml),
      logoUrl: logoUrl,
      options: options,
      ...resolution,
    };

    return baseTemplate(finalContext);
}

================================================================================

File: core/services/theme-engine/helpers/strUtil.helper.ts
// src/core/services/theme-engine/helpers/strUtil.helper.ts
import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const strUtilHelper: SignumHelper = () => ({
  /**
   * A generic string utility helper for common text manipulations like
   * truncating, uppercasing, and lowercasing.
   *
   * @example {{str-util some.text op="truncate" len=100}}
   * @example {{str-util some.text op="uppercase"}}
   */
  // --- FIX: The function signature now correctly matches SignumHelperFunction ---
  'str-util': function(...args: unknown[]): string {
    // The options object from Handlebars is always the last argument.
    const options = args.pop() as HelperOptions;
    // The input string is the first argument passed from the template.
    const input = args[0];
  
    // Type guard: Ensure the input is a valid string before proceeding.
    if (!input || typeof input !== 'string') {
        // Return an empty string if the input is not a string, null, or undefined.
        return '';
    }
  
    // Extract the desired operation from the helper's hash arguments.
    const op = options.hash.op;
  
    switch (op) {
      case 'truncate':
        // Safely get the length, with a default value.
        const len = typeof options.hash.len === 'number' ? options.hash.len : 140;
        if (input.length <= len) return input;
        return input.substring(0, len) + 'â¦';
      
      case 'uppercase':
        return input.toUpperCase();
      
      case 'lowercase':
        return input.toLowerCase();
      
      default:
        // If no valid operation is specified, return the original string.
        return input;
    }
  }
});

================================================================================

File: core/services/theme-engine/helpers/concat.helper.ts
// src/core/services/theme-engine/helpers/concat.helper.ts

import { SignumHelper } from './types';

export const concatHelper: SignumHelper = () => ({
  /**
   * Concatenates multiple string arguments into a single string.
   *
   * @example
   * {{concat "Hello" " " "World"}} -> "Hello World"
   *
   * @example
   * <img alt=(concat @root.manifest.title " Logo")>
   */
  concat: function(...args: unknown[]): string {
    // The last argument provided by Handlebars is the 'options' object. 
    //const options = args.pop() as HelperOptions;

    // Join all other arguments with an empty string.
    return args.join('');
  },
});

================================================================================

File: core/services/theme-engine/helpers/query.helper.ts
// src/core/services/theme-engine/helpers/query.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';

// The helper factory receives the full siteData object, which it can use.
export const queryHelper: SignumHelper = (siteData) => ({
  /**
   * Fetches, filters, and sorts a list of content items from a collection.
   * The resulting array is made available to the inner block of the helper.
   *
   * @example
   * {{#query source_collection="blog" limit=5 as |posts|}}
   *   {{#each posts}} ... {{/each}}
   * {{/query}}
   */
  // --- FIX: The function signature now correctly matches SignumHelperFunction ---
  // The 'this' context is now 'unknown' and is not used.
  query: function(this: unknown, ...args: unknown[]): string {
    const options = args[args.length - 1] as Handlebars.HelperOptions;
    const config = options.hash;

    const sourceCollectionSlug = config.source_collection;
    if (!sourceCollectionSlug || typeof sourceCollectionSlug !== 'string') {
      console.warn("Query helper called without a valid 'source_collection' string.");
      return options.inverse ? options.inverse(this) : '';
    }

    // Find the source collection node in the site's structure.
    const collectionNode = siteData.manifest.structure.find(
        n => n.slug === sourceCollectionSlug
    );
    if (!collectionNode || !collectionNode.children) {
      console.warn(`Query could not find collection with slug: "${sourceCollectionSlug}"`);
      return options.inverse ? options.inverse(this) : '';
    }
    
    const childPaths = new Set(collectionNode.children.map(c => c.path));
    let items = (siteData.contentFiles ?? []).filter(f => childPaths.has(f.path));

    const sortBy = config.sort_by || 'date';
    const sortOrder = config.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    items.sort((a, b) => {
      const valA = a.frontmatter[sortBy];
      const valB = b.frontmatter[sortBy];
      if (sortBy === 'date') {
        const dateA = valA ? new Date(valA as string).getTime() : 0;
        const dateB = valB ? new Date(valB as string).getTime() : 0;
        if (isNaN(dateA) || isNaN(dateB)) return 0;
        return (dateA - dateB) * orderModifier;
      }
      if (typeof valA === 'string' && typeof valB === 'string') {
        return valA.localeCompare(valB) * orderModifier;
      }
      if (typeof valA === 'number' && typeof valB === 'number') {
        return (valA - valB) * orderModifier;
      }
      return 0;
    });

    if (config.limit) {
      const limit = parseInt(config.limit, 10);
      if (!isNaN(limit)) {
        items = items.slice(0, limit);
      }
    }

    // Render the inner block, passing the queried items as a block parameter.
    if (options.data && options.fn) {
        const data = Handlebars.createFrame(options.data);
        const blockParamName = options.data.blockParams?.[0];
        if (blockParamName) {
            data[blockParamName] = items;
        }
        return options.fn(items, { data });
    }
    
    return options.fn(items);
  }
});

================================================================================

File: core/services/theme-engine/helpers/markdown.helper.ts
// src/core/services/theme-engine/helpers/markdown.helper.ts
import { SignumHelper } from './types';
import Handlebars from 'handlebars';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

export const markdownHelper: SignumHelper = () => ({
  /**
   * Safely renders a string of Markdown into HTML.
   * It uses 'marked' to parse the Markdown and 'DOMPurify' to sanitize
   * the resulting HTML, preventing XSS attacks.
   * @example {{{markdown some.body_content}}}
   */
  // --- FIX: The function signature now correctly matches SignumHelperFunction ---
  markdown: function(...args: unknown[]): Handlebars.SafeString {
    // The markdown content is the first argument passed to the helper.
    const markdownString = args[0];

    // Type guard: Ensure the input is a non-empty string before processing.
    if (!markdownString || typeof markdownString !== 'string') {
      return new Handlebars.SafeString('');
    }

    // Use marked to parse, then DOMPurify to sanitize against XSS attacks.
    const unsafeHtml = marked.parse(markdownString, { async: false }) as string;
    
    // Check if running in a browser environment before using DOMPurify
    if (typeof window !== 'undefined') {
        const safeHtml = DOMPurify.sanitize(unsafeHtml);
        return new Handlebars.SafeString(safeHtml);
    }

    // If not in a browser (e.g., during server-side testing), return the raw parsed HTML.
    // In a real-world scenario, you might use a Node.js-compatible sanitizer here.
    return new Handlebars.SafeString(unsafeHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/comparison.helper.ts
// src/core/services/theme-engine/helpers/comparison.helper.ts
import { SignumHelper } from './types';

/**
 * Provides a set of comparison helpers for Handlebars templates.
 * These helpers are now type-safe and handle 'unknown' inputs correctly.
 *
 * @example
 * {{#if (eq post.status "published")}} ... {{/if}}
 * {{#if (gt comment.likes 10)}} ... {{/if}}
 */
export const comparisonHelpers: SignumHelper = () => ({
  /**
   * Checks for strict equality (===). Safe for any type.
   */
  eq: (a: unknown, b: unknown): boolean => a === b,

  /**
   * Checks if the first argument is greater than the second.
   * Only compares numbers or strings. Returns false for other types.
   */
  gt: (a: unknown, b: unknown): boolean => {
    // --- FIX: Add type guards to safely perform the comparison ---
    // Only proceed if both 'a' and 'b' are of the same comparable type.
    if (typeof a === 'number' && typeof b === 'number') {
      return a > b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
      return a > b;
    }
    // For all other type combinations, comparison is not meaningful.
    return false;
  },

  /**
   * Checks if the first argument is less than the second.
   * Only compares numbers or strings. Returns false for other types.
   */
  lt: (a: unknown, b: unknown): boolean => {
    // --- FIX: Add type guards to safely perform the comparison ---
    if (typeof a === 'number' && typeof b === 'number') {
      return a < b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
      return a < b;
    }
    return false;
  },
});

================================================================================

File: core/services/theme-engine/helpers/getUrl.helper.ts
// src/core/services/theme-engine/helpers/getUrl.helper.ts
import { SignumHelper } from './types';
import { getUrlForNode as getUrlUtil } from '@/core/services/urlUtils.service';
import type { StructureNode } from '@/types';
import { HelperOptions } from 'handlebars';

// The helper factory receives the full siteData object.
export const getUrlHelper: SignumHelper = (siteData) => ({
  /**
   * A Handlebars helper to expose the getUrlForNode utility to templates.
   * This allows templates to generate correct, context-aware links for pages.
   *
   * @example
   * <a href="{{getUrlForNode this isExport=../options.isExport}}">Link</a>
   */
  // --- FIX: Corrected the function signature to match SignumHelperFunction ---
  getUrlForNode: function(this: unknown, ...args: unknown[]): string {
    // The options object from Handlebars is always the last argument.
    const options = args.pop() as HelperOptions;
    
    // The node object is the first argument passed from the template.
    const node = args[0] as StructureNode;
    
    // Extract the 'isExport' flag from the helper's hash arguments.
    const isExport = options.hash.isExport === true;
    
    // Type guard to ensure the node is valid before proceeding.
    if (!node || typeof node !== 'object' || !('path' in node) || !('slug' in node)) {
        console.warn('Handlebars "getUrlForNode" helper was called with an invalid node object.');
        return '#error-invalid-node';
    }

    // --- FIX: Pass the required `manifest` object from the factory's scope ---
    // The utility function needs the full manifest to determine if the node is the homepage.
    return getUrlUtil(node, siteData.manifest, isExport);
  }
});

================================================================================

File: core/services/theme-engine/helpers/types.ts
// src/core/services/theme-engine/helpers/types.ts
import { LocalSiteData } from '@/types';
import Handlebars from 'handlebars';

/**
 * Defines the function signature for a Handlebars helper function within Signum.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
export type SignumHelperFunction = (
  /**
   * FIX: Replaced 'any' with 'unknown' for the 'this' context.
   * The context within a Handlebars helper is dynamic. 'unknown' is the
   * type-safe equivalent of 'any', requiring type checks before use.
   */
  this: unknown,
  /**
   * FIX: Replaced 'any[]' with 'unknown[]' for the helper arguments.
   * Helpers can receive a variable number of arguments of any type.
   * 'unknown[]' safely represents this contract.
   */
  ...args: unknown[]
) => string | Handlebars.SafeString | boolean | Promise<Handlebars.SafeString>;

/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 */
export type SignumHelper = (siteData: LocalSiteData) => Record<string, SignumHelperFunction>;

================================================================================

File: core/services/theme-engine/helpers/pager.helper.ts
// src/core/services/theme-engine/helpers/pager.helper.ts

import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { PaginationData } from '@/types';

/**
 * A type guard to check if an unknown value has the shape of PaginationData.
 * @param data The unknown data to check.
 * @returns {boolean} True if the data is valid PaginationData.
 */
function isPaginationData(data: unknown): data is PaginationData {
    if (typeof data !== 'object' || data === null) {
        return false;
    }
    const d = data as PaginationData;
    return (
        typeof d.currentPage === 'number' &&
        typeof d.totalPages === 'number' &&
        typeof d.hasPrevPage === 'boolean' &&
        typeof d.hasNextPage === 'boolean'
    );
}


/**
 * Renders a complete pagination control component.
 * It generates 'Previous' and 'Next' links and a 'Page X of Y' indicator.
 * The links are disabled when not applicable (e.g., on the first or last page).
 * 
 * @example
 * {{{pager pagination}}}
 */
export const pagerHelper: SignumHelper = () => ({
  // --- FIX: The function signature now correctly matches SignumHelperFunction ---
  pager: function(...args: unknown[]): Handlebars.SafeString {
    // The pagination object is the first argument passed from the template.
    const pagination = args[0];

    // --- FIX: Use the type guard to validate the input ---
    if (!isPaginationData(pagination) || pagination.totalPages <= 1) {
      return new Handlebars.SafeString('');
    }

    const prevPageUrl = pagination.prevPageUrl ?? '#';
    const nextPageUrl = pagination.nextPageUrl ?? '#';

    const prevLink = pagination.hasPrevPage
      ? `<a href="${prevPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">â¹ Previous</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50 cursor-not-allowed">â¹ Previous</span>`;

    const nextLink = pagination.hasNextPage
      ? `<a href="${nextPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">Next âº</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50 cursor-not-allowed">Next âº</span>`;
    
    const pageIndicator = `<div class="f6 mid-gray">Page ${pagination.currentPage} of ${pagination.totalPages}</div>`;

    const pagerHtml = `
      <div class="flex items-center justify-between mt4 pt3 bt b--black-10">
        <div>${prevLink}</div>
        <div>${pageIndicator}</div>
        <div>${nextLink}</div>
      </div>
    `;

    return new Handlebars.SafeString(pagerHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/assign.helper.ts
// src/core/services/theme-engine/helpers/assign.helper.ts
import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const assignHelper: SignumHelper = () => ({
  /**
   * A Handlebars helper to add a new property to an object's context
   * before rendering a block. This is useful for augmenting data inside a loop.
   *
   * @example
   * {{#assign myItem "newUrl" "https://example.com"}}
   *   <a href="{{this.newUrl}}">{{this.title}}</a>
   * {{/assign}}
   */
  // --- FIX: The function signature now correctly matches SignumHelperFunction ---
  assign: function(this: unknown, ...args: unknown[]): string {
    // The last argument passed by Handlebars is always the options object.
    const options = args.pop() as HelperOptions;

    // We expect 3 arguments from the template: [object, key, value]
    if (args.length !== 3) {
      console.warn('Handlebars "assign" helper called with incorrect number of arguments. Expected 3.');
      // Gracefully fail by rendering the {{else}} block if it exists.
      return options.inverse ? options.inverse(this) : '';
    }

    const [object, key, value] = args;

    // Add type guards to ensure the arguments are used safely.
    if (typeof object !== 'object' || object === null) {
      console.warn(`Handlebars "assign" helper: first argument must be an object, but received type ${typeof object}.`);
      return options.inverse ? options.inverse(this) : '';
    }

    if (typeof key !== 'string' || key === '') {
      console.warn(`Handlebars "assign" helper: second argument must be a non-empty string key, but received type ${typeof key}.`);
      return options.inverse ? options.inverse(this) : '';
    }

    // Create a new context object by spreading the original and adding the new key-value pair.
    const newContext = { ...object, [key]: value };

    // Execute the inner block of the helper, passing the new, augmented context to it.
    // This is what makes the new property available inside the {{#assign}}...{{/assign}} block.
    return options.fn(newContext);
  },
});

================================================================================

File: core/services/theme-engine/helpers/index.ts
// src/lib/theme-helpers/index.ts
// ... (other helper imports)
import { queryHelper } from './query.helper';
import { comparisonHelpers } from './comparison.helper';
import { renderLayoutForItemHelper } from './renderLayoutForItem.helper';
import { markdownHelper } from './markdown.helper';
import { strUtilHelper } from './strUtil.helper';
import { formatDateHelper } from './formatDate.helper';
import { pagerHelper } from './pager.helper';
import { SignumHelper } from './types';
import { getUrlHelper } from './getUrl.helper';
import { assignHelper } from './assign.helper';
import { imageHelper } from './image.helper';
import { concatHelper } from './concat.helper';

export const coreHelpers: SignumHelper[] = [
  queryHelper,
  strUtilHelper,
  formatDateHelper,
  comparisonHelpers,
  markdownHelper,
  renderLayoutForItemHelper, 
  pagerHelper,
  getUrlHelper,
  assignHelper,
  imageHelper,
  concatHelper
];

================================================================================

File: core/services/theme-engine/helpers/formatDate.helper.ts
// src/core/services/theme-engine/helpers/formatDate.helper.ts
import { SignumHelper } from './types';

export const formatDateHelper: SignumHelper = () => ({
  /**
   * Formats a date string or Date object into a more readable format.
   * @example {{formatDate some.date_string}}
   * @example {{formatDate "2023-10-27"}}
   */
  // --- FIX: The function signature now correctly matches SignumHelperFunction ---
  formatDate: function(...args: unknown[]): string {
    // The date value is the first argument passed to the helper.
    const dateString = args[0];

    // Type guard: Check if the input is a valid type for the Date constructor.
    if (
        !dateString ||
        (typeof dateString !== 'string' &&
         typeof dateString !== 'number' &&
         !(dateString instanceof Date))
    ) {
      // If the input is null, undefined, or an invalid type, return an empty string.
      return '';
    }
    
    // The Date constructor can safely handle string, number, or Date objects.
    const date = new Date(dateString);
    
    // Check if the created date is valid. `new Date('invalid')` results in an invalid date.
    if (isNaN(date.getTime())) {
      console.warn(`Handlebars "formatDate" helper received an invalid date value:`, dateString);
      return ''; // Return empty for invalid dates
    }

    // Format the valid date into a user-friendly string.
    return date.toLocaleDateString('en-GB', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  }
});

================================================================================

File: core/services/theme-engine/helpers/renderLayoutForItem.helper.ts
// src/core/services/theme-engine/helpers/renderLayoutForItem.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import type { ParsedMarkdownFile } from '@/types';
import type { HelperOptions } from 'handlebars';

export const renderLayoutForItemHelper: SignumHelper = () => ({
  /**
   * Renders a specific layout for a single content item.
   * This is used inside a view template's `each` loop to render item cards, etc.
   * @example {{{render_layout_for_item this layout=../contentFile.frontmatter.collection.item_layout}}}
   */
  // --- FIX: The function signature now correctly matches SignumHelperFunction ---
  render_layout_for_item: function(this: unknown, ...args: unknown[]): string | Handlebars.SafeString {
    // The options object from Handlebars is always the last argument.
    const options = args.pop() as HelperOptions;
    // The content item object is the first argument passed from the template.
    const item = args[0] as ParsedMarkdownFile;

    // Extract the desired layout ID from the helper's hash arguments.
    const layoutId = options.hash.layout;

    // Type guards to ensure we have valid data before proceeding.
    if (!item || typeof item !== 'object') {
        console.warn('[render_layout_for_item] Helper called without a valid item object.');
        return '';
    }
    if (!layoutId || typeof layoutId !== 'string') {
        console.warn('[render_layout_for_item] Helper called without a valid layout ID.');
        return '';
    }

    // Retrieve the pre-compiled template from Handlebars' partials cache.
    const layoutTemplateSource = Handlebars.partials[layoutId];

    if (layoutTemplateSource) {
        // If the template exists, compile it and render with the item's data.
        const layoutTemplate = Handlebars.compile(layoutTemplateSource);
        return new Handlebars.SafeString(layoutTemplate(item));
    }

    // If the template is not found, return a helpful HTML comment for debugging.
    console.warn(`[render_layout_for_item] Item layout template "${layoutId}" not found.`);
    return `<!-- Item layout "${layoutId}" not found -->`;
  }
});

================================================================================

File: core/services/theme-engine/helpers/image.helper.ts
// src/core/services/theme-engine/helpers/image.helper.ts

import Handlebars from 'handlebars';
import { SignumHelper } from './types';
// --- FIX: Import ImageTransformOptions along with the other types ---
import { ImageRef, LocalSiteData, ImageTransformOptions } from '@/types';
import { getActiveImageService } from '@/core/services/images/images.service';

interface RootTemplateContext {
  options: {
    isExport: boolean;
  };
}

export const imageHelper: SignumHelper = (siteData: LocalSiteData) => ({
  /**
   * An async Handlebars helper to generate image URLs with transformations.
   * It reads parameters from the helper's hash.
   * @example {{{image src=logo width=100 height=100}}}
   */
  image: async function(this: unknown, ...args: unknown[]): Promise<Handlebars.SafeString> {
    // The actual options object from Handlebars is always the last argument.
    const options = args[args.length - 1] as Handlebars.HelperOptions;
    
    const rootContext = options.data.root as RootTemplateContext;
    const isExport = rootContext.options?.isExport || false;

    // Destructure properties from the hash object within options.
    const { src, width, height, crop, gravity, alt, lazy = true, class: className = '' } = options.hash;

    if (!src || typeof src !== 'object' || !('serviceId' in src)) {
      return new Handlebars.SafeString('<!-- Invalid ImageRef provided to image helper -->');
    }

    const imageRef = src as ImageRef;

    try {
      const imageService = getActiveImageService(siteData.manifest);
      
      const transformOptions: ImageTransformOptions = { width, height, crop, gravity };

      const displayUrl = await imageService.getDisplayUrl(siteData.manifest, imageRef, transformOptions, isExport);
      
      const lazyAttr = lazy ? 'loading="lazy"' : '';
      const altAttr = `alt="${alt || imageRef.alt || ''}"`;
      const classAttr = className ? `class="${className}"` : '';
      const widthAttr = width ? `width="${width}"` : '';
      const heightAttr = height ? `height="${height}"` : '';

      const imgTag = `<img src="${displayUrl}" ${widthAttr} ${heightAttr} ${altAttr} ${classAttr} ${lazyAttr}>`;

      return new Handlebars.SafeString(imgTag);
    } catch (error) {
      console.error(`[ImageHelper] Failed to render image for src: ${imageRef.src}`, error);
      return new Handlebars.SafeString(`<!-- Image render failed: ${(error as Error).message} -->`);
    }
  }
});

================================================================================

File: app/layout.tsx
// src/app/layout.tsx
'use client'; 

import { useEffect, useState, Suspense } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import './globals.css'; 
import { Toaster } from "@/core/components/ui/sonner"; 
import { ThemeProvider } from "@/core/components/ThemeProvider";
import { useInitialiseUIStore } from '@/core/hooks/useInitialiseUIStore';

function AppLoadingIndicator() {
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading Signum...</p>
      </div>
    </div>
  ); 
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  useInitialiseUIStore();
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true); 
    // Initialize the app state from storage only once
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]); 

  // Show the loading indicator only on the client and before initialization is complete
  const showLoading = clientMounted && !isInitialized;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Signum - Decentralized Publishing</title>
      </head>
      <body className="h-full">
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
          {showLoading ? (
            <AppLoadingIndicator />
          ) : (
         
                <Suspense fallback={<AppLoadingIndicator />}>
                  {children}
                </Suspense>
              
          )}
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================================================================================

File: app/page.tsx
// src/app/page.tsx
'use client';

import { Button } from '@/core/components/ui/button';
import { Link } from '@/core/components/ui/link';
import { ShieldCheck, Feather, Zap, Archive, Leaf } from 'lucide-react';

export default function MarketingHomePage() {
  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto px-4 py-16 sm:py-24 text-center">
      <header className="mb-12">
        <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold tracking-tight text-foreground">
          Signum: Own Your Content.
        </h1>
        <p className="mt-4 max-w-2xl mx-auto text-lg sm:text-xl text-muted-foreground">
          A simple, private, and portable publishing platform that puts you back in control.
        </p>
      </header>

      <div className="mb-16">
        <Button asChild size="lg">
          <Link href="/sites">
            Open Dashboard & Get Started
          </Link>
        </Button>
      </div>

      <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 max-w-5xl mx-auto">
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <ShieldCheck className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Private & Secure</h3>
          <p className="text-muted-foreground text-sm">
            No tracking or surveillance by default. Your data is yours.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Feather className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Simple & Focused</h3>
          <p className="text-muted-foreground text-sm">
            A minimal, content-first editor lets you focus on writing.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Zap className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Blazingly Fast</h3>
          <p className="text-muted-foreground text-sm">
            Static sites are fast, reliable, and efficient to host.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Archive className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Truly Portable</h3>
          <p className="text-muted-foreground text-sm">
            Export your entire site anytime. No vendor lock-in, ever.
          </p>
        </div>
      </section>
    </div>
    </>
  );
}

================================================================================

File: app/globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: app/sites/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';

export default function SiteLoaderLayout({ children }: { children: React.ReactNode }) {
  const params = useParams();
  const siteId = params.siteId as string;

  // --- USE THE NEW ACTION ---
  const loadSiteAction = useAppStore(state => state.loadSite);
  
  useEffect(() => {
    if (siteId) {
      // This will now reliably load the manifest and content files.
      loadSiteAction(siteId);
    }
  }, [siteId, loadSiteAction]);

  return <>{children}</>;
}

================================================================================

File: app/sites/page.tsx
// src/app/sites/page.tsx
'use client';

import { useState, useRef, useCallback } from 'react';
import Link from 'next/link';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import {
  FilePlus2,
  Leaf,
  Upload,
  Eye,
  Edit3,
  Archive,
  Trash2,
  MoreVertical,
} from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/core/components/ui/dropdown-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/core/components/ui/alert-dialog";
import { toast } from "sonner";
import { importSiteFromZip, exportSiteBackup } from '@/core/services/siteBackup.service';
import { saveAllImageAssetsForSite } from '@/core/services/localFileSystem.service';
import { LocalSiteData } from '@/types';
import { slugify } from '@/lib/utils';

export default function HomePageDashboard() {
  const { sites, getSiteById, addSite, updateSiteSecrets, loadSite, deleteSiteAndState } = useAppStore();
  const [isImporting, setIsImporting] = useState(false);
  const [isOverwriteDialogOpen, setIsOverwriteDialogOpen] = useState(false);
  const [importedData, setImportedData] = useState<(LocalSiteData & { imageAssetsToSave?: Record<string, Blob> }) | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  /**
   * Finishes the import process by saving the data to the store and storage.
   * This is called either directly for a new site or after overwrite confirmation.
   */
  const finishImport = useCallback(async (data: LocalSiteData & { imageAssetsToSave?: Record<string, Blob> }) => {
    try {
      // --- FIX: Separate the binary data from the serializable data ---
      // The `imageAssetsToSave` property is transient and must not be passed
      // to the main `addSite` action, as it will cause a serialization error.
      const { imageAssetsToSave, ...siteDataToSave } = data;

      // 1. Save the core site data (manifest, content, etc.) which is JSON-serializable.
      await addSite(siteDataToSave);
      
      // 2. Save secrets to their dedicated store.
      if(siteDataToSave.secrets) {
        await updateSiteSecrets(siteDataToSave.siteId, siteDataToSave.secrets);
      }
      
      // 3. Save the image Blobs to their dedicated binary storage.
      if(imageAssetsToSave) {
        await saveAllImageAssetsForSite(siteDataToSave.siteId, imageAssetsToSave);
      }
      
      toast.success(`Site "${data.manifest.title}" imported successfully!`);
    } catch (error) {
      console.error("Error finishing site import:", error);
      toast.error(`Failed to save imported site: ${(error as Error).message}`);
    }
  }, [addSite, updateSiteSecrets]);

  const handleFileSelected = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setIsImporting(true);
    toast.info("Importing site from backup...");

    try {
      const data = await importSiteFromZip(file);
      const existingSite = getSiteById(data.siteId);

      if (existingSite) {
        setImportedData(data);
        setIsOverwriteDialogOpen(true);
      } else {
        await finishImport(data);
      }
    } catch (error) {
      console.error("Error during site import:", error);
      toast.error(`Import failed: ${(error as Error).message}`);
    } finally {
      if (fileInputRef.current) fileInputRef.current.value = "";
      setIsImporting(false);
    }
  };

  const handleOverwriteConfirm = async () => {
    if (importedData) await finishImport(importedData);
    setIsOverwriteDialogOpen(false);
    setImportedData(null);
  };
  
  const handleExportBackup = async (siteId: string) => {
    toast.info("Preparing site backup...");
    try {
        await loadSite(siteId);
        const siteToExport = getSiteById(siteId);
        if (!siteToExport) throw new Error("Could not load site data for export.");
        const blob = await exportSiteBackup(siteToExport);
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${slugify(siteToExport.manifest.title || 'signum-backup')}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        toast.success("Site backup downloaded!");
    } catch (error) {
        console.error("Failed to export site:", error);
        toast.error(`Export failed: ${(error as Error).message}`);
    }
  };

  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

  const validSites = sites.filter(site => site && site.manifest);

  return (
    <>
      <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
        <div className="container mx-auto flex h-16 items-center justify-between px-4">
          <Link href="/" className="flex items-center gap-2">
            <Leaf className="h-7 w-7 text-primary" />
            <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
          </Link>
          <div className="flex items-center gap-2">
            <Button variant="outline" onClick={() => fileInputRef.current?.click()} disabled={isImporting}>
              <Upload className="mr-2 h-4 w-4" /> {isImporting ? 'Importing...' : 'Import site'}
            </Button>
            <Button asChild>
              <Link href="/create-site"><FilePlus2 className="mr-2 h-4 w-4" /> Create new site</Link>
            </Button>
          </div>
        </div>
      </header>
      
      <main className="container mx-auto p-4 sm:p-6 lg:p-8">
        <h1 className="text-3xl font-bold text-foreground mb-8">My sites</h1>
        {validSites.length === 0 ? (
          <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
            <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
            <p className="text-muted-foreground mb-4">Click &quot;Create New Site&quot; or &quot;Import Site&quot; to get started.</p>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {validSites.map((site) => (
              <div key={site.siteId} className="bg-card border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between">
                <div>
                  <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.manifest.title}>
                    {site.manifest.title || "Untitled Site"}
                  </h2>
                  <p className="text-sm text-muted-foreground mb-4 line-clamp-2" title={site.manifest.description}>
                    {site.manifest.description || 'No description provided.'}
                  </p>
                </div>
                <div className="mt-4 flex flex-wrap justify-end gap-2">
                  <Button variant="default" size="sm" asChild>
                    <Link href={`/sites/${site.siteId}/edit`}><Edit3 className="mr-2 h-4 w-4" /> Edit</Link>
                  </Button>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="outline" size="icon"><MoreVertical className="h-4 w-4" /></Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem asChild><Link href={`/sites/${site.siteId}/view`} target="_blank" rel="noopener noreferrer"><Eye className="mr-2 h-4 w-4" /> View Live Preview</Link></DropdownMenuItem>
                      <DropdownMenuItem onClick={() => handleExportBackup(site.siteId)}><Archive className="mr-2 h-4 w-4" /> Export backup</DropdownMenuItem>
                      <DropdownMenuSeparator />
                      <AlertDialog>
                        <AlertDialogTrigger asChild>
                          <DropdownMenuItem onSelect={(e: Event) => e.preventDefault()} className="text-destructive focus:bg-destructive/10 focus:text-destructive">
                            <Trash2 className="mr-2 h-4 w-4" /> Delete site
                          </DropdownMenuItem>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                            <AlertDialogDescription>This action will permanently delete &quot;{site.manifest.title}&quot; and cannot be undone.</AlertDialogDescription>
                          </AlertDialogHeader>
                          <AlertDialogFooter>
                            <AlertDialogCancel>Cancel</AlertDialogCancel>
                            <AlertDialogAction onClick={() => handleDeleteSite(site.siteId, site.manifest.title)} className="bg-destructive hover:bg-destructive/90">Yes, delete site</AlertDialogAction>
                          </AlertDialogFooter>
                        </AlertDialogContent>
                      </AlertDialog>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>
            ))}
          </div>
        )}
      </main>

      <input type="file" ref={fileInputRef} onChange={handleFileSelected} accept=".zip" className="hidden" />

      <AlertDialog open={isOverwriteDialogOpen} onOpenChange={setIsOverwriteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Site Already Exists</AlertDialogTitle>
            <AlertDialogDescription>
              A site with the ID &quot;{importedData?.siteId}&quot; already exists. Do you want to overwrite it with the data from the backup file?
              <br/><br/>
              <strong>This action cannot be undone.</strong>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setImportedData(null)}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleOverwriteConfirm} className="bg-destructive hover:bg-destructive/90">Overwrite</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

================================================================================

File: app/sites/[siteId]/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import { useEffect, ReactNode, useCallback } from 'react';
import { useParams, usePathname } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import Link from 'next/link';
import Image from 'next/image';
import { TbEdit, TbSettings } from "react-icons/tb";
import { cn } from '@/lib/utils';

/**
 * The root layout for a single site's backend.
 * This component provides the persistent vertical toolbar and, crucially, manages
 * the loading of the active site's data into the global store.
 *
 * RECENT FIX: The data loading logic has been made non-destructive. It now checks
 * if the site's content is already in memory before triggering a full load from
 * storage. This prevents the UI from reverting after a save operation.
 */
export default function SingleSiteLayout({ children }: { children: ReactNode }) {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;

  // --- State and Action Hooks ---
  // Select the specific data and actions needed from the store.
  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const loadSite = useAppStore(state => state.loadSite);
  const setActiveSiteId = useAppStore(state => state.setActiveSiteId);

  // --- FIX: This is the new, "smart" data loading effect ---
  useEffect(() => {
    // Always set the active site ID when this layout is mounted.
    if (siteId) {
      setActiveSiteId(siteId);
    }
    
    // THE CRITICAL GUARD CLAUSE:
    // Only call `loadSite` if the siteId is present AND the site's core content
    // (`contentFiles`) has not yet been loaded into the store.
    if (siteId && (!site || !site.contentFiles)) {
      console.log(`[SiteLayout] Site data for ${siteId} not found in memory. Loading from storage.`);
      loadSite(siteId);
    }

    // Cleanup function: When the user navigates away, clear the activeSiteId.
    return () => {
      setActiveSiteId(null);
    };
  // The dependency array ensures this logic re-evaluates if the siteId changes
  // or if the site object itself is replaced in the store.
  }, [siteId, site, loadSite, setActiveSiteId]);

  // --- Visual Rendering Logic ---
  const isEditorActive = pathname.startsWith(`/sites/${siteId}/edit`);
  const isSettingsActive = pathname.startsWith(`/sites/${siteId}/settings`);

  const navItems = [
    { href: `/sites/${siteId}/edit`, title: 'Edit', icon: TbEdit, isActive: isEditorActive },
    { href: `/sites/${siteId}/settings`, title: 'Settings', icon: TbSettings, isActive: isSettingsActive },
  ];

  return (
    <div className="flex h-screen flex-col lg:flex-row bg-muted/20">
      <aside className="fixed inset-x-0 bottom-0 z-30 flex h-16 w-full shrink-0 border-t bg-background lg:static lg:inset-y-0 lg:left-0 lg:h-full lg:w-[60px] lg:border-r lg:border-t-0">
        <nav className="flex w-full items-center justify-center gap-4 px-2 lg:flex-col lg:justify-start lg:pb-5">
          <Link
            href="/sites"
            title="Dashboard"
            className='lg:flex hidden flex-col items-center w-[60px] h-[60px] border-b'
          >
            <Image src="/signum.svg" width={34} height={34} alt="Signum Logo" className='m-auto'/>
          </Link>
          
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              title={item.title}
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-lg transition-colors',
                item.isActive
                  ? 'bg-accent text-accent-foreground'
                  : 'text-muted-foreground hover:bg-accent/50 hover:text-foreground'
              )}
            >
              <item.icon className="size-6" />
            </Link>
          ))}
        </nav>
      </aside>

      <main className="flex-1 overflow-auto pb-16 lg:pb-0">
        {children}
      </main>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/page.tsx
// src/app/sites/[siteId]/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page now acts as a smart entry point for a site.
// Its only job is to redirect the user to the editor.
export default function SiteRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid polluting the browser's history.
      // This sends the user directly to the site editor.
      router.replace(`/sites/${siteId}/edit`);
    }
  }, [siteId, router]);

  // Display a loading message while the redirect is processed.
  return (
    <div className="flex justify-center items-center h-full">
      <p>Redirecting to editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/layout.tsx
// src/app/sites/[siteId]/settings/layout.tsx
'use client';

import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import SettingsNav from '@/features/site-settings/components/SettingsNav';
import { ReactNode, useEffect } from 'react';
import { useUIStore } from '@/core/state/uiStore';

/**
 * The root layout for the entire settings section.
 * It provides the consistent ThreeColumnLayout structure and manages the
 * global UI state to ensure the left sidebar (with the settings menu) is

 * always visible and the right sidebar is always hidden.
 */
export default function SettingsSectionLayout({ children }: { children: ReactNode }) {
  // --- START: Get state and setters from the UI store ---
  const { 
    leftSidebarContent, 
    rightSidebarContent, 
    setLeftAvailable, 
    setRightAvailable, 
    setRightOpen,
    setLeftSidebarContent,
    setRightSidebarContent 
  } = useUIStore(state => state.sidebar);
  // --- END ---

  // This effect runs once to configure the sidebars for the entire settings section.
  useEffect(() => {
    // 1. Configure availability and state
    setLeftAvailable(true);
    setRightAvailable(false); // No right sidebar in settings
    setRightOpen(false);      // Ensure it's closed

    // 2. Set the static content for the left sidebar
    setLeftSidebarContent(<SettingsNav />);
    // 3. Ensure the right sidebar content is null
    setRightSidebarContent(null);

    // Cleanup when navigating away from the settings section
    return () => {
      setLeftAvailable(false);
      setLeftSidebarContent(null);
    };
  }, [setLeftAvailable, setRightAvailable, setRightOpen, setLeftSidebarContent, setRightSidebarContent]);

  // The final render now uses the ThreeColumnLayout, reading the sidebar
  // content from the store and passing it as props.
  return (
    <ThreeColumnLayout
      leftSidebar={leftSidebarContent}
      rightSidebar={rightSidebarContent} // This will be null, so nothing renders
    >
      {children}
    </ThreeColumnLayout>
  );
}

================================================================================

File: app/sites/[siteId]/settings/page.tsx
// src/app/sites/[siteId]/settings/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { Manifest, ImageRef } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import SiteSettingsForm from '@/features/site-settings/components/SiteSettingsForm'; // Import the main form

// --- FIX: Define the complete form data shape in one place ---
interface PageFormData {
  title: string;
  description: string;
  author: string;
  baseUrl: string;
  logo: ImageRef | undefined;
  favicon: ImageRef | undefined;
}

export default function SiteSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);

  // --- FIX: Manage the entire form's data in a single state object ---
  const [formData, setFormData] = useState<PageFormData | null>(null);

  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);

  // Load all settings from the manifest into the single formData state
  useEffect(() => {
    if (site?.manifest) {
      setIsLoading(true);
      setFormData({
        title: site.manifest.title,
        description: site.manifest.description,
        author: site.manifest.author || '',
        baseUrl: site.manifest.baseUrl || '',
        logo: site.manifest.logo,
        favicon: site.manifest.favicon,
      });
      setHasChanges(false);
      setIsLoading(false);
    }
  }, [site]);
  
  // This single handler receives the complete, updated form data from the child component.
  const handleFormChange = useCallback((newData: PageFormData) => {
    setFormData(newData);
    setHasChanges(true);
  }, []);

  const handleSave = async () => {
    if (!site?.manifest || !formData) {
        toast.error("Form data is not ready. Cannot save.");
        return;
    }
    setIsLoading(true);
    
    // Construct the new manifest directly from the single formData object.
    const newManifest: Manifest = {
      ...site.manifest,
      title: formData.title.trim(),
      description: formData.description.trim(),
      author: formData.author.trim(),
      baseUrl: formData.baseUrl.trim(),
      logo: formData.logo,
      favicon: formData.favicon,
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Site settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving site settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading || !formData) {
    return <div className="p-6">Loading settings...</div>;
  }

  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Site Settings</h1>
        <p className="text-muted-foreground">Manage the core details and identity of your website.</p>
      </div>

      <div className="border-t pt-6">
        {/* --- FIX: Render the single, encapsulated form component --- */}
        <SiteSettingsForm
          siteId={siteId}
          formData={formData}
          onFormChange={handleFormChange}
        />
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/images/page.tsx
// src/app/sites/[siteId]/settings/image/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { Manifest } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { SiteSecrets } from '@/core/services/siteSecrets.service';

type ImageServiceId = 'local' | 'cloudinary';

export default function ImageSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  // Get the site object and the actions from the Zustand store.
  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);
  const updateSiteSecretsAction = useAppStore(state => state.updateSiteSecrets);

  // State for public settings (from manifest)
  const [selectedService, setSelectedService] = useState<ImageServiceId>('local');
  const [cloudinaryCloudName, setCloudinaryCloudName] = useState('');

  // State for private settings (from secrets store)
  const [cloudinaryUploadPreset, setCloudinaryUploadPreset] = useState('');

  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);

  // This effect runs when the component mounts or the site data in the store changes.
  // It populates the form's local state with the authoritative data from the store.
  useEffect(() => {
    if (site?.manifest) {
      setIsLoading(true);

      // Load public settings from the site's manifest
      const { imageService, cloudinary } = site.manifest.settings || {};
      setSelectedService(imageService || 'local');
      setCloudinaryCloudName(cloudinary?.cloudName || '');
      
      // Load private settings from the site's secrets object
      setCloudinaryUploadPreset(site.secrets?.cloudinary?.uploadPreset || '');
      
      setHasChanges(false);
      setIsLoading(false);
    }
  }, [site]); // Re-run this effect if the `site` object in the store is updated
  
  const handleServiceChange = (value: string) => {
    // The value from the Select is a string, which we cast to our specific type.
    setSelectedService(value as ImageServiceId);
    setHasChanges(true);
  };
  
  // This generic handler can still be used for simple text inputs.
  const handleInputChange = (setter: React.Dispatch<React.SetStateAction<string>>, value: string) => {
    setter(value);
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!site?.manifest) {
        toast.error("Site data not available. Cannot save settings.");
        return;
    }
    
    setIsLoading(true);

    // 1. Prepare the new public manifest data
    const newManifest: Manifest = {
      ...site.manifest,
      settings: {
        ...site.manifest.settings,
        imageService: selectedService,
        cloudinary: {
            cloudName: cloudinaryCloudName.trim(),
        },
      },
    };

    // 2. Prepare the new private secrets data
    const newSecrets: SiteSecrets = {
        cloudinary: {
            uploadPreset: cloudinaryUploadPreset.trim(),
        }
    };

    try {
      // 3. Call the store actions to save both data structures.
      // These actions will persist the data and update the global state.
      await updateManifestAction(siteId, newManifest);
      await updateSiteSecretsAction(siteId, newSecrets);
      
      setHasChanges(false);
      // The toast messages are now handled inside the store actions for consistency.
    } catch(error) {
      // The actions will throw on failure, allowing us to catch here if needed.
      console.error("An error occurred during save:", error);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading || !site) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Image Settings</h1>
        <p className="text-muted-foreground">Configure how images are stored and processed for your site.</p>
      </div>

      <div className="border-t pt-6 space-y-6">
        <div className="space-y-2">
            <Label htmlFor="service-select">Image Storage Backend</Label>
            <Select value={selectedService} onValueChange={handleServiceChange}>
                <SelectTrigger id="service-select" className="mt-1">
                    <SelectValue placeholder="Select a service..." />
                </SelectTrigger>
                <SelectContent>
                    <SelectItem value="local">Store in Site Bundle (Default)</SelectItem>
                    <SelectItem value="cloudinary">Upload to Cloudinary</SelectItem>
                </SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">&quot;Local&quot; is best for portability. &quot;Cloudinary&quot; is best for performance.</p>
        </div>
        
        {selectedService === 'cloudinary' && (
            <div className="p-4 border rounded-lg bg-card space-y-4">
                <h3 className="font-semibold text-card-foreground">Cloudinary Settings</h3>
                 <div className="space-y-2">
                    <Label htmlFor="cloud-name">Cloudinary Cloud Name (Public)</Label>
                    <Input
                        id="cloud-name"
                        value={cloudinaryCloudName}
                        onChange={(e) => handleInputChange(setCloudinaryCloudName, e.target.value)}
                        placeholder="e.g., your-cloud-name"
                    />
                     <p className="text-xs text-muted-foreground">This is public and stored in your site&apos;s manifest.</p>
                </div>
                 <div className="space-y-2">
                    <Label htmlFor="upload-preset">Cloudinary Upload Preset (Secret)</Label>
                        <Input
                        id="upload-preset"
                        type="password"
                        value={cloudinaryUploadPreset}
                        onChange={(e) => handleInputChange(setCloudinaryUploadPreset, e.target.value)}
                        placeholder="e.g., ml_default"
                    />
                     <p className="text-xs text-muted-foreground">This is a secret and is stored securely in your browser, not in your public site files.</p>
                </div>
            </div>
        )}
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Image Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/appearance/page.tsx
// src/app/sites/[siteId]/settings/appearance/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import AppearanceSettingsForm, { AppearanceFormRef } from '@/features/site-settings/components/AppearanceSettingsForm';
import { Button } from '@/core/components/ui/button';
import { Manifest, ThemeConfig, ThemeInfo } from '@/types';
import { useEffect, useState, useCallback, useMemo, useRef } from 'react';
import { toast } from "sonner";
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { getAvailableThemes } from '@/core/services/configHelpers.service';
import { getMergedThemeDataForForm } from '@/core/services/theme.service';
import { RJSFSchema } from '@rjsf/utils';

export default function AppearanceSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;
  const formRef = useRef<AppearanceFormRef>(null);

  const updateManifestAction = useAppStore(state => state.updateManifest);
  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));

  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);
  
  const [formSchema, setFormSchema] = useState<RJSFSchema | null>(null);
  const [initialConfigForForm, setInitialConfigForForm] = useState<ThemeConfig['config'] | null>(null);
  
  // This state tracks the theme selected in the dropdown UI.
  const [selectedThemeName, setSelectedThemeName] = useState<string | undefined>(undefined);

  const availableThemes = useMemo(() => getAvailableThemes(site?.manifest), [site?.manifest]);

  // Effect 1: Initialize the UI's selected theme from the saved manifest.
  useEffect(() => {
    if (site?.manifest.theme.name && !selectedThemeName) {
      setSelectedThemeName(site.manifest.theme.name);
    }
  }, [site?.manifest.theme.name, selectedThemeName]);

  // Effect 2: The main data-loading effect. It runs ONLY when the theme selection changes.
  // It does NOT depend on the `site` object, which was the source of the feedback loop.
  useEffect(() => {
    if (!selectedThemeName) return;

    setIsLoading(true);
    
    const savedThemeName = site?.manifest.theme.name;
    const userSavedConfig = site?.manifest.theme.config || {};
    
    const configToMerge = (selectedThemeName === savedThemeName) ? userSavedConfig : {};

    getMergedThemeDataForForm(selectedThemeName, configToMerge).then(({ schema, initialConfig }) => {
      setFormSchema(schema);
      setInitialConfigForForm(initialConfig);
      setIsLoading(false);
    });
  }, [selectedThemeName]); // Intentionally does NOT depend on `site`.

  const handleDirty = useCallback(() => {
    setHasChanges(true);
  }, []);

  const handleThemeChange = (newThemeName: string) => {
    if (newThemeName !== selectedThemeName) {
      setSelectedThemeName(newThemeName);
      setHasChanges(true);
    }
  };

  const handleSave = async () => {
    if (!site?.manifest || !formRef.current || !selectedThemeName) return;
    setIsLoading(true);
    
    const currentFormData = formRef.current.getFormData();
    
    const newManifest: Manifest = {
      ...site.manifest,
      theme: {
        name: selectedThemeName,
        config: currentFormData,
      },
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Appearance settings saved successfully!');
      setHasChanges(false);
    } catch(error) {
      toast.error(`Failed to save settings: ${(error as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading || !initialConfigForForm || !selectedThemeName) {
    return <div className="p-6 text-muted-foreground">Loading...</div>;
  }
  
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Appearance</h1>
        <p className="text-muted-foreground">Customize the visual style and branding of your site.</p>
      </div>
      <div className="border-t pt-6 space-y-6">
        <div>
          <Label htmlFor="theme-select">Active Theme</Label>
          <Select value={selectedThemeName} onValueChange={handleThemeChange}>
            <SelectTrigger id="theme-select" className="mt-1">
              <SelectValue placeholder="Select a theme..." />
            </SelectTrigger>
            <SelectContent>
              {availableThemes.map((theme: ThemeInfo) => (
                <SelectItem key={theme.path} value={theme.path}>
                  {theme.name}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        
        <AppearanceSettingsForm 
          // [THE FIX] By giving the component a `key`, React will destroy and
          // re-create it whenever the theme name changes, forcing it to
          // correctly re-initialize its state with the new theme's data.
          // This `key` does NOT change on save, so the component persists.
          key={selectedThemeName}
          ref={formRef}
          // These props are now only for initialization.
          initialConfig={initialConfigForForm}
          schema={formSchema}
          // Other props
          onDirty={handleDirty}
          themePath={selectedThemeName}
        />
      </div>
      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Appearance'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/layout.tsx
// src/app/sites/[siteId]/edit/layout.tsx
'use client';

import { ReactNode } from 'react';

/**
 * The root layout for the /edit section.
 * In this refactored architecture, this layout has a minimal role.
 * It primarily serves as a container for the editor pages.
 * The context providers and specific layouts are now handled by the
 * page components themselves for better encapsulation.
 */
export default function EditSiteLayout({ children }: { children: ReactNode }) {
  // This layout simply renders the page that Next.js passes to it.
  return <>{children}</>;
}

================================================================================

File: app/sites/[siteId]/edit/page.tsx
// src/app/sites/[siteId]/edit/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { toast } from 'sonner';

/**
 * A smart entry point for the site editor.
 *
 * This component's logic is now simplified:
 * 1. It waits for the site data to be fully loaded.
 * 2. If the site has pages, it finds the designated homepage (the first page)
 *    and redirects to its specific editor URL.
 * 3. If the site has NO pages, it redirects to the generic content editor URL,
 *    which will then display the "Create Your Homepage" prompt.
 */
export default function SiteEditorRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(state => state.getSiteById(siteId));
  const loadingSites = useAppStore(state => state.loadingSites);

  useEffect(() => {
    // Guard Clause 1: Wait for the siteId to be available.
    if (!siteId) return;

    // Guard Clause 2: Wait for the asynchronous data loading from storage to complete.
    // The `SiteLoaderLayout` triggers this load; we just wait for it to finish.
    if (loadingSites.has(siteId) || !site) {
      return;
    }
    
    let redirectPath: string;

    // Check if the site's structure array has any pages.
    if (site.manifest.structure.length > 0) {
      // The site has pages. The homepage is always the first one.
      const homepageNode = site.manifest.structure[0];
      
      if (homepageNode) {
        // Derive the editor slug from the homepage node's actual path.
        const editorSlug = homepageNode.path.replace(/^content\//, '').replace(/\.md$/, '');
        redirectPath = `/sites/${siteId}/edit/content/${editorSlug}`;
      } else {
        // This is an edge case for a corrupted manifest.
        toast.error("Error: Site has a structure but no valid homepage found.");
        redirectPath = `/sites/${siteId}/settings`;
      }
    } else {
      // The site has NO pages. Redirect to the generic content editor,
      // which will display the "Create Your Homepage" UI.
      redirectPath = `/sites/${siteId}/edit/content`;
    }

    // Use `replace` to avoid polluting browser history with this redirect page.
    router.replace(redirectPath);

  }, [site, siteId, router, loadingSites]);

  // Display a consistent loading message while waiting for the logic to run.
  return (
    <div className="p-6 flex justify-center items-center h-full">
      <p>Loading Editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
// src/app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
'use client';

import { useMemo, useEffect, useRef } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';
import { EditorProvider } from '@/features/editor/contexts/EditorContext';
import type { LocalSiteData } from '@/types';

// Component Imports
import { Button } from '@/core/components/ui/button';
import { FilePlus, LayoutGrid } from 'lucide-react';
import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import LeftSidebar from '@/features/editor/components/LeftSidebar';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
import CreateCollectionPageDialog from '@/features/editor/components/CreateCollectionPageDialog';
import BlocknoteEditor, { type BlocknoteEditorRef } from '@/features/editor/components/BlocknoteEditor';
import FrontmatterSidebar from '@/features/editor/components/FrontmatterSidebar';
import PrimaryContentFields from '@/features/editor/components/PrimaryContentFields';
import CollectionItemList from '@/features/editor/components/CollectionItemList';
import SaveButton from '@/features/editor/components/SaveButton';

// Modular Hooks
import { usePageIdentifier } from '@/features/editor/hooks/usePageIdentifier';
import { useFileContent } from '@/features/editor/hooks/useFileContent';
import { useFilePersistence } from '@/features/editor/hooks/useFilePersistence';

function EditContentPageInternal() {
  const editorRef = useRef<BlocknoteEditorRef>(null);

  // --- FIX: Use the new `activeSiteId` to get the correct site data ---
  const activeSiteId = useAppStore(state => state.activeSiteId);
  const site = useAppStore(state => activeSiteId ? state.getSiteById(activeSiteId) : undefined);
  
  const { siteId, isNewFileMode, filePath } = usePageIdentifier({ site });
  
  const { status, frontmatter, initialBlocks, slug, setSlug, handleFrontmatterChange, onContentModified } = useFileContent(siteId, filePath, isNewFileMode);
  const { handleDelete } = useFilePersistence({ siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent: () => editorRef.current?.getBlocks() ?? [] });
  const { leftSidebarContent, rightSidebarContent, setLeftAvailable, setRightAvailable, setLeftSidebarContent, setRightSidebarContent } = useUIStore(state => state.sidebar);

  const isCollectionPage = useMemo(() => !!frontmatter?.collection, [frontmatter]);

  const rightSidebarComponent = useMemo(() => {
    if (status !== 'ready' || !frontmatter || !site) return null;
    return <FrontmatterSidebar siteId={siteId} filePath={filePath} site={site as LocalSiteData} frontmatter={frontmatter} onFrontmatterChange={handleFrontmatterChange} isNewFileMode={isNewFileMode} slug={slug} onSlugChange={setSlug} onDelete={handleDelete} />;
  }, [status, site, frontmatter, siteId, filePath, isNewFileMode, slug, handleFrontmatterChange, setSlug, handleDelete]);

  useEffect(() => {
    setLeftAvailable(true);
    setLeftSidebarContent(<LeftSidebar />);
    return () => { setLeftAvailable(false); setLeftSidebarContent(null); };
  }, [setLeftAvailable, setLeftSidebarContent]);

  useEffect(() => {
    if (rightSidebarComponent) {
      setRightAvailable(true);
      setRightSidebarContent(rightSidebarComponent);
    } else {
      setRightAvailable(false);
      setRightSidebarContent(null);
    }
    return () => { setRightAvailable(false); setRightSidebarContent(null); };
  }, [rightSidebarComponent, setRightAvailable, setRightSidebarContent]);

  const isSiteEmpty = site && site.manifest.structure.length === 0 && !isNewFileMode;

  return (
    <ThreeColumnLayout
        leftSidebar={leftSidebarContent}
        rightSidebar={isSiteEmpty ? null : rightSidebarContent}
        headerActions={isSiteEmpty ? null : <SaveButton />}
    >
      {isSiteEmpty ? (
        <div className="flex flex-col items-center justify-center h-full text-center p-8 bg-background">
          <h2 className="text-2xl font-bold mb-2">Create Your Homepage</h2>
          <p className="text-muted-foreground mb-6 max-w-md">Your site is empty. The first page you create will become your site&apos;s permanent homepage.</p>
          <div className="flex gap-4">
            <NewPageDialog siteId={siteId}><Button size="lg"><FilePlus className="mr-2 h-5 w-5" /> Create Content Page</Button></NewPageDialog>
            <CreateCollectionPageDialog siteId={siteId}><Button size="lg" variant="outline"><LayoutGrid className="mr-2 h-5 w-5" /> Create Collection Page</Button></CreateCollectionPageDialog>
          </div>
        </div>
      ) : (
        (() => {
          if (status !== 'ready' || !frontmatter || !filePath) {
            return <div className="p-6 flex justify-center items-center h-full"><p>Loading Editor...</p></div>;
          }
          return (
            <div className='flex h-full w-full flex-col'>
              <div className='container mx-auto flex h-full max-w-[900px] flex-col p-6'>
                <div className="shrink-0"><PrimaryContentFields frontmatter={frontmatter} onFrontmatterChange={handleFrontmatterChange} /></div>
                <div className="mt-6 flex-grow min-h-0">
                  {isCollectionPage ? (
                    <CollectionItemList siteId={siteId} collectionPagePath={filePath} />
                  ) : (
                    <BlocknoteEditor ref={editorRef} key={filePath} initialContent={initialBlocks} onContentChange={onContentModified} />
                  )}
                </div>
              </div>
            </div>
          );
        })()
      )}
    </ThreeColumnLayout>
  );
}

export default function EditContentPage() {
    return (
        <EditorProvider>
            <EditContentPageInternal />
        </EditorProvider>
    );
}

================================================================================

File: app/sites/[siteId]/view/[[...slug]]/page.tsx
// src/app/sites/[siteId]/view/[[...slug]]/page.tsx
'use client';

import SitePreview from '@/features/viewer/components/SiteViewer';

export default function ViewSitePage() {
  // This page's only job is to render the master preview component.
  // The component itself will read the URL from the browser.
  return <SitePreview />;
}

================================================================================

File: app/create-site/page.tsx
// src/app/create-site/page.tsx
'use client';

import { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { LocalSiteData, Manifest, ThemeInfo } from '@/types';
import { Button } from '@/core/components/ui/button';
import { generateSiteId } from '@/lib/utils';
import { toast } from "sonner";
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { GENERATOR_VERSION, CORE_THEMES } from '@/config/editorConfig';
import { getMergedThemeDataForForm } from '@/core/services/theme.service';


/**
 * Renders the "Create New Site" page.
 * 
 * This component is responsible for gathering initial site details (title, theme)
 * and orchestrating the creation of a new site record.
 * 
 * RECENT REFACTOR: This component no longer contains logic for parsing theme defaults itself.
 * It now uses the centralized `synchronizeThemeDefaults` service to ensure that the new
 * site's manifest is created with a complete and valid theme configuration from the start.
 * This makes the component simpler and more aligned with the principle of separation of concerns.
 */
export default function CreateSitePage() {
  const router = useRouter();
  const addSite = useAppStore((state) => state.addSite);
  const [siteTitle, setSiteTitle] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const availableThemes = useMemo(() => CORE_THEMES, []);
  const [selectedTheme, setSelectedTheme] = useState<ThemeInfo | null>(availableThemes[0] || null);

  const handleSubmit = async () => {
    if (!siteTitle.trim() || !selectedTheme) {
      toast.error('Site title and a theme are required.');
      return;
    }
    setIsLoading(true);
    try {
      const newSiteId = generateSiteId(siteTitle);
      // [FIX] Use the hydrateTheme function as intended.
       const { initialConfig } = await getMergedThemeDataForForm(selectedTheme.path, {});
      
      const newManifest: Manifest = {
        siteId: newSiteId,
        generatorVersion: GENERATOR_VERSION,
        title: siteTitle.trim(),
        description: siteDescription.trim(),
        theme: {
          name: selectedTheme.path,
          config: initialConfig, // Use the fetched defaults as the initial config.
        },
        structure: [],
      };
      const newSiteData: LocalSiteData = {
        siteId: newSiteId,
        manifest: newManifest,
        contentFiles: [],
        themeFiles: [],
        layoutFiles: [],
      };
      await addSite(newSiteData);
      toast.success(`Site "${siteTitle}" created successfully!`);
      router.push(`/sites/${newSiteId}/edit`);
    } catch (error) {
      console.error("Error during site creation:", error);
      toast.error(`Failed to create site: ${(error as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-2xl">
      <div className="space-y-6">
        <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Create a New Site</h1>
            <Button onClick={() => router.push('/sites')} variant="outline">Cancel</Button>
        </div>

        <div className="space-y-4 p-6 border rounded-lg">
            <h2 className="text-lg font-semibold">Site Details</h2>
            <div>
                <Label htmlFor="site-title">Site Title</Label>
                <Input
                    id="site-title"
                    value={siteTitle}
                    onChange={(e) => setSiteTitle(e.target.value)}
                    placeholder="My Awesome Project"
                    required
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="site-description">Site Description (Optional)</Label>
                <Textarea
                    id="site-description"
                    value={siteDescription}
                    onChange={(e) => setSiteDescription(e.target.value)}
                    placeholder="A short and catchy description of your new site."
                    rows={3}
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="theme-select">Theme</Label>
                <Select 
                    value={selectedTheme?.path || ''} 
                    onValueChange={(themePath) => {
                        const theme = availableThemes.find(t => t.path === themePath);
                        if (theme) setSelectedTheme(theme);
                    }} 
                >
                    <SelectTrigger id="theme-select" className="mt-1">
                        <SelectValue placeholder="Select a theme..." />
                    </SelectTrigger>
                    <SelectContent>
                        {availableThemes.map(theme => (
                            <SelectItem key={theme.path} value={theme.path}>
                                {theme.name}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                 <p className="text-xs text-muted-foreground mt-1">
                    Choose the overall design for your site. You can change this later.
                </p>
            </div>
        </div>

        <div className="flex justify-end">
            <Button onClick={handleSubmit} disabled={isLoading || !siteTitle.trim() || !selectedTheme} size="lg">
                {isLoading ? 'Creating...' : 'Create Site'}
            </Button>
        </div>
      </div>
    </div>
  );
}

================================================================================

File: config/editorConfig.ts
// src/config/editorConfig.ts
import type { ThemeInfo, LayoutInfo } from '@/types';
import { RJSFSchema, UiSchema } from '@rjsf/utils'; 

/**
 * The official version of the Signum generator client.
 * This is written to the manifest.json on site creation and can be used
 * by the theme engine or other tools to check for compatibility.
 */
export const GENERATOR_VERSION = 'SignumClient/1.3.0';

/**
 * The URL segment used to identify a new, unsaved content file.
 * This allows the editor to distinguish between editing an existing file
 * and creating a new one.
 * e.g., /edit/site-id/content/blog/_new
 */
export const NEW_FILE_SLUG_MARKER = '_new';

/**
 * The delay in milliseconds for the autosave functionality in the content editor.
 * A longer delay reduces server/storage load but increases risk of data loss on close.
 * A shorter delay saves more often but can be more "chatty".
 */
export const AUTOSAVE_DELAY = 2500;

/**
 * The default layout path used for any new single page.
 * The system will fall back to this if a more specific layout isn't defined.
 * The path is relative to '/public/layouts/'.
 * e.g., 'page'
 */
export const DEFAULT_PAGE_LAYOUT_PATH = 'page';

/**
 * The default layout path used for any new collection.
 * This ensures that when a user creates a new collection, it has a sensible
 * default appearance without requiring an immediate decision.
 * The path is relative to '/public/layouts/'.
 * e.g., 'listing'
 */
export const DEFAULT_VIEW_LAYOUT_PATH = 'listing';

export const CORE_LAYOUTS: LayoutInfo[] = [
  // Page Layouts
  { id: 'page', name: 'Standard Page', type: 'page', path: 'page', description: "A clean, single-column page layout." },
  // Add other page layouts like 'post' here if they exist

  // List Layouts
  { id: 'listing', name: 'Vertical List', type: 'list', path: 'listing', description: "A standard, top-to-bottom list of items." },
  // Add other list layouts like 'grid' here if they exist

  // Item Layouts
  { id: 'teaser', name: 'Teaser Card', type: 'item', path: 'teaser', description: "A compact card with a title and summary." },
];

export const CORE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', path: 'default' },
];

/**
 * Default configuration for a new site's homepage (index.md).
 * Centralizes the initial title and content.
 */
export const DEFAULT_HOMEPAGE_CONFIG = {
  TITLE: 'Welcome to your new site!',
  /**
   * Generates the default markdown content for the homepage.
   * @param {string} siteTitle - The title of the site to include in the welcome message.
   * @returns {string} The formatted markdown string.
   */
  getContent: (siteTitle: string): string => 
    `## Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`
};

/**
 * The universal base schema for all content frontmatter.
 * This object is imported directly, eliminating network requests.
 * Fields like 'title' and 'description' are not included here because they
 * are handled by dedicated UI components, not the generic form generator.
 */
export const BASE_SCHEMA: { schema: RJSFSchema; uiSchema: UiSchema } = {
  schema: {
    title: 'Base content fields',
    type: 'object',
    properties: {
      slug: {
        type: 'string',
        title: 'Slug (URL Path)',
        description: 'The URL-friendly version of the title. Auto-generated, but can be edited.',
      },
      image: {
        type: 'string',
        title: 'Image',
        description: 'URL or path to a featured image for this content.',
      },
      date: {
        type: 'string',
        title: 'Publication date',
        format: 'date',
      },
      status: {
        type: 'string',
        title: 'Status',
        enum: ['published', 'draft'],
        default: 'draft',
      },
      author: {
        type: 'string',
        title: 'Author',
      },
      tags: {
        type: 'array',
        title: 'Tags',
        items: {
          type: 'string',
        },
      },
    },
  },
  uiSchema: {
    slug: {
      'ui:widget': 'hidden',
    },
    tags: {
      'ui:options': {
        addable: true,
        removable: true,
      },
    },
  },
};

================================================================================

File: features/viewer/components/SiteViewer.tsx
// src/components/view/SiteViewer.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useEffect, useState, useCallback } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { resolvePageContent } from '@/core/services/pageResolver.service';
import { PageType } from '@/types';import { render as renderWithTheme } from '@/core/services/theme-engine/themeEngine.service';
import { AlertTriangle, Edit } from 'lucide-react';
import { Button } from '@/core/components/ui/button';
import Link from 'next/link';

/**
 * Renders a live, interactive preview of a Signum site within an iframe.
 * This component acts as a mini-SPA, controlling the browser's URL history
 * to allow for deep linking and back/forward button navigation within the preview.
 */
export default function SiteViewer() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;
  const viewRootPath = `/sites/${siteId}/view`;

  const [currentRelativePath, setCurrentRelativePath] = useState(
    pathname.replace(viewRootPath, '') || '/'
  );
  const [htmlContent, setHtmlContent] = useState<string>('<p>Loading Preview...</p>');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const site = useAppStore((state) => state.getSiteById(siteId));

  const sandboxAttributes = 
    process.env.NODE_ENV === 'development'
      ? 'allow-scripts allow-forms allow-same-origin'
      : 'allow-scripts allow-forms';


  const updateIframeContent = useCallback(async () => {
    if (!site) return;

    // This ensures we don't try to render before the site's content is loaded.
    if (!site.contentFiles) {
        console.log("SiteViewer is waiting for content files to load...");
        return;
    }

    const slugArray = currentRelativePath.split('/').filter(Boolean);
    const resolution = resolvePageContent(site, slugArray);
    
    if (resolution.type === PageType.NotFound) {
      setErrorMessage(resolution.errorMessage);
      return;
    }

    try {
      const pureHtml = await renderWithTheme(site, resolution, {
        siteRootPath: viewRootPath,
        isExport: false,
      });

      // --- START: NEW ROBUST COMMUNICATION SCRIPT ---
      const parentOrigin = typeof window !== 'undefined' ? window.location.origin : '';

      const communicationScript = `
        <script>
          // The parent component injects its own origin here. This is the key.
          const PARENT_ORIGIN = '${parentOrigin}'; 

          document.addEventListener('click', function(e) {
            const link = e.target.closest('a');

            // 1. If it's not a link, do nothing.
            if (!link || !link.href) return;
            
            // 2. If it's an in-page anchor link, let the browser handle it.
            if (link.hash && link.pathname === window.location.pathname) return;

            // 3. This is the crucial check: Does the link point to the same origin
            //    as the parent application? This works in ANY sandbox mode.
            if (link.origin === PARENT_ORIGIN) {
              e.preventDefault();
              const newPath = new URL(link.href).pathname;
              // Post the message back to the parent, specifying its own origin for security.
              window.parent.postMessage({ type: 'SIGNUM_NAVIGATE', path: newPath }, PARENT_ORIGIN);
            }
            // 4. If it's an external link (e.g., to google.com), the condition fails
            //    and the browser handles it normally (opening in a new tab if target="_blank").
          });
        <\/script>
      `;
      // --- END: NEW ROBUST COMMUNICATION SCRIPT ---

      const finalHtml = pureHtml.replace('</body>', `${communicationScript}</body>`);
      setHtmlContent(finalHtml);
      setErrorMessage(null);
    } catch (e) {
      const error = e as Error;
      console.error("Error during site rendering:", error);
      setErrorMessage(`Theme Error: ${error.message}`);
    }
  }, [site, viewRootPath, currentRelativePath]);

  // Re-render the iframe whenever the path or the site data itself changes.
  useEffect(() => {
    updateIframeContent();
  }, [updateIframeContent]);

  // This effect manages the browser history and remains unchanged.
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // Security: Only accept messages from our own origin.
      if (event.origin !== window.location.origin) return;
      
      const { type, path } = event.data;
      if (type === 'SIGNUM_NAVIGATE' && path !== window.location.pathname) {
        history.pushState({ path }, '', path);
        setCurrentRelativePath(path.replace(viewRootPath, '') || '/');
      }
    };

    const handlePopState = (event: PopStateEvent) => {
        const newPath = event.state?.path || pathname;
        setCurrentRelativePath(newPath.replace(viewRootPath, '') || '/');
    };

    window.addEventListener('message', handleMessage);
    window.addEventListener('popstate', handlePopState);

    return () => {
      window.removeEventListener('message', handleMessage);
      window.removeEventListener('popstate', handlePopState);
    };
  }, [viewRootPath, pathname]);

  if (errorMessage) {
    return (
      <div className="p-8 text-center">
        <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
        <h1 className="text-2xl font-bold mb-2">Could Not Render Preview</h1>
        <p className="text-muted-foreground">{errorMessage}</p>
        <Button asChild variant="default" className="mt-6">
          <Link href={`/sites/${siteId}/edit`}>
            <Edit className="mr-2 h-4 w-4" /> Go to Editor
          </Link>
        </Button>
      </div>
    );
  }

  return (
    <iframe
      srcDoc={htmlContent}
      title={site?.manifest.title || 'Site Preview'}
      className="w-full h-full border-0"
      sandbox={sandboxAttributes}
    />
  );
}

================================================================================

File: features/viewer/components/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; 

import { marked } from 'marked';
import { useMemo } from 'react';
import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {

    }
    const rawHtml = marked.parse(markdown) as string;
    if (typeof window !== 'undefined') { 
    return DOMPurify.sanitize(rawHtml);
     }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Signum, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: features/site-settings/components/AppearanceSettingsForm.tsx
// src/features/site-settings/components/AppearanceSettingsForm.tsx
'use client';

import { RJSFSchema } from '@rjsf/utils';
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';
import { ThemeConfig } from '@/types';
// useEffect is no longer needed and is removed.
import { useState, forwardRef, useImperativeHandle } from 'react';

interface AppearanceSettingsFormProps {
  // These props are passed by the parent to initialize the form.
  schema: RJSFSchema | null;
  initialConfig: ThemeConfig['config'];
  onDirty: () => void;
  themePath: string; // Keep for display purposes
}

export interface AppearanceFormRef {
  getFormData: () => ThemeConfig['config'];
}

const AppearanceSettingsForm = forwardRef<AppearanceFormRef, AppearanceSettingsFormProps>(({ 
  schema, 
  initialConfig, 
  onDirty,
  themePath
}, ref) => {

  // The form's state is initialized ONCE from the initialConfig prop when the
  // component mounts. It will NOT be updated by parent re-renders.
  const [formData, setFormData] = useState(initialConfig);

  // The problematic useEffect hook has been removed entirely.

  useImperativeHandle(ref, () => ({
    getFormData: () => formData,
  }));

  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    setFormData(event.formData as ThemeConfig['config'] || {});
    onDirty();
  };

  if (!schema) {
    return (
      <div className="text-center border-2 border-dashed p-6 rounded-lg">
        <p className="font-semibold">No Appearance Options</p>
        <p className="text-sm text-muted-foreground">The current theme "{themePath}" does not provide any customizable settings.</p>
      </div>
    );
  }

  return (
    <SchemaDrivenForm
      schema={schema}
      formData={formData}
      onFormChange={handleChange}
    />
  );
});

AppearanceSettingsForm.displayName = 'AppearanceSettingsForm';
export default AppearanceSettingsForm;

================================================================================

File: features/site-settings/components/SiteSettingsForm.tsx
// src/features/site-settings/components/SiteSettingsForm.tsx
'use client';

import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { ImageRef } from '@/types';
import SiteAssetUploader from './SiteAssetsUploader';

interface SiteSettingsFormProps {
  siteId: string;
  formData: {
    title: string;
    description: string;
    author: string;
    baseUrl: string;
    logo: ImageRef | undefined;
    favicon: ImageRef | undefined;
  };
  onFormChange: (newData: SiteSettingsFormProps['formData']) => void;
}

export default function SiteSettingsForm({ siteId, formData, onFormChange }: SiteSettingsFormProps) {
  
  // FIX: Typed the 'value' parameter to 'unknown' for better type safety.
  const handleChange = (field: keyof typeof formData, value: unknown) => {
    onFormChange({ ...formData, [field]: value });
  };

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <h2 className="text-lg font-semibold">Site Identity</h2>
        <SiteAssetUploader 
          siteId={siteId}
          label="Site Logo"
          value={formData.logo}
          onChange={(newRef) => handleChange('logo', newRef)}
          onRemove={() => handleChange('logo', undefined)}
        />
        <SiteAssetUploader
          siteId={siteId}
          label="Favicon"
          value={formData.favicon}
          onChange={(newRef) => handleChange('favicon', newRef)}
          onRemove={() => handleChange('favicon', undefined)}
        />
      </div>

      <div className="border-t pt-6 space-y-4">
        <h2 className="text-lg font-semibold">Core Details</h2>
        <div className="space-y-2">
            <Label htmlFor="title">Site Title</Label>
            <Input
                id="title"
                value={formData.title}
                onChange={(e) => handleChange('title', e.target.value)}
                placeholder="My Awesome Site"
            />
        </div>
        <div className="space-y-2">
            <Label htmlFor="description">Site Description</Label>
            <Textarea
                id="description"
                value={formData.description}
                onChange={(e) => handleChange('description', e.target.value)}
                placeholder="A short, catchy description."
                rows={3}
            />
        </div>
        <div className="space-y-2">
            <Label htmlFor="author">Author (Optional)</Label>
            <Input
                id="author"
                value={formData.author}
                onChange={(e) => handleChange('author', e.target.value)}
                placeholder="Your Name or Organization"
            />
        </div>
        <div className="space-y-2">
            <Label htmlFor="baseUrl">Base URL</Label>
            <Input
                id="baseUrl"
                type="url"
                value={formData.baseUrl}
                onChange={(e) => handleChange('baseUrl', e.target.value)}
                placeholder="https://www.my-awesome-site.com"
            />
        </div>
      </div>
    </div>
  );
}

================================================================================

File: features/site-settings/components/SiteAssetsUploader.tsx
// src/features/site-settings/components/SiteAssetsUploader.tsx
'use client';

import { useEffect, useState } from 'react';
import Image from 'next/image'; // FIX: Import the optimized Next.js Image component
import { ImageRef } from '@/types';
import { useAppStore } from '@/core/state/useAppStore';
import { getActiveImageService } from '@/core/services/images/images.service';
import { Button } from '@/core/components/ui/button';
import { UploadCloud, XCircle } from 'lucide-react';
import { toast } from 'sonner';

interface SiteAssetUploaderProps {
  siteId: string;
  label: string;
  value: ImageRef | undefined;
  onChange: (newRef: ImageRef) => void;
  onRemove: () => void;
}

export default function SiteAssetUploader({ siteId, label, value, onChange, onRemove }: SiteAssetUploaderProps) {
  const site = useAppStore(state => state.getSiteById(siteId));
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);

  useEffect(() => {
    let objectUrl: string | null = null;
    const generatePreview = async () => {
      if (value && site?.manifest) {
        try {
          const service = getActiveImageService(site.manifest);
          const url = await service.getDisplayUrl(site.manifest, value, { width: 128, height: 128, crop: 'fit' }, false);
          setPreviewUrl(url);
          // Only store blob URLs for later revocation to prevent memory leaks
          if (url.startsWith('blob:')) {
            objectUrl = url;
          }
        } catch (error) {
          console.error(`Could not generate preview for ${label}:`, error);
          setPreviewUrl(null);
        }
      } else {
        setPreviewUrl(null);
      }
    };
    generatePreview();
    
    return () => {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    };
  }, [value, site, label]);

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !site?.manifest) return;
    
    setIsUploading(true);
    try {
      const service = getActiveImageService(site.manifest);
      const newRef = await service.upload(file, siteId);
      onChange(newRef);
      toast.success(`${label} uploaded successfully.`);
    } catch (error) {
      toast.error(`Failed to upload ${label}: ${(error as Error).message}`);
    } finally {
      setIsUploading(false);
      event.target.value = '';
    }
  };

  const inputId = `uploader-${label.toLowerCase().replace(/\s/g, '-')}`;

  return (
    <div className="flex items-center gap-4">
      <div className="w-16 h-16 bg-muted rounded-md flex items-center justify-center overflow-hidden flex-shrink-0 relative">
        {previewUrl ? (
          // FIX: Replaced `<img>` with the optimized <Image /> component
          <Image src={previewUrl} alt={`${label} preview`} fill className="object-contain" />
        ) : (
          <UploadCloud className="w-8 h-8 text-muted-foreground" />
        )}
      </div>
      <div className="flex-grow">
        <label htmlFor={inputId} className="font-medium text-sm">{label}</label>
        <div className="flex items-center gap-2 mt-1">
          <Button asChild size="sm" variant="outline" disabled={isUploading}>
            <label htmlFor={inputId}>
              {isUploading ? 'Uploading...' : (value ? 'Change...' : 'Upload...')}
            </label>
          </Button>
          <input type="file" id={inputId} className="hidden" onChange={handleFileSelect} accept="image/png, image/jpeg, image/svg+xml, image/x-icon" />
          {value && (
            <Button size="sm" variant="ghost" className="text-destructive" onClick={onRemove}>
              <XCircle className="w-4 h-4 mr-1" />
              Remove
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

================================================================================

File: features/site-settings/components/SettingsNav.tsx
'use-client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbUserCircle, TbPalette, TbPhoto } from 'react-icons/tb';
import { cn } from '@/lib/utils';

// This is the navigation component for the settings area.
export default function SettingsNav() {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const navItems = [
    { href: `/sites/${siteId}/settings`, title: 'Site Details', icon: TbUserCircle },
    { href: `/sites/${siteId}/settings/appearance`, title: 'Appearance', icon: TbPalette },
    { href: `/sites/${siteId}/settings/images`, title: 'Images', icon: TbPhoto },
    // Add more settings links here as needed
  ];

  return (
    <div className="flex h-full flex-col p-4">
      <h2 className="px-2 text-lg font-semibold tracking-tight">Settings</h2>
      <nav className="mt-4 flex flex-col gap-1">
        {navItems.map((item) => (
          <Link
            key={item.href}
            href={item.href}
            className={cn(
              'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
              pathname === item.href
                ? 'bg-primary text-primary-foreground'
                : 'text-muted-foreground hover:bg-muted/50 hover:text-foreground'
            )}
          >
            <item.icon className="h-5 w-5" />
            {item.title}
          </Link>
        ))}
      </nav>
    </div>
  );
}

================================================================================

File: features/editor/contexts/EditorContext.tsx
// src/contexts/EditorContext.tsx
'use client';
import { toast } from 'sonner';

import { createContext, useContext, useState, ReactNode, useMemo, useRef, useCallback } from 'react';

export type SaveState = 'idle' | 'saving' | 'saved' | 'no_changes';

interface EditorContextType {
  saveState: SaveState;
  setSaveState: (state: SaveState) => void;
  hasUnsavedChanges: boolean;
  setHasUnsavedChanges: (hasChanges: boolean) => void;
  triggerSave: () => Promise<void>;
  registerSaveAction: (saveFn: () => Promise<void>) => void;
}

export const EditorContext = createContext<EditorContextType | undefined>(undefined);

interface EditorProviderProps {
  children: ReactNode;
}

export function EditorProvider({ children }: EditorProviderProps) {
  const [saveState, setSaveState] = useState<SaveState>('no_changes');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const saveActionRef = useRef<(() => Promise<void>) | null>(null);

  const registerSaveAction = useCallback((saveFn: () => Promise<void>) => {
    saveActionRef.current = saveFn;
  }, []);

  const triggerSave = useCallback(async () => {
    if (saveActionRef.current) {
      setSaveState('saving');
      try {
        await saveActionRef.current();
        setSaveState('saved');
        setHasUnsavedChanges(false);
        setTimeout(() => setSaveState('no_changes'), 2000);
      } catch (error) {
        console.error("Save failed:", error);
        toast.error((error as Error).message || "Failed to save.");
        setSaveState('idle');
      }
    }
  }, []);

  const contextValue = useMemo(() => ({
    saveState,
    setSaveState,
    hasUnsavedChanges, 
    setHasUnsavedChanges, 
    triggerSave,
    registerSaveAction,
    // FIX: Add missing dependencies for correctness
  }), [saveState, hasUnsavedChanges, registerSaveAction, triggerSave, setSaveState, setHasUnsavedChanges]);

  return (
    <EditorContext.Provider value={contextValue}>
      {children}
    </EditorContext.Provider>
  );
}

export function useEditor() {
  const context = useContext(EditorContext);
  if (context === undefined) {
    throw new Error('useEditor must be used within an EditorProvider');
  }
  return context;
}

================================================================================

File: features/editor/components/EditorHeader.tsx
// src/features/editor/components/EditorHeader.tsx
'use client';

import { ReactNode, useState } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { toast } from 'sonner';
import { exportSiteToZip } from '@/core/services/siteExporter.service';
import { slugify } from '@/lib/utils';
import { Eye, PanelLeft, UploadCloud, PanelRight } from 'lucide-react';

/**
 * Props for the generic EditorHeader component.
 */
interface EditorHeaderProps {
  /**
   * An optional React node containing action buttons or other components
   * to be displayed in the header. This allows for context-specific actions.
   */
  actions?: ReactNode;
}

export default function EditorHeader({ actions }: EditorHeaderProps) {
  const params = useParams();
  const siteId = params.siteId as string;
  const [isPublishing, setIsPublishing] = useState(false);

  // Get site and UI state from the global stores
  const site = useAppStore((state) => state.getSiteById(siteId));
  const { toggleLeftSidebar, toggleRightSidebar, isLeftAvailable, isRightAvailable } = useUIStore((state) => state.sidebar);

  const handlePublishSite = async () => {
    if (!site) {
      toast.error("Site data not found. Cannot publish.");
      return;
    }
    setIsPublishing(true);
    toast.info("Generating site bundle for download...");
    try {
      const blob = await exportSiteToZip(site);
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${slugify(site.manifest.title || 'signum-site')}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      toast.success("Site bundle downloaded!");
    } catch (error) {
      console.error("Error publishing site to Zip:", error);
      toast.error(`Failed to generate Zip: ${(error as Error).message}`);
    } finally {
      setIsPublishing(false);
    }
  };
  
  // Render a placeholder header if site data isn't loaded yet
  if (!site) {
    return (
        <header className="sticky top-0 z-20 flex h-[60px] items-center gap-4 border-b bg-background px-4 lg:h-[60px]"></header>
    );
  }

  return (
    <header className="sticky top-0 z-20 flex shrink-0 items-center gap-4 border-b bg-background lg:pl-4 pr-4 h-[60px]">
      <div className="flex items-center gap-2">
        <Link
            href="/sites"
            title="Dashboard"
            className='flex lg:hidden flex-col w-[60px] h-[60px] items-center border-r mr-2'
          >
            <Image src="/signum.svg" width={34} height={34} alt="Signum Logo" className='m-auto'/>
        </Link>
        {isLeftAvailable && (
            <Button 
                variant="outline" 
                size="icon" 
                className="shrink-0" 
                onClick={toggleLeftSidebar}
                aria-label="Toggle file tree"
            >
                <PanelLeft className="h-5 w-5" />
            </Button>
        )}
      </div>

      <div className="flex-1 text-lg text-muted-foreground truncate">
       <span className="font-bold text-foreground">{site.manifest.title}</span>
      </div>
      
      <div className="flex items-center justify-end gap-2">
        {/* Render the custom actions passed via props. This is where the SaveButton will appear on the editor page. */}
        {actions}

        <Button variant="outline" asChild>
            <Link href={`/sites/${siteId}/view`} target="_blank">
                <Eye className="h-4 w-4" />
                <span className='hidden md:block '>View</span>
            </Link>
        </Button>
        <Button variant="default" onClick={handlePublishSite} disabled={isPublishing}>
            <UploadCloud className="h-4 w-4" /> 
            <span className='hidden md:block '>{isPublishing ? 'Publishing...' : 'Publish'}</span>
        </Button>

        {isRightAvailable && (
            <Button 
                variant="outline" 
                size="icon" 
                className="shrink-0" 
                onClick={toggleRightSidebar}
                aria-label="Toggle settings sidebar"
            >
                <PanelRight className="h-5 w-5" />
            </Button>
        )}
      </div>
    </header>
  );
}

================================================================================

File: features/editor/components/ImageUploadWidget.tsx
// src/features/editor/components/ImageUploadWidget.tsx
'use client';

import { useState } from 'react';
import Image from 'next/image'; // FIX: Import the optimized Image component
import { useAppStore } from '@/core/state/useAppStore';
import { getActiveImageService } from '@/core/services/images/images.service';
import { ImageRef } from '@/types';
import { Button } from '@/core/components/ui/button';

interface ImageUploadWidgetProps {
  siteId: string;
  value: string;
  onImageSelect: (imageRef: ImageRef) => void;
}

export default function ImageUploadWidget({ siteId, value, onImageSelect }: ImageUploadWidgetProps) {
  const site = useAppStore(state => state.getSiteById(siteId));
  const [isLoading, setIsLoading] = useState(false);

  const handleUploadClick = async (event: React.ChangeEvent<HTMLInputElement>) => {
    if (!event.target.files || !site) return;
    const file = event.target.files[0];
    
    setIsLoading(true);
    try {
      const imageService = getActiveImageService(site.manifest);
      const imageRef = await imageService.upload(file, siteId);
      onImageSelect(imageRef);
    } catch (error) {
      console.error("Image upload failed:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      {value && <Image src={value} alt="Current image" width={200} height={150} className="w-full h-auto rounded-md mb-2 object-cover" />}
      <input
        type="file"
        id="image-upload"
        className="hidden"
        onChange={handleUploadClick}
        accept="image/*"
      />
      <Button asChild>
        <label htmlFor="image-upload">{value ? 'Change Image' : 'Upload Image'}</label>
      </Button>
      {isLoading && <p>Uploading...</p>}
    </div>
  );
}

================================================================================

File: features/editor/components/PrimaryContentFields.tsx
// src/components/publishing/PrimaryContentFields.tsx
'use client';

import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { Label } from '@/core/components/ui/label';
import { MarkdownFrontmatter } from '@/types';

// FIXED: The interface is now much stricter and safer.
// It only defines the properties this component actually cares about.
interface PrimaryFieldsProps {
  frontmatter: {
    title?: string;
    description?: string;
  };
  // The callback expects a partial update to the main frontmatter state.
  onFrontmatterChange: (newData: Partial<MarkdownFrontmatter>) => void;
  showDescription?: boolean;
}

export default function PrimaryContentFields({
  frontmatter,
  onFrontmatterChange,
}: PrimaryFieldsProps) {

  // FIXED: The handler now only passes back the single field that changed.
  // This makes the component more reusable and decoupled from the parent's state shape.
  const handleChange = (field: 'title' | 'description', value: string) => {
    onFrontmatterChange({
      [field]: value,
    });
  };

  return (
    <div className="space-y-4 shrink-0">
      <div className="space-y-2 mb-6 border-b pb-3">
        <Label htmlFor="content-title" className="text-[10px] font-medium uppercase text-gray-400">
          Title
        </Label>
        <Input
          id="content-title"
          placeholder="Enter a title..."
          value={frontmatter.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          // These classes create the large, "invisible" input style
          className="text-2xl lg:text-3xl font-bold h-auto p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent"
        />
      </div>

        <div className="space-y-2 mb-6 border-b pb-3">
          <Label htmlFor="content-description" className="text-[10px] font-medium uppercase text-gray-400">
            Description
          </Label>
          <Textarea
            
            placeholder="Add a short description..."
            value={frontmatter.description || ''}
            onChange={(e) => handleChange('description', e.target.value)}
            // Style for a clean, borderless textarea
            className="p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent resize-none text-2xl text-black"
            rows={1}
          />
        </div>
    </div>
  );
}

================================================================================

File: features/editor/components/NewPageDialog.tsx
// src/features/editor/components/NewPageDialog.tsx
'use client';

import { useState, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// --- UI & Type Imports ---
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface NewPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function NewPageDialog({ siteId, children, onComplete }: NewPageDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [title, setTitle] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setTitle('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleCreatePage = async () => {
    if (!title.trim()) {
      toast.error("Page title cannot be empty.");
      return;
    }
    setIsSubmitting(true);
    const slug = slugify(title);
    const filePath = `content/${slug}.md`;

    const slugExists = site?.contentFiles?.some(f => f.slug === slug);
    if (slugExists) {
        toast.error(`A page with the slug "${slug}" already exists.`);
        setIsSubmitting(false);
        return;
    }
    
    const frontmatter: MarkdownFrontmatter = {
        title: title.trim(),
        layout: DEFAULT_PAGE_LAYOUT_PATH,
        date: new Date().toISOString().split('T')[0],
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\nStart writing your content here.\n`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);      if (success) {
        toast.success(`Page "${title}" created!`);
        handleOpenChange(false);
        onComplete?.();
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else { throw new Error("Failed to update manifest or save file."); }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New Content Page</DialogTitle>
          <DialogDescription>
            Give your new page a title. You can add content and change settings later.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="space-y-1">
            <Label htmlFor="title">Page Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., About Us" />
          </div>
        </div>
        <DialogFooter>
          <DialogClose asChild><Button variant="outline">Cancel</Button></DialogClose>
          <Button type="button" onClick={handleCreatePage} disabled={!title.trim() || isSubmitting}>
            {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Page</>}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/CollectionSettings.tsx
// src/features/editor/components/CollectionSettings.tsx
'use client';

import { useEffect, useState, useCallback } from 'react';
import { MarkdownFrontmatter, CollectionConfig } from '@/types';
import { getAvailableLayouts, LayoutManifest } from '@/core/services/configHelpers.service';
import { useAppStore } from '@/core/state/useAppStore';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';

interface ViewEditorProps {
  siteId: string;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;
}

export default function ViewEditor({ siteId, frontmatter, onFrontmatterChange }: ViewEditorProps) {
  const site = useAppStore(state => state.getSiteById(siteId));

  // State for the dropdown options
  const [itemLayouts, setItemLayouts] = useState<LayoutManifest[]>([]);
  const [pageLayouts, setPageLayouts] = useState<LayoutManifest[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Fetch available layouts when the component mounts
  useEffect(() => {
    async function fetchData() {
      if (!site) return;
      setIsLoading(true);
      const allLayouts = await getAvailableLayouts(site);
      // Filter layouts by their new, specific types
      setItemLayouts(allLayouts.filter(l => l.layoutType === 'item'));
      setPageLayouts(allLayouts.filter(l => l.layoutType === 'page'));
      setIsLoading(false);
    }
    fetchData();
  }, [site]);

  // A generic handler to update a specific property within the 'collection' object
  const handleCollectionConfigChange = useCallback((key: keyof CollectionConfig, value: string | number) => {
    // We update the entire 'collection' object in the parent's frontmatter state
    const updatedCollectionConfig = { ...(frontmatter.collection!), [key]: value };
    onFrontmatterChange({
      collection: updatedCollectionConfig
    });
  }, [frontmatter.collection, onFrontmatterChange]);

  const collectionConfig = frontmatter.collection;

  if (isLoading) return <div className="p-6">Loading collection settings...</div>;

  // This component should not render if the page isn't a collection page.
  if (!collectionConfig) {
      return (
           <div className="p-6 text-center text-destructive-foreground bg-destructive/20 border border-destructive rounded-lg">
              <h3 className="font-semibold">Not a Collection Page</h3>
              <p className="text-sm">To enable collection settings, add a `collection` block to this page&apos;s frontmatter.</p>
          </div>
      );
  }

  return (
    <div className="space-y-6">
             <h4 className='font-bold'>Collection layouts</h4>

      <p className="text-sm text-muted-foreground -mt-4">
        Configure how the list of child pages is displayed on this page.
      </p>

      {/* --- Layout Selection --- */}
      <div className="gap-4">
       
        <div className="space-y-2">
  <Label htmlFor="item-layout">Item layout (in list)</Label>
  <div className="w-full">
    <Select value={collectionConfig.item_layout} onValueChange={(v) => handleCollectionConfigChange('item_layout', v)}>
      <SelectTrigger id="item-layout" className="!w-full">
        <SelectValue placeholder="Select..." />
      </SelectTrigger>
      <SelectContent>
        {itemLayouts.map(l => <SelectItem key={l.id} value={l.id}>{l.name}</SelectItem>)}
      </SelectContent>
    </Select>
  </div>
  <p className="text-xs text-muted-foreground">Appearance of each item teaser.</p>
</div>
      </div>
      <div className="space-y-2">
        <Label htmlFor="item-page-layout">Full page layout (for items)</Label>
        <Select value={collectionConfig.item_page_layout} onValueChange={(v) => handleCollectionConfigChange('item_page_layout', v)}>
            <SelectTrigger id="item-page-layout" className='!w-full'><SelectValue placeholder="Select..." /></SelectTrigger>
            <SelectContent>{pageLayouts.map(l => <SelectItem key={l.id} value={l.id}>{l.name}</SelectItem>)}</SelectContent>
        </Select>
         <p className="text-xs text-muted-foreground">The default layout when a user clicks to view a single item from this collection.</p>
      </div>

      {/* --- Sorting & Pagination --- */}
       <h4 className='font-bold'>Sorting & pagination</h4>
              <div className="flex flex-col gap-4">
                  <div className="space-y-2">
                      <Label htmlFor="sort-by">Sort items by</Label>
                      <Select value={collectionConfig.sort_by} onValueChange={(v) => handleCollectionConfigChange('sort_by', v)}>
                        <SelectTrigger id="sort-by" className='!w-full'><SelectValue placeholder="Select..." /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="date">Date</SelectItem>
                            <SelectItem value="title">Title</SelectItem>
                        </SelectContent>
                      </Select>
                  </div>
                  <div className="space-y-2">
                      <Label htmlFor="sort-order">Sort order</Label>
                       <Select value={collectionConfig.sort_order} onValueChange={(v) => handleCollectionConfigChange('sort_order', v)}>
                        <SelectTrigger id="sort-order"  className='!w-full'><SelectValue placeholder="Select..." /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="desc">Descending</SelectItem>
                            <SelectItem value="asc">Ascending</SelectItem>
                        </SelectContent>
                      </Select>
                  </div>
                   <div className="space-y-2">
                        <Label htmlFor="items-per-page">Items Per Page</Label>
                        <Input
                            id="items-per-page"
                            type="number"
                            value={collectionConfig.items_per_page || 10}
                            onChange={(e) => handleCollectionConfigChange('items_per_page', parseInt(e.target.value, 10) || 10)}
                            className="w-full block"
                        />
                    </div>
                    </div>
           
    </div>
  );
}

================================================================================

File: features/editor/components/FileTree.tsx
// src/features/editor/components/FileTree.tsx
'use client';

import React from 'react';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import FileTreeNode from './FileTreeNode';
import type { FlattenedNode } from '@/core/services/fileTree.service';

/**
 * Defines the shape of the visual drop indicator state, passed from the parent.
 */
interface DndProjection {
  parentId: string | null;
  depth: number;
  index: number;
}

/**
 * Defines the props accepted by the FileTree component.
 * It now receives a pre-filtered list of items to render, and a separate
 * list of IDs that are valid sortable targets.
 */
interface FileTreeProps {
  itemsToRender: FlattenedNode[];
  sortableIds: string[];
  activeId: string | null;
  projected: DndProjection | null;
  baseEditPath: string;
  activePath: string | undefined;
  homepagePath: string | undefined;
  onCollapse: (id: string) => void;
}

/**
 * Renders the sortable list of pages.
 * This component is now a "dumb" presenter; all filtering and state management
 * is handled by its parent (LeftSidebar).
 */
export default function FileTree({
  itemsToRender,
  sortableIds,
  activeId,
  projected,
  baseEditPath,
  activePath,
  homepagePath,
  onCollapse,
}: FileTreeProps) {
  return (
    // The SortableContext is given only the IDs of items that can be dragged.
    // The homepage ID is excluded by the parent component.
    <SortableContext items={sortableIds} strategy={verticalListSortingStrategy}>
      <ul className="space-y-0.5">
        {/* It maps over the pre-filtered list of items to render each node. */}
        {itemsToRender.map((item) => (
          <FileTreeNode
            key={item.path}
            item={item}
            activeId={activeId}
            projected={projected}
            baseEditPath={baseEditPath}
            activePath={activePath}
            homepagePath={homepagePath}
            onCollapse={onCollapse}
          />
        ))}
      </ul>
    </SortableContext>
  );
}

================================================================================

File: features/editor/components/FileTreeNode.tsx
// src/features/editor/components/FileTreeNode.tsx
'use client';

import React from 'react';
import Link from 'next/link';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { GripVertical, ChevronRight, File as FileIcon, LayoutGrid, Home } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { FlattenedNode } from '@/core/services/fileTree.service';
import type { MarkdownFrontmatter } from '@/types';

/**
 * Defines the shape of the visual drop indicator state.
 */
interface DndProjection {
  parentId: string | null;
  depth: number;
  index: number;
}

interface FileTreeNodeProps {
  item: FlattenedNode;
  isClone?: boolean;
  // --- Props for UI state ---
  activeId: string | null;
  projected: DndProjection | null;
  baseEditPath: string;
  activePath: string | undefined;
  homepagePath: string | undefined;
  onCollapse: (id: string) => void;
}

/**
 * Renders a single item in the file tree. It handles displaying the correct icon,
 * indentation, collapse state, and drag-and-drop visual feedback.
 */
export default function FileTreeNode({
  item,
  isClone,
  activeId,
  projected,
  baseEditPath,
  activePath,
  homepagePath,
  onCollapse,
}: FileTreeNodeProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: item.path,
    // The homepage is not draggable.
    disabled: item.path === homepagePath,
  });

  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  const isHomepage = item.path === homepagePath;
  const frontmatter = item.frontmatter as MarkdownFrontmatter | undefined;
  const isCollection = !!(frontmatter?.collection);
  const hasChildren = item.children && item.children.length > 0;

  // --- LOGIC FIX: The condition to show the collapse button is now fully specified. ---
  // It will only show if the item:
  // 1. Has children.
  // 2. Is NOT a collection page (we don't show their content items in the tree).
  // 3. Is NOT the homepage (the homepage's children are the top-level pages).
  const showCollapseButton = hasChildren && !isCollection && !isHomepage;

  const editorSlug = item.path.replace(/^content\//, '').replace(/\.md$/, '');
  const href = `${baseEditPath}/content/${editorSlug}`;

  const isOver = projected?.parentId === item.parentId && projected?.index === item.index;
  const projectedDepth = projected && isOver ? projected.depth : item.depth;
  const indentation = isClone ? item.depth * 24 : projectedDepth * 24;

  const showDropLine = activeId && projected && isOver && projected.depth === item.depth;
  const showNestingHighlight = activeId && projected && isOver && projected.depth > item.depth;
  
  return (
    <li
      ref={setNodeRef}
      style={{ paddingLeft: indentation, ...style }}
      className={cn(
        'relative list-none my-0.5 rounded-md transition-shadow',
        isDragging && 'opacity-50 z-10 shadow-lg',
        showNestingHighlight && 'bg-blue-100 dark:bg-blue-900/40'
      )}
    >
      {showDropLine && (
        <div className="absolute -top-[3px] left-0 right-0 h-1 bg-blue-500 rounded-full z-20" />
      )}
      
      <div
        className={cn(
          "flex items-center group w-full relative transition-colors h-9",
          activePath === item.path && "bg-accent text-accent-foreground"
        )}
      >
        <button
          {...attributes}
          {...listeners}
          disabled={isHomepage}
          className={cn(
            "p-1.5 touch-none",
            isHomepage ? "cursor-default text-muted-foreground/30" : "cursor-grab text-muted-foreground/50 hover:text-muted-foreground"
          )}
        >
          <GripVertical className="h-4 w-4" />
        </button>
        
        <div className="flex-grow flex items-center pl-1 pr-1 overflow-hidden">
          {showCollapseButton ? (
            <button onClick={() => onCollapse(item.path)} className="p-0.5 mr-1" aria-label={`Collapse ${item.title}`}>
                <ChevronRight className={cn("h-4 w-4 shrink-0 transition-transform duration-200", !item.collapsed && "rotate-90")} />
            </button>
          ) : (
            // A spacer is used to keep alignment consistent for items without a collapse button.
            <span className="w-5 mr-1 shrink-0" />
          )}

          {isHomepage ? (
            <Home className="h-4 w-4 shrink-0 text-primary" />
          ) : isCollection ? (
            <LayoutGrid className="h-4 w-4 shrink-0 text-muted-foreground" />
          ) : (
            <FileIcon className="h-4 w-4 shrink-0 text-muted-foreground" />
          )}
          
          <Link href={href} className="truncate flex-grow mx-1.5 text-sm hover:underline" title={item.title}>
            {item.menuTitle || item.title}
          </Link>
        </div>
      </div>
    </li>
  );
}

================================================================================

File: features/editor/components/DataSourceSelectWidget.tsx
// src/features/editor/components/DataSourceSelectWidget.tsx
'use client';

import { useEffect, useState, useMemo } from 'react';
import { getAvailableLayouts } from '@/core/services/configHelpers.service';
import { WidgetProps } from '@rjsf/utils';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Label } from '@/core/components/ui/label';
import type { LocalSiteData, StructureNode } from '@/types';
import type { LayoutManifest } from '@/core/services/configHelpers.service';

interface SelectOption {
  label: string;
  value: string;
}

interface DataSourceSelectWidgetProps extends WidgetProps {
    formContext?: {
        site?: LocalSiteData;
    };
}

const DataSourceSelectWidget = ({ id, label, options, value, onChange, required, formContext }: DataSourceSelectWidgetProps) => {
  const { uiSchema } = options;
  const site = formContext?.site;

  const dataSource = uiSchema?.['ui:dataSource'] as string;
  const layoutTypeFilter = uiSchema?.['ui:layoutType'] as string | undefined;

  const [items, setItems] = useState<SelectOption[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchItems = async () => {
      // Add a more robust guard clause
      if (!site || !site.manifest || !site.contentFiles) {
        setItems([]);
        setIsLoading(false);
        return;
      }
      setIsLoading(true);

      let fetchedItems: SelectOption[] = [];

      try {
        switch (dataSource) {
          case 'collections':
            // 1. Find all content files that ARE collection pages.
            const collectionFilePaths = new Set(
              site.contentFiles
                .filter(f => !!f.frontmatter.collection)
                .map(f => f.path)
            );
            // 2. Filter the structure nodes to only include those whose paths are in our set.
            fetchedItems = site.manifest.structure
              .filter((n: StructureNode) => collectionFilePaths.has(n.path))
              .map((c: StructureNode) => ({ label: c.title, value: c.slug }));
            break;

          case 'layouts':
            const allLayouts: LayoutManifest[] = await getAvailableLayouts(site);
            fetchedItems = allLayouts
              .filter(l => !layoutTypeFilter || l.layoutType === layoutTypeFilter)
              .map(l => ({ label: l.name, value: l.id })); // Use id for value
            break;

          default:
            fetchedItems = [];
        }
        setItems(fetchedItems);
      } catch (error) {
        console.error(`Failed to fetch data source "${dataSource}":`, error);
        setItems([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchItems();
  }, [site, dataSource, layoutTypeFilter]);

  const placeholder = useMemo(() => {
    if (isLoading) return `Loading ${dataSource || 'options'}...`;
    if (dataSource) return `Select a ${dataSource.replace(/s$/, '')}...`;
    return 'Select an option...';
  }, [isLoading, dataSource]);

  return (
    <div className="space-y-1">
      <Label htmlFor={id}>{label}{required ? '*' : ''}</Label>
      <Select value={value} onValueChange={onChange} disabled={isLoading}>
        <SelectTrigger id={id} className="mt-1">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {items.map(item => (
            <SelectItem key={item.value} value={item.value}>
              {item.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DataSourceSelectWidget;

================================================================================

File: features/editor/components/BlocknoteEditor.tsx
// src/features/editor/components/BlocknoteEditor.tsx
'use client';

import { forwardRef, useImperativeHandle } from 'react';
import { Block } from '@blocknote/core';
import { useCreateBlockNote } from '@blocknote/react';
import { BlockNoteView } from '@blocknote/mantine';
import '@blocknote/mantine/style.css';
import { Label } from '@/core/components/ui/label';

interface BlocknoteEditorProps {
  initialContent: Block[];
  onContentChange: () => void; // Only needs to signal a change, not pass content
}

// The ref will now expose a function to get the editor's block data.
export interface BlocknoteEditorRef {
  getBlocks: () => Block[];
}

const BlocknoteEditor = forwardRef<BlocknoteEditorRef, BlocknoteEditorProps>(
  ({ initialContent, onContentChange }, ref) => {
    // Creates a new editor instance.
    const editor = useCreateBlockNote({
        initialContent: initialContent.length > 0 ? initialContent : undefined,
    });

    // Expose a function for the parent component to get the current content.
    useImperativeHandle(ref, () => ({
      getBlocks: () => {
        return editor.document;
      },
    }));

    return (
      <div className="space-y-2 h-full flex flex-col">
        <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400 shrink-0">
          Content
        </Label>
        <div className="flex-grow min-h-0 overflow-y-auto border p-2">
            <BlockNoteView
                editor={editor}
                theme="light" // Or use a theme provider to make it dynamic
                onChange={onContentChange}
            />
        </div>
      </div>
    );
  }
);

BlocknoteEditor.displayName = 'BlocknoteEditor';
export default BlocknoteEditor;

================================================================================

File: features/editor/components/CollectionItemList.tsx
// src/features/editor/components/CollectionItemList.tsx
'use client';

import Link from 'next/link';
import { useMemo } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { findChildNodes } from '@/core/services/fileTree.service';
import { Button } from '@/core/components/ui/button';
import { FileText, PlusCircle } from 'lucide-react';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';

interface CollectionItemListProps {
  siteId: string;
  collectionPagePath: string; // e.g., 'content/blog.md'
}

export default function CollectionItemList({ siteId, collectionPagePath }: CollectionItemListProps) {
  const site = useAppStore(state => state.getSiteById(siteId));

  const collectionItems = useMemo(() => {
    if (!site?.manifest) return [];
    return findChildNodes(site.manifest.structure, collectionPagePath);
  }, [site?.manifest, collectionPagePath]);

  const newItemPath = `/sites/${siteId}/edit/content/${collectionPagePath.replace('content/', '').replace('.md', '')}/${NEW_FILE_SLUG_MARKER}`;

  return (
    <div className="h-full flex flex-col p-6">
      <div className="flex shrink-0 items-center justify-between mb-4 pb-4 border-b">
        <h1 className="text-2xl font-bold">Collection Items</h1>
        <Button asChild>
          <Link href={newItemPath}>
            <PlusCircle className="mr-2 h-4 w-4" /> New Item
          </Link>
        </Button>
      </div>
      <div className="flex-grow rounded-lg bg-background p-1 overflow-y-auto">
        {collectionItems.length > 0 ? (
          <ul className="space-y-1">
            {collectionItems.map((item) => {
              // --- THIS IS THE FIX ---
              // Generate the link from the reliable `item.path` instead of `item.slug`.
              const editorSlug = item.path.replace(/^content\//, '').replace(/\.md$/, '');
              const itemEditorPath = `/sites/${siteId}/edit/content/${editorSlug}`;
              // --- END OF FIX ---

              return (
                <li key={item.path}>
                  <Link href={itemEditorPath} className="flex items-center rounded-md p-2 transition-colors hover:bg-muted">
                    <FileText className="mr-3 h-4 w-4 text-muted-foreground" />
                    <span className="font-medium">{item.title || item.slug}</span>
                  </Link>
                </li>
              );
            })}
          </ul>
        ) : (
          <div className="text-center text-muted-foreground py-10">
            <p>No items have been added to this collection yet.</p>
            <Button asChild variant="outline" className="mt-4">
               <Link href={newItemPath}>
                    <PlusCircle className="mr-2 h-4 w-4" /> Add your first item
                </Link>
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}

================================================================================

File: features/editor/components/CreateCollectionPageDialog.tsx
// src/features/editor/components/CreateCollectionPageDialog.tsx
'use client';

import { useState, useEffect, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// UI & Type Imports
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter } from '@/types';
//import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface CreateCollectionPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

// Default layouts for a new collection page
const DEFAULT_LIST_LAYOUT = 'listing';
const DEFAULT_ITEM_LAYOUT = 'teaser';
const DEFAULT_ITEM_PAGE_LAYOUT = 'page';

export default function CreateCollectionPageDialog({ siteId, children, onComplete }: CreateCollectionPageDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  useEffect(() => {
    setSlug(slugify(name));
  }, [name]);

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setName('');
        setSlug('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }

    const filePath = `content/${slug}.md`;
    if (site?.contentFiles?.some(f => f.path === filePath)) {
        toast.error(`A page with the folder name "${slug}" already exists.`);
        return;
    }

    setIsSubmitting(true);

    const frontmatter: MarkdownFrontmatter = {
        title: name.trim(),
        layout: DEFAULT_LIST_LAYOUT, // The layout for this page itself
        collection: { // The special block that makes this a Collection Page
            item_layout: DEFAULT_ITEM_LAYOUT,
            item_page_layout: DEFAULT_ITEM_PAGE_LAYOUT,
            sort_by: 'date',
            sort_order: 'desc',
            items_per_page: 10,
        }
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\n# Welcome to the ${name.trim()} collection!\n\nYou can write an introduction for this collection here.`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);
      if (success) {
        toast.success(`Collection page "${name}" created!`);
        handleOpenChange(false);
        onComplete?.();
        // Redirect to the editor for the new collection page itself
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else {
        throw new Error("Failed to update manifest or save file.");
      }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
    } finally {
        setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection Page</DialogTitle>
            <DialogDescription>
              Create a new page that will list other pages, like a blog or a portfolio.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name.trim() || isSubmitting}>
                {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Collection</>}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/RightSidebar.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';

interface RightSidebarProps {
  children: ReactNode;
}

export default function RightSidebar({ children }: RightSidebarProps) {
  const { isRightOpen } = useUIStore((state) => state.sidebar);

  return (
    <aside
      className={cn(
        // Base styles
        'h-full w-80 shrink-0 border-l bg-muted/20 transition-all duration-300 ease-in-out',
        
        // Hide/Show Logic
        isRightOpen ? 'ml-0' : '-mr-[320px] w-0 border-l-0 opacity-0'
      )}
    >
      <div className="h-full overflow-y-auto">
        {children}
      </div>
    </aside>
  );
}

================================================================================

File: features/editor/components/SaveButton.tsx
// src/features/editor/components/SaveButton.tsx
'use client';

import { useEditor } from '@/features/editor/contexts/EditorContext';
import { Button } from '@/core/components/ui/button';
import { Save, Check, Loader2 } from 'lucide-react';

/**
 * A context-aware button that displays the current save state
 * (e.g., Save, Saving..., Saved) and triggers the save action.
 *
 * This component MUST be rendered within a tree wrapped by an `<EditorProvider>`
 * as it relies on the `useEditor` hook for its state and actions.
 */
export default function SaveButton() {
  const { saveState, hasUnsavedChanges, triggerSave } = useEditor();

  // Define the visual states for the button
  const buttonStates = {
    idle: {
      icon: <Save className="h-4 w-4" />,
      text: 'Save',
    },
    saving: {
      icon: <Loader2 className="h-4 w-4 animate-spin" />,
      text: 'Saving...',
    },
    saved: {
      icon: <Check className="h-4 w-4" />,
      text: 'Saved',
    },
  };

  // Determine the current display state and if the button should be disabled
  let currentDisplayState: 'idle' | 'saving' | 'saved';
  let isDisabled = false;

  if (saveState === 'saving') {
    currentDisplayState = 'saving';
    isDisabled = true;
  } else if (hasUnsavedChanges) {
    currentDisplayState = 'idle';
    isDisabled = false;
  } else {
    // This covers both 'saved' and 'no_changes' states.
    // In both cases, the content is considered saved and there's nothing to do.
    currentDisplayState = 'saved';
    isDisabled = true;
  }

  const current = buttonStates[currentDisplayState];

  return (
    <Button variant='ghost' onClick={triggerSave} disabled={isDisabled}>
      {current.icon}
      <span className='hidden md:block'>{current.text}</span>
    </Button>
  );
}

================================================================================

File: features/editor/components/LeftSidebar.tsx
// src/components/publishing/LeftSidebar.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useMemo, useCallback, useState } from 'react';
import { createPortal } from 'react-dom';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import FileTree from '@/features/editor/components/FileTree';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
import CreateCollectionPageDialog from '@/features/editor/components/CreateCollectionPageDialog';
import { FilePlus, LayoutGrid, GripVertical, Archive } from 'lucide-react';
import {
  DndContext,
  DragEndEvent,
  DragOverlay,
  DragStartEvent,
  PointerSensor,
  useSensor,
  useSensors,
  DragOverEvent,
  DragMoveEvent,
  closestCenter,
  useDroppable,
} from '@dnd-kit/core';
import { flattenTree, FlattenedNode } from '@/core/services/fileTree.service';
import { arrayMove } from '@dnd-kit/sortable';
import { toast } from 'sonner';
import { exportSiteBackup } from '@/core/services/siteBackup.service';
import { slugify } from '@/lib/utils';

interface DndProjection {
  parentId: string | null;
  depth: number;
  index: number;
}

function DragOverlayItem({ id, items }: { id: string, items: FlattenedNode[] }) {
    const item = items.find(i => i.path === id);
    if (!item) return null;
    return (
        <div className="flex items-center gap-2 p-2 bg-background border rounded-md shadow-lg text-sm font-semibold">
            <GripVertical className="h-4 w-4 text-muted-foreground" />
            <span>{item.title}</span>
        </div>
    );
}

export default function LeftSidebar() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;
  const { getSiteById, loadSite } = useAppStore();

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { repositionNode } = useAppStore.getState();

  const [activeId, setActiveId] = useState<string | null>(null);
  const [overId, setOverId] = useState<string | null>(null);
  const [offsetLeft, setOffsetLeft] = useState(0);
  const [collapsedIds, setCollapsedIds] = useState<Set<string>>(new Set());

  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 8 } }));
  const { setNodeRef: setRootDroppableRef } = useDroppable({ id: '__root_droppable__' });

  const flattenedItems = useMemo(() => {
    if (!site?.manifest.structure || !site.contentFiles) return [];
    return flattenTree(site.manifest.structure, site.contentFiles);
  }, [site?.manifest.structure, site?.contentFiles]);
  
  const homepageItem = useMemo(() => flattenedItems.find(item => item.frontmatter?.homepage === true), [flattenedItems]);
  const sortableItems = useMemo(() => flattenedItems.filter(item => item.frontmatter?.homepage !== true), [flattenedItems]);
  const sortableIds = useMemo(() => sortableItems.map(i => i.path), [sortableItems]);
  
  const activeItem = activeId ? flattenedItems.find(i => i.path === activeId) : null;

  const handleExportBackup = async () => {
    toast.info("Preparing site backup...");
    try {
        await loadSite(siteId);
        const siteToExport = getSiteById(siteId);
        if (!siteToExport) throw new Error("Could not load site data for export.");
        const blob = await exportSiteBackup(siteToExport);
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${slugify(siteToExport.manifest.title || 'signum-backup')}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        toast.success("Site backup downloaded!");
    } catch (error) {
        console.error("Failed to export site:", error);
        toast.error(`Export failed: ${(error as Error).message}`);
    }
  };

  const itemsToRender = useMemo(() => {
    // This logic correctly filters children of collapsed parents.
    return flattenedItems.filter(item => {
        if (item.depth === 0) return true;
        if (item.parentId && collapsedIds.has(item.parentId)) return false;
        // Also check grandparents for level 2 items
        const parent = flattenedItems.find(p => p.path === item.parentId);
        if (parent?.parentId && collapsedIds.has(parent.parentId)) return false;
        return true;
    });
  }, [flattenedItems, collapsedIds]);
  
  const projected = useMemo((): DndProjection | null => {
    if (!activeItem || !overId) return null;
    const indentationWidth = 24;
    const dragDepth = Math.round(offsetLeft / indentationWidth);
    const projectedDepth = activeItem.depth + dragDepth;
    const overItemIndex = flattenedItems.findIndex(({ path }) => path === overId);
    const activeItemIndex = flattenedItems.findIndex(({ path }) => path === activeId);
    const newItems = arrayMove(flattenedItems, activeItemIndex, overItemIndex);
    const previousItem = newItems[overItemIndex - 1];
    const nextItem = newItems[overItemIndex + 1];
    const maxDepth = previousItem ? previousItem.depth + 1 : 0;
    const minDepth = nextItem ? nextItem.depth : 0;
    let depth = Math.max(minDepth, Math.min(projectedDepth, maxDepth));

    if (depth > 2) {
      depth = 2;
    }
    
    let parentId = null;
    if (depth > 0 && previousItem) {
        if (depth === previousItem.depth) parentId = previousItem.parentId;
        else if (depth > previousItem.depth) parentId = previousItem.path;
        else parentId = newItems.slice(0, overItemIndex).reverse().find((item) => item.depth === depth)?.parentId ?? null;
    }
    return { depth, parentId, index: overItemIndex };
  }, [activeId, overId, offsetLeft, flattenedItems, activeItem]);

  const handleCollapse = useCallback((id: string) => {
    setCollapsedIds(prev => {
        const newSet = new Set(prev);
        if (newSet.has(id)) newSet.delete(id);
        else newSet.add(id);
        return newSet;
    });
  }, []);

  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveId(event.active.id as string);
    setOverId(event.active.id as string);
  }, []);

  const handleDragMove = useCallback((event: DragMoveEvent) => setOffsetLeft(event.delta.x), []);
  const handleDragOver = useCallback((event: DragOverEvent) => setOverId(event.over?.id as string ?? null), []);

  const resetState = useCallback(() => {
    setActiveId(null);
    setOverId(null);
    setOffsetLeft(0);
  }, []);

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    if (!projected) {
        resetState();
        return;
    }
    const { active, over } = event;
    if (site && active.id && over?.id) {
        if (over.id === '__root_droppable__') {
            repositionNode(siteId, active.id as string, null, flattenedItems.length - 1);
        } else {
            repositionNode(siteId, active.id as string, projected.parentId, projected.index);
        }
    }
    resetState();
  }, [projected, site, siteId, repositionNode, flattenedItems.length, resetState]);

  
  


  const activePathForFileTree = useMemo(() => {
    if (!site?.manifest) return undefined;
    const editorRootPath = `/sites/${siteId}/edit/content`;
    if (pathname.startsWith(editorRootPath)) {
        const slug = pathname.substring(editorRootPath.length).replace(/^\//, '');
        return slug ? `content/${slug}.md` : homepageItem?.path;
    }
    return undefined;
  }, [pathname, site, siteId, homepageItem]);

  if (!site) return null;

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragMove={handleDragMove}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
      onDragCancel={resetState}
    >
      <div className="flex h-full flex-col">
        <div className="flex shrink-0 items-center justify-between border-b px-2 py-0.5">
          <h3 className="px-2 text-xs font-semibold uppercase tracking-wider text-muted-foreground">Content</h3>
          <div className="flex items-center gap-1">
            <CreateCollectionPageDialog siteId={siteId}>
                <Button variant="ghost" className='size-7 p-1' title="New Collection">
                    <LayoutGrid className="h-4 w-4" />
                </Button>
            </CreateCollectionPageDialog>
            <NewPageDialog siteId={siteId}>
                <Button variant="ghost" className='size-7 p-1' title="New Page">
                    <FilePlus className="h-4 w-4" />
                </Button>
            </NewPageDialog>
          </div>
        </div>
        
        <div className="flex-grow overflow-y-auto p-2" ref={setRootDroppableRef}>
          {homepageItem && itemsToRender.length > 0 ? (
            <FileTree 
              itemsToRender={itemsToRender.map(item => ({...item, collapsed: collapsedIds.has(item.path)}))}
              sortableIds={sortableIds}
              activeId={activeId}
              projected={projected}
              baseEditPath={`/sites/${siteId}/edit`}
              activePath={activePathForFileTree}
              homepagePath={homepageItem.path}
              onCollapse={handleCollapse}
            />
          ) : (
            <div className="px-2 py-4 text-xs text-center text-muted-foreground italic">
              <p>No pages created yet. Click the buttons above to add one.</p>
            </div>
          )}
        </div>

        <div className="mt-auto shrink-0 border-t p-2 space-y-1">
            <Button variant="ghost" onClick={handleExportBackup} className="w-full justify-start gap-2">
                <Archive className="h-4 w-4" /> Export site backup
            </Button>
            
        </div>
      </div>
      
      {createPortal(
        <DragOverlay dropAnimation={null} style={{ pointerEvents: 'none' }}>
          {activeId ? <DragOverlayItem id={activeId} items={flattenedItems} /> : null}
        </DragOverlay>,
        document.body
      )}
    </DndContext>
  );
}

================================================================================

File: features/editor/components/FrontmatterSidebar.tsx
// src/features/editor/components/FrontmatterSidebar.tsx
'use client';

import React, { useState, useEffect, useMemo } from 'react';
import type { LocalSiteData, MarkdownFrontmatter } from '@/types';
import { getAvailableLayouts, getLayoutManifest, LayoutManifest } from '@/core/services/configHelpers.service';
import { RJSFSchema } from '@rjsf/utils'; 
import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Button } from '@/core/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Trash2 } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";
import ViewEditor from '@/features/editor/components/CollectionSettings'; 
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm'; 

/**
 * Props for the FrontmatterSidebar component.
 */
interface FrontmatterSidebarProps {
  siteId: string;
  filePath: string; // The full path to the content file being edited
  site: Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles' | 'contentFiles'>;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: Partial<MarkdownFrontmatter>) => void;
  isNewFileMode: boolean;
  slug: string;
  onSlugChange: (newSlug: string) => void;
  onDelete: () => Promise<void>;
}

/**
 * Renders the right-hand sidebar in the editor, containing all metadata
 * and settings for the current page (frontmatter).
 */
export default function FrontmatterSidebar({
  siteId, site, frontmatter, onFrontmatterChange,
  isNewFileMode, slug, onSlugChange, onDelete,
}: FrontmatterSidebarProps) {

  const [availableLayouts, setAvailableLayouts] = useState<LayoutManifest[]>([]);
  const [layoutSchema, setLayoutSchema] = useState<RJSFSchema | null>(null);

  const isCollectionPage = useMemo(() => !!frontmatter.collection, [frontmatter]);

  // Effect to fetch the available layouts (e.g., page, list) for the dropdowns.
  useEffect(() => {
    async function fetchAndFilterLayouts() {
      if (!site) return;
      const requiredLayoutType = isCollectionPage ? 'list' : 'page';
      const filteredLayouts = await getAvailableLayouts(site, requiredLayoutType);
      setAvailableLayouts(filteredLayouts);
    }
    fetchAndFilterLayouts();
  }, [site, isCollectionPage]);

  // Effect to load the JSON schema for the currently selected layout.
  useEffect(() => {
    const loadSchema = async () => {
      if (!frontmatter.layout) {
        setLayoutSchema(null);
        return;
      }
      const manifest = await getLayoutManifest(site, frontmatter.layout);
      setLayoutSchema(manifest?.schema || null);
    };
    loadSchema();
  }, [site, frontmatter.layout]);

  const menuTitleValue = typeof frontmatter.menuTitle === 'string' ? frontmatter.menuTitle : '';
  const handleLayoutChange = (layoutId: string) => {
    onFrontmatterChange({ layout: layoutId });
  };

  return (
    <div className="space-y-6 h-full flex flex-col">
      
      {/* Settings are organized into accordions for clarity */}
      <Accordion type="multiple" defaultValue={['page', 'collection']} className="w-full flex-grow overflow-y-auto">
        {isCollectionPage && (
          <AccordionItem value="collection">
            <AccordionTrigger>Collection settings</AccordionTrigger>
            <AccordionContent className="pt-2">
              <ViewEditor siteId={siteId} frontmatter={frontmatter} onFrontmatterChange={onFrontmatterChange} />
            </AccordionContent>
          </AccordionItem>
        )}
        <AccordionItem value="page">
          <AccordionTrigger>Page meta</AccordionTrigger>
          <AccordionContent className="space-y-6 ">

            {layoutSchema && (
                <div className="">
                    <SchemaDrivenForm schema={layoutSchema} formData={frontmatter} onFormChange={(data) => onFrontmatterChange(data as Partial<MarkdownFrontmatter>)} />
                </div>
            )}
          </AccordionContent>
        </AccordionItem>

        
        <AccordionItem value='menu'>
        <AccordionTrigger>Menu settings</AccordionTrigger>
          <AccordionContent>
 <div className="space-y-2">
              <Label htmlFor="menu-title-input">Menu title (Optional)</Label>
              <Input
                id="menu-title-input"
                placeholder="e.g., Home, About Us"
                value={menuTitleValue}
                onChange={(e) => onFrontmatterChange({ menuTitle: e.target.value })}
              />
              <p className="text-xs text-muted-foreground">A short label for navigation menus. If left blank, the page title will be used.</p>
            </div>
          </AccordionContent>

        </AccordionItem>

        <AccordionItem value='layout'>
          <AccordionTrigger>Layout settings</AccordionTrigger>
          <AccordionContent>
<div className="space-y-2">
              <Label htmlFor="page-layout-select">Layout</Label>
              <Select value={frontmatter.layout} onValueChange={handleLayoutChange}>
                  <SelectTrigger id="page-layout-select" className='w-full'><SelectValue placeholder="Select a layout..." /></SelectTrigger>
                  <SelectContent>{availableLayouts.map(layout => <SelectItem key={layout.id} value={layout.id}>{layout.name}</SelectItem>)}</SelectContent>
              </Select>
               <p className="text-xs text-muted-foreground">Controls the appearance of this page.</p>
            </div>
          </AccordionContent>
        </AccordionItem>

        <AccordionItem value="advanced">
          <AccordionTrigger>Advanced</AccordionTrigger>
          <AccordionContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="slug-input">URL Slug</Label>
                <Input
                    id="slug-input"
                    value={slug}
                    onChange={(e) => onSlugChange(e.target.value)}
                    disabled={!isNewFileMode}
                    className={!isNewFileMode ? 'bg-muted/50 cursor-not-allowed' : ''}
                />
                <p className="text-xs text-muted-foreground">The unique filename for this page. Can only be set on creation.</p>
              </div>
              {!isNewFileMode && (
        <div className="">
          <AlertDialog>
              <AlertDialogTrigger asChild>
                  <Button variant="outline" className="w-full text-destructive hover:bg-destructive/10 hover:text-destructive">
                      <Trash2 className="h-4 w-4 mr-2" /> Delete page
                  </Button>
              </AlertDialogTrigger>
              <AlertDialogContent>
                  <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This action will permanently delete the file for &quot;{frontmatter?.title || 'this content'}&quot; and cannot be undone.
                      </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={onDelete} className="bg-destructive hover:bg-destructive/90 text-destructive-foreground">
                          Yes, Delete Forever
                      </AlertDialogAction>
                  </AlertDialogFooter>
              </AlertDialogContent>
          </AlertDialog>
        </div>
      )}
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      {/* The Delete button is only available for existing pages */}
      
    </div>
  );
}

================================================================================

File: features/editor/hooks/useUnloadPrompt.ts
// src/features/editor/hooks/useUnloadPrompt.ts
'use client';

import { useEffect } from 'react';

/**
 * A hook that shows the native browser confirmation dialog when the user
 * attempts to navigate away from the page.
 *
 * @param {boolean} shouldPrompt - A flag that determines whether the prompt should be shown.
 */
export function useUnloadPrompt(shouldPrompt: boolean) {
  useEffect(() => {
    const handleBeforeUnload = (event: BeforeUnloadEvent) => {
      if (shouldPrompt) {
        // Standard way to trigger the browser's native confirmation dialog
        event.preventDefault();
        // Required for some older browsers
        event.returnValue = '';
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    // Cleanup the event listener when the component unmounts
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [shouldPrompt]); // The effect re-runs whenever the `shouldPrompt` flag changes
}

================================================================================

File: features/editor/hooks/usePageIdentifier.ts
// src/features/editor/hooks/usePageIdentifier.ts
'use client';

import { useMemo } from 'react';
import { useParams } from 'next/navigation';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';
import type { LocalSiteData } from '@/types';

interface PageIdentifierParams {
  /** The fully loaded site data object from the Zustand store. */
  site: LocalSiteData | undefined;
}

/**
 * A data-aware hook that parses the URL to identify the site and the specific
 * file path being targeted for editing.
 *
 * Its primary responsibilities are:
 * 1.  Identifying when the user is creating a new file.
 * 2.  Resolving a URL with a slug (e.g., `/edit/content/about-us`) to a file path (`content/about-us.md`).
 * 3.  **Crucially, resolving the editor's root URL (`/edit/content`) to the site's designated homepage file path.**
 *
 * @param {PageIdentifierParams} props - Contains the loaded site data.
 * @returns An object containing the resolved `siteId`, `filePath`, and other contextual flags.
 */
export function usePageIdentifier({ site }: PageIdentifierParams) {
  const params = useParams();
  const siteId = params.siteId as string;
  const slugSegments = useMemo(() => (params.slug as string[]) || [], [params.slug]);

  const isNewFileMode = useMemo(() => slugSegments.includes(NEW_FILE_SLUG_MARKER), [slugSegments]);

  const filePath = useMemo(() => {
    // For creating a new file, the path is its intended parent directory.
    if (isNewFileMode) {
      const parentSlug = slugSegments.slice(0, slugSegments.indexOf(NEW_FILE_SLUG_MARKER)).join('/');
      return parentSlug ? `content/${parentSlug}` : 'content';
    }

    // --- Logic for an existing file ---
    const slug = slugSegments.join('/');
    
    // If the URL has a specific slug, the file path is derived directly from it.
    if (slug) {
      return `content/${slug}.md`;
    }

    // **Homepage Resolution Logic**
    // If the URL has NO slug, we are at the editor's root. We must find the
    // designated homepage file from the loaded site data.
    if (site?.contentFiles) {
      const homepageFile = site.contentFiles.find(f => f.frontmatter.homepage === true);
      // Return the actual path of the homepage file.
      if (homepageFile) {
        return homepageFile.path;
      }
    }
    
    // Fallback: If data is not yet loaded or if the site is brand new and has no
    // pages (and therefore no homepage), return an empty path. The UI will handle this state.
    return '';

  }, [slugSegments, isNewFileMode, site]);

  return { siteId, slugSegments, isNewFileMode, filePath };
}

================================================================================

File: features/editor/hooks/useFileContent.ts
// src/features/editor/hooks/useFileContent.ts
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/EditorContext';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import type { MarkdownFrontmatter } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';
import { Block } from '@blocknote/core';
import { markdownToBlocks } from '@/core/services/blocknote.service';

/** The possible loading states for the file content. */
export type FileStatus = 'initializing' | 'loading' | 'ready' | 'not_found';
interface PageFrontmatter extends MarkdownFrontmatter { menuTitle?: string; }

/**
 * Manages the content state for the editor.
 *
 * This hook is responsible for:
 * 1.  Taking a definitive `filePath` (from `usePageIdentifier`).
 * 2.  Waiting for the global site data to be loaded into the Zustand store.
 * 3.  **Reading the file's content directly from the store, not re-fetching it from storage.**
 * 4.  Preparing the initial state for the editor (frontmatter, Blocknote blocks).
 * 5.  Handling state changes as the user types or modifies frontmatter fields.
 *
 * @param siteId The ID of the current site.
 * @param filePath The unambiguous path to the file to be loaded.
 * @param isNewFileMode A flag indicating if we are creating a new file.
 * @returns An object containing the status, content state, and state handlers.
 */
export function useFileContent(siteId: string, filePath: string, isNewFileMode: boolean) {
  const router = useRouter();
  const site = useAppStore(state => state.getSiteById(siteId));
  const { setHasUnsavedChanges } = useEditor();

  const [status, setStatus] = useState<FileStatus>('initializing');
  const [frontmatter, setFrontmatter] = useState<PageFrontmatter | null>(null);
  const [slug, setSlug] = useState('');
  const [initialBlocks, setInitialBlocks] = useState<Block[]>([]);

  useEffect(() => {
    const loadData = async () => {
      // **Guard Clause 1:** Wait until `usePageIdentifier` has resolved a valid path.
      // This prevents trying to load content for an empty or resolving path.
      if (!filePath) {
        setStatus('loading');
        return;
      }
      
      // **Guard Clause 2:** Wait for the site's content files to be fully hydrated
      // into the Zustand store from local storage. This is the key to preventing race conditions.
      if (!site?.contentFiles) {
        setStatus('loading');
        return;
      }

      let markdownContent = '';

      if (isNewFileMode) {
        // Setup for a brand new, unsaved file.
        setFrontmatter({
          title: '',
          layout: DEFAULT_PAGE_LAYOUT_PATH,
          date: new Date().toISOString().split('T')[0],
          status: 'draft',
        });
        markdownContent = '# Start Writing...';
        setSlug('');
      } else {
        // **The Core Fix: Read directly from the hydrated Zustand store.**
        const fileData = site.contentFiles.find(f => f.path === filePath);

        if (!fileData) {
          setStatus('not_found');
          toast.error(`Content file not found at path: ${filePath}`);
          router.replace(`/sites/${siteId}/edit`); // Redirect to a safe page.
          return;
        }
        
        // Use the data already in the store. No re-fetching or re-parsing needed.
        setFrontmatter(fileData.frontmatter);
        markdownContent = fileData.content;
        setSlug(fileData.slug);
      }
      
      // Convert the markdown body into blocks for the editor.
      const blocks = await markdownToBlocks(markdownContent);
      setInitialBlocks(blocks);

      // We are ready to render the editor.
      setStatus('ready');
      setHasUnsavedChanges(false);
    };

    loadData();
    
  }, [site, filePath, isNewFileMode, siteId, router, setHasUnsavedChanges]);

  // Callback to signal that some content (either body or frontmatter) has changed.
  const onContentModified = useCallback(() => {
    setHasUnsavedChanges(true);
  }, [setHasUnsavedChanges]);

  // Handler for frontmatter form changes. It receives a partial update.
  const handleFrontmatterChange = useCallback((update: Partial<PageFrontmatter>) => {
    setFrontmatter(prev => {
      if (!prev) return null;
      const newFm = { ...prev, ...update };
      // Auto-generate the slug from the title, but only for new files.
      if (isNewFileMode && update.title !== undefined) {
        setSlug(slugify(update.title));
      }
      return newFm;
    });
    onContentModified();
  }, [isNewFileMode, onContentModified]);

  return { status, frontmatter, initialBlocks, slug, setSlug, handleFrontmatterChange, onContentModified };
}

================================================================================

File: features/editor/hooks/useFilePersistence.ts
// src/features/editor/hooks/useFilePersistence.ts
'use client';

import { useCallback, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/EditorContext';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';
import { toast } from 'sonner';
import type { MarkdownFrontmatter } from '@/types';
import { useUnloadPrompt } from './useUnloadPrompt';
import { Block } from '@blocknote/core';
import { blocksToMarkdown } from '@/core/services/blocknote.service';

interface PersistenceParams {
  siteId: string;
  filePath: string;
  isNewFileMode: boolean;
  frontmatter: MarkdownFrontmatter | null;
  slug: string;
  getEditorContent: () => Block[]; 
}

export function useFilePersistence({
  siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent,
}: PersistenceParams) {
  const router = useRouter();
  const { addOrUpdateContentFile, deleteContentFileAndState, getSiteById } = useAppStore.getState();
  const { hasUnsavedChanges, setHasUnsavedChanges, setSaveState, registerSaveAction } = useEditor();
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleSave = useCallback(async () => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);
    if (!frontmatter) throw new Error("Frontmatter not ready for saving.");
    if (!frontmatter.title.trim()) throw new Error("A title is required before saving.");

    const currentBlocks = getEditorContent();
    const markdownBody = await blocksToMarkdown(currentBlocks);
    
    // --- FIX: Logic is now split for Create vs. Update ---
    if (isNewFileMode) {
      // --- CREATION LOGIC (First Save) ---
      if (!slug.trim()) throw new Error("A URL slug is required for a new page.");
      
      const site = getSiteById(siteId);
      const finalPath = `${filePath}/${slug.trim()}.md`.replace('//', '/');

      // Check for path conflicts before saving
      if (site?.contentFiles?.some(f => f.path === finalPath)) {
        throw new Error(`A page with the path "${slug}" already exists.`);
      }

      const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);
      await addOrUpdateContentFile(siteId, finalPath, rawMarkdown);

      // Transition from "creation mode" to "editing mode" by updating the URL
      const newEditPath = finalPath.replace(/^content\//, '').replace(/\.md$/, '');
      router.replace(`/sites/${siteId}/edit/content/${newEditPath}`);

    } else {
      // --- UPDATE LOGIC (Subsequent Saves) ---
      const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);
      await addOrUpdateContentFile(siteId, filePath, rawMarkdown);
    }
  }, [siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent, addOrUpdateContentFile, getSiteById, router]);

  const handleDelete = useCallback(async () => {
    if (isNewFileMode || !frontmatter) return;
    try {
      await deleteContentFileAndState(siteId, filePath);
      toast.success(`Page "${frontmatter.title}" deleted.`);
      router.push(`/sites/${siteId}/edit`);
    } catch (error) {
      toast.error(`Failed to delete page: ${(error as Error).message}`);
    }
  }, [isNewFileMode, frontmatter, deleteContentFileAndState, siteId, filePath, router]);

  useEffect(() => {
    registerSaveAction(handleSave);
  }, [handleSave, registerSaveAction]);

  useEffect(() => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);
    // Autosave is disabled in new file mode until the first manual save.
    if (hasUnsavedChanges && !isNewFileMode) {
      autosaveTimeoutRef.current = setTimeout(async () => {
        setSaveState('saving');
        try {
          await handleSave();
          setHasUnsavedChanges(false);
          setSaveState('saved');
          setTimeout(() => setSaveState('no_changes'), 2000);
        } catch (error) { console.error("Autosave failed:", error); setSaveState('idle'); }
      }, AUTOSAVE_DELAY);
    }
    return () => { if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current); };
  }, [hasUnsavedChanges, isNewFileMode, handleSave, setSaveState, setHasUnsavedChanges]);

  useUnloadPrompt(hasUnsavedChanges);

  return { handleDelete };
}

================================================================================

File: components/publishing/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { Label } from '@/core/components/ui/label';

interface MarkdownEditorProps {
  initialValue: string;
  // onContentChange is now used primarily by the parent to trigger its own state updates
  onContentChange: (markdown: string) => void;
}

// The ref now needs to expose a method to get the current content
export interface MarkdownEditorRef {
  getMarkdown: () => string;
}

const MarkdownEditor = forwardRef<MarkdownEditorRef, MarkdownEditorProps>(
  ({ initialValue, onContentChange }, ref) => {
    // We'll manage the textarea's value with local state
    const [content, setContent] = useState(initialValue);

    // If the initialValue prop changes from the parent (e.g., loading a new file),
    // we update the local state.
    useEffect(() => {
      setContent(initialValue);
    }, [initialValue]);

    // Expose a function for the parent component to get the current content
    useImperativeHandle(ref, () => ({
      getMarkdown: () => {
        return content;
      },
    }));

    // This handler updates both local state and informs the parent of a change
    const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
      const newContent = event.target.value;
      setContent(newContent);
      onContentChange(newContent); // Let the parent know things have changed
    };

    return (
      <div className="space-y-2 h-full">
      <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400">
            Content
          </Label>
      <textarea
        id="content-body"
        value={content}
        onChange={handleChange}
        placeholder="Start writing your Markdown here..."
        className="w-full h-full bg-background 
                   text-base font-mono leading-relaxed resize-none 
                   focus:ring-2 focus:ring-ring focus:outline-none"
      />
      </div>
    );
  }
);

MarkdownEditor.displayName = 'MarkdownEditor';
export default MarkdownEditor;

================================================================================

File: components/publishing/SchemaDrivenForm.tsx
'use client';

import Form from '@rjsf/shadcn';
import validator from '@rjsf/validator-ajv8';
import { 
  RJSFSchema, 
  UiSchema, 
  FieldTemplateProps, 
  ObjectFieldTemplateProps, 
  RegistryWidgetsType,
  FormContextType
 } from '@rjsf/utils';
import { Label } from '@/core/components/ui/label';


// --- Props Definition ---
interface SchemaDrivenFormProps<T = unknown> {
  schema: RJSFSchema;
  uiSchema?: UiSchema;
  formData: object;
  onFormChange: (data: object) => void;
  liveValidate?: boolean;
  widgets?: RegistryWidgetsType<T>;
  formContext?: FormContextType & T; // <-- Use the official type and our generic
}



// --- Custom Field Template (for better layout and labels) ---
function CustomFieldTemplate(props: FieldTemplateProps) {
  const { id, classNames, label, help, required, description, errors, children, schema } = props;

  if (props.hidden) {
    return <div className="hidden">{children}</div>;
  }
  
  const isCheckbox = schema.type === 'boolean' && (props.uiSchema?.['ui:widget'] === 'checkbox' || props.uiSchema?.['ui:widget'] === undefined);

  if (isCheckbox) {
      return <div className={classNames}>{children}</div>
  }

  return (
    <div className={classNames}>
      {label && (
        <Label htmlFor={id} className="block text-sm font-medium mb-1">
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}
      
      {description}
      
      {children}
      
      {errors}
      
      {help}
    </div>
  );
}

// --- Custom Object Field Template (for overall form layout) ---
function CustomObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  return (
    <div>
        {props.description && <p className="text-sm text-muted-foreground">{props.description}</p>}
        <div className="mt-4">
            {props.properties.map(element => (
                <div key={element.name} className="mb-4">
                    {element.content}
                </div>
            ))}
        </div>
    </div>
  );
}

// --- Custom Submit Button Template (to hide it) ---
// FIXED: The 'props' parameter was defined but never used, so it has been removed.
function HideSubmitButton() {
    return null;
}

/**
 * A reusable component that dynamically generates a form from a given JSON Schema.
 * It uses react-jsonschema-form with a shadcn/ui theme for a consistent look and feel.
 */
export default function SchemaDrivenForm<T>({ 
  schema, 
  uiSchema, 
  formData, 
  onFormChange, 
  liveValidate = false,
  widgets,
  formContext 
}: SchemaDrivenFormProps<T>) {

  const safeFormData = formData || {};

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={safeFormData}
      validator={validator}
      onChange={(e) => onFormChange(e.formData)}
      liveValidate={liveValidate}
      showErrorList={false}
      widgets={widgets}
      formContext={formContext}
      
      templates={{
        FieldTemplate: CustomFieldTemplate,
        ObjectFieldTemplate: CustomObjectFieldTemplate,
        ButtonTemplates: {
            SubmitButton: HideSubmitButton,
        }
      }}
    />
  );
}

================================================================================

File: components/publishing/GroupedFrontmatterFields.tsx
// src/components/publishing/GroupedFrontmatterFields.tsx
'use client';

import { useMemo } from 'react';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import SchemaDrivenForm from './SchemaDrivenForm';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/core/components/ui/accordion";

interface Group {
  title: string;
  fields: string[];
}
type StrictUiSchema = UiSchema & { 'ui:groups'?: Group[] };

interface GroupedFrontmatterFormProps {
  schema: RJSFSchema;
  uiSchema?: StrictUiSchema;
  formData: Record<string, unknown>;
  onFormChange: (newData: Record<string, unknown>) => void;
}

function createSubSchema(originalSchema: RJSFSchema, fields: string[]): RJSFSchema {
  const subSchema: RJSFSchema = { ...originalSchema, properties: {}, required: originalSchema.required?.filter(field => fields.includes(field)) };
  if (!subSchema.properties) subSchema.properties = {};
  for (const field of fields) {
    if (originalSchema.properties && originalSchema.properties[field]) {
      subSchema.properties[field] = originalSchema.properties[field];
    }
  }
  return subSchema;
}

export default function GroupedFrontmatterForm({
  schema,
  uiSchema,
  formData,
  onFormChange,
}: GroupedFrontmatterFormProps) {
  
  const { groups, ungroupedFields } = useMemo(() => {
    const definedGroups = uiSchema?.['ui:groups'] || [];
    const allSchemaFields = Object.keys(schema.properties || {});
    const fieldsInGroups = new Set(definedGroups.flatMap(g => g.fields));
    const remainingFields = allSchemaFields.filter(f => !fieldsInGroups.has(f));
    return { groups: definedGroups, ungroupedFields: remainingFields };
  }, [schema, uiSchema]);

  // FIXED: The handler now accepts the event from rjsf and extracts the formData.
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onFormChange(event.formData || {});
  };

  if (!schema.properties || Object.keys(schema.properties).length === 0) {
    return <p className="text-sm text-muted-foreground">This layout has no configurable fields.</p>;
  }

  return (
    <div className="border-t">
      <Accordion type="multiple" defaultValue={groups.map(g => g.title)} className="w-full">
        {groups.map((group) => {
          if (group.fields.length === 0) return null;
          return (
            <AccordionItem value={group.title} key={group.title}>
              <AccordionTrigger>{group.title}</AccordionTrigger>
              <AccordionContent className="pt-4">
                <SchemaDrivenForm
                  schema={createSubSchema(schema, group.fields)}
                  formData={formData}
                  onFormChange={handleChange}
                />
              </AccordionContent>
            </AccordionItem>
          );
        })}
      </Accordion>

      {ungroupedFields.length > 0 && (
        <div className="">
            <Accordion type='single' collapsible>

<AccordionItem value="item-1">                <AccordionTrigger>
                  Fields
                </AccordionTrigger>
                <AccordionContent>
<SchemaDrivenForm
            schema={createSubSchema(schema, ungroupedFields)}
            formData={formData}
            onFormChange={handleChange}
          />
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </div>
      )}
    </div>
  );
}

================================================================================

File: components/layout/ThreeColumnLayout.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';
import EditorHeader from '@/features/editor/components/EditorHeader';

interface ThreeColumnLayoutProps {
  leftSidebar: ReactNode;
  rightSidebar: ReactNode;
  children: ReactNode;
  headerActions?: ReactNode;
}

export default function ThreeColumnLayout({ leftSidebar, rightSidebar, children, headerActions }: ThreeColumnLayoutProps) {
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const isRightOpen = useUIStore((state) => state.sidebar.isRightOpen);

  return (
    <div className="flex h-screen w-full flex-col bg-muted/20">
      <EditorHeader actions={headerActions} />
      
      {/* This is now the positioning context for all three columns */}
      <div className="relative flex-1 overflow-hidden">
        
        
        {/* Left Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 left-0 z-20 h-full w-72 border-r bg-background transition-transform duration-300 ease-in-out',
            isLeftOpen ? 'translate-x-0' : '-translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {leftSidebar}
          </div>
        </aside>

        {/* Main Content: The layout is now controlled by padding */}
        <main
          className={cn(
            'h-full overflow-y-auto transition-all duration-300 ease-in-out',
            // When left sidebar is open, add left padding
            isLeftOpen ? 'lg:pl-72' : 'lg:pl-0',
            // When right sidebar is open, add right padding
            isRightOpen ? 'lg:pr-80' : 'lg:pr-0'
          )}
        >
          {children}
        </main>

        {/* Right Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 right-0 z-10 h-full w-80 border-l bg-background transition-transform duration-300 ease-in-out',
            isRightOpen ? 'translate-x-0' : 'translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {rightSidebar}
          </div>
        </aside>
      </div>
    </div>
  );
}

================================================================================

File: lib/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { Input } from 'gray-matter'; // Import GrayMatterOption and Input
//import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { MarkdownFrontmatter, ParsedMarkdownFile } from '@/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Signum focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: lib/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: lib/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: lib/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { LocalSiteData, ParsedMarkdownFile, Manifest } from '@/types';
import { parseMarkdownString } from './markdownParser';
import { flattenStructure } from '../core/services/fileTree.service';

async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const url = new URL(filePath, baseUrl).href;
  const response = await fetch(url, { cache: 'no-store' });
  if (!response.ok) {
    throw new Error(`Fetch failed for ${url}: ${response.statusText}`);
  }
  return response.text();
}

/**
 * Fetches and reconstructs an entire remote Signum site into the LocalSiteData format.
 * It fetches the manifest, then fetches all content files listed within it.
 * @param remoteSiteUrl The base URL of the remote Signum site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json, which is now the single source of truth.
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_signum/manifest.json');
    const manifest: Manifest = JSON.parse(manifestString);

    if (!manifest || !manifest.siteId || !manifest.structure) {
        throw new Error("Invalid manifest structure fetched from remote site.");
    }
    
    // 2. Collect all unique file paths from the manifest structure.
    const allPageNodes = flattenStructure(manifest.structure);
    const contentFilePaths = [...new Set(allPageNodes.map(node => node.path))];

    // 3. Fetch all content files in parallel.
    const contentFilesPromises = contentFilePaths.map(async (path) => {
        try {
            const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, `_signum/${path}`);
            const { frontmatter, content } = parseMarkdownString(rawMarkdown);
            const slug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
            return { slug, path, frontmatter, content };
        } catch (error) {
            console.warn(`Could not fetch or parse content file: ${path}`, error);
            return null; // Return null on failure for this specific file
        }
    });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];

    // 4. Construct the final LocalSiteData object.
    const finalSiteData: LocalSiteData = {
      siteId: `remote-${manifest.siteId}`, // Prefix to distinguish in local state
      manifest: manifest,
      contentFiles: validContentFiles,
    };

    return finalSiteData;

  } catch (error) {
    console.error(`CRITICAL ERROR fetching remote site data for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

