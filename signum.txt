FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: public, ios, node_modules
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html
================================================================================

File: types/index.ts
// src/types/index.ts
//import { RJSFSchema } from '@rjsf/utils'; // Import RJSFSchema

// Represents a node in the hierarchical site structure.
export interface StructureNode {
  type: 'page' | 'collection';
  title: string;
  path: string;
  slug: string;
  navOrder?: number;
  children?: StructureNode[];
  layout: string;
  // This property is specific to collection nodes, so it's optional.
  itemLayout?: string;
  // CORRECTED: Add an index signature to allow for arbitrary properties
  // from the theme's schema, making the node a flexible data container.
  [key: string]: unknown;
}

// Represents the theme configuration.
export interface ThemeConfig {
  name: string; // This is the theme's ID, e.g., "default"
  type: 'core' | 'contrib'; // The new type property
  config: {
    [key: string]: string | boolean | number;
  };
}

// The new, authoritative Manifest.
export interface Manifest {
  siteId: string;
  generatorVersion: string;
  title: string;
  description: string;
  author?: string;
  theme: ThemeConfig;
  structure: StructureNode[];
}

// A raw markdown file parsed from storage.
export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

// Represents a link used for rendering navigation menus.
// This is a derived type, not part of the core manifest data.
export interface NavLinkItem {
  href: string;
  label: string;
  isActive?: boolean;
  children?: NavLinkItem[];
}

// Represents the fields within a content file's frontmatter.
export interface MarkdownFrontmatter {
  title: string;
  // This allows any other string key, accommodating custom frontmatter.
  [key: string]: unknown; // 'unknown' is safer than 'any'. It forces type checks.
}

// The complete data for a site held in the app's state.
export interface LocalSiteData {
  siteId: string;
  manifest: Manifest;
  contentFiles: ParsedMarkdownFile[];
}

// The state and actions for the Zustand store.
export interface AppState {
  sites: LocalSiteData[];
  addSite: (site: LocalSiteData) => Promise<void>;
  updateManifest: (siteId: string, manifest: Manifest) => Promise<void>;
  addNewCollection: (siteId: string, name: string, slug: string, layout: string) => Promise<void>;
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string, layoutId: string) => Promise<boolean>;
  deleteSiteAndState: (siteId:string) => Promise<void>;
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
}

================================================================================

File: app/layout.tsx
// src/app/layout.tsx
'use client'; 

import { useEffect, useState, Suspense } from 'react';
import { useAppStore } from '@/stores/useAppStore';
import Navbar from '@/components/core/Navbar'; 
import Footer from '@/components/core/Footer';   
import './globals.css'; 
import { Toaster } from "@/components/ui/sonner"; 
import { ThemeProvider } from "@/components/core/ThemeProvider"; 

// Loading component to show during initialization or suspense
function AppLoadingIndicator() { // CORRECTED: Ensure it returns JSX
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading Signum...</p>
      </div>
    </div>
  ); // <<< MISSING RETURN WAS HERE
}


export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true); 
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]); 

  const showLoading = clientMounted && !isInitialized;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Signum - Decentralized Publishing</title>
        {/* Ensure no stray characters or whitespace directly in <head> */}
      </head>
      <body>
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
          <div className="flex flex-col min-h-screen bg-background text-foreground">
            {showLoading ? (
              <AppLoadingIndicator /> // Now correctly used
            ) : (
              <>
                <Navbar />
                <main className="flex-grow container mx-auto px-4 py-8 sm:px-6 lg:px-8"> 
                  <Suspense fallback={<AppLoadingIndicator />}>
                    {children}
                  </Suspense>
                </main>
                <Footer />
              </>
            )}
          </div>
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================================================================================

File: app/page.tsx
// src/app/page.tsx
'use client';

import Link from 'next/link';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';
import { PlusCircle, Edit3, Eye, Trash2, FilePlus2, ExternalLink } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { toast } from "sonner";

export default function HomePageDashboard() {
  const sites = useAppStore((state) => state.sites);
  const deleteSiteAndState = useAppStore((state) => state.deleteSiteAndState);
  const isInitialized = useAppStore((state) => state.isInitialized);

  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

  if (!isInitialized) {
    return (
        <div className="flex items-center justify-center h-full">
            <p>Loading sites...</p>
        </div>
    );
  }

  // CORRECTED: Filter the sites array to only include sites that have a valid manifest.
  // This prevents runtime errors if stale or malformed data is loaded from localStorage.
  const validSites = sites.filter(site => site && site.manifest);

  return (
    <div className="container mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-8 gap-4">
        <h1 className="text-3xl font-bold text-foreground">My Signum Sites (Local)</h1>
        <Button asChild size="lg">
          <Link href="/create-site">
            <FilePlus2 className="mr-2 h-5 w-5" /> Create New Site
          </Link>
        </Button>
      </div>

      {validSites.length === 0 ? (
        <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
          <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
          <p className="text-muted-foreground mb-4">
            You haven&apos;t created any sites. Click Create New Site to get started.
          </p>
          <Button asChild>
            <Link href="/create-site">
                <PlusCircle className="mr-2 h-4 w-4" /> Start Creating
            </Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {validSites.map((site) => (
            <div 
                key={site.siteId} 
                className="bg-card border border-border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between"
            >
              <div>
                <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.manifest.title}>
                  {site.manifest.title || "Untitled Site"}
                </h2>
                <p className="text-sm text-muted-foreground mb-1 line-clamp-2" title={site.manifest.description}>
                  {site.manifest.description || 'No description provided.'}
                </p>
                <p className="text-xs text-muted-foreground mb-4 break-all" title={site.siteId}>
                  ID: {site.siteId}
                </p>
              </div>
              <div className="mt-4 flex flex-col sm:flex-row sm:justify-start gap-2">
                <Button variant="outline" size="sm" asChild className="flex-1 sm:flex-none">
                  <Link href={`/${site.siteId}`} target="_blank" rel="noopener noreferrer">
                    <Eye className="mr-2 h-4 w-4" /> View
                  </Link>
                </Button>
                <Button variant="default" size="sm" asChild className="flex-1 sm:flex-none">
                  <Link href={`/edit/${site.siteId}`}>
                     <Edit3 className="mr-2 h-4 w-4" /> Edit
                  </Link>
                </Button>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" size="sm" className="flex-1 sm:flex-none">
                      <Trash2 className="mr-2 h-4 w-4" /> Delete
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This action cannot be undone. This will permanently delete the site
                        &quot;{site.manifest.title || 'this site'}&quot; and all its content from your local storage.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() => handleDeleteSite(site.siteId, site.manifest.title || 'Untitled Site')}
                        className="bg-destructive hover:bg-destructive/90 text-destructive-foreground"
                      >
                        Yes, delete site
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </div>
            </div>
          ))}
        </div>
      )}
       <footer className="mt-12 text-center text-sm text-muted-foreground">
        <p>Signum Local Client v0.1.0</p>
        <p>
          <Link href="https://github.com/your-repo/signum-client" target="_blank" rel="noopener noreferrer" className="hover:text-primary transition-colors">
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
      </footer>
    </div>
  );
}

================================================================================

File: app/globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: app/(publishing)/edit/[siteId]/layout.tsx
// src/app/(publishing)/edit/[siteId]/layout.tsx
'use client';

import Link from 'next/link';
import { useParams, usePathname, useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';
import { Settings, Eye, Home, PlusCircle, FolderPlus, UploadCloud, Palette } from 'lucide-react';
import FileTree from '@/components/publishing/FileTree';
import NewCollectionDialog from '@/components/publishing/NewCollectionDialog';
import { useEffect, useState, useCallback, useMemo } from 'react';
import { toast } from 'sonner';
import { exportSiteToZip } from '@/lib/siteExporter';
import { slugify } from '@/lib/utils';
import { StructureNode } from '@/types';
import { getAvailableLayouts, type ThemeLayout } from '@/lib/themeEngine';


const NEW_FILE_SLUG_MARKER = '_new';

export default function EditSiteLayout({ children }: { children: React.ReactNode }) {
  const params = useParams();
  const pathname = usePathname();
  const router = useRouter();
  const siteId = params.siteId as string;

  const site = useAppStore((state) => state.getSiteById(siteId));
  const updateManifest = useAppStore((state) => state.updateManifest);
  const addNewCollection = useAppStore((state) => state.addNewCollection);
  const [isPublishing, setIsPublishing] = useState(false);
  const [activePath, setActivePath] = useState<string | undefined>();
  const [availableCollectionLayouts, setAvailableCollectionLayouts] = useState<ThemeLayout[]>([]);

  const siteStructure = useMemo(() => site?.manifest.structure || [], [site?.manifest.structure]);

  useEffect(() => {
    // Fetch available layouts when the component mounts and the site data is available
    if (site) {
        getAvailableLayouts(site.manifest.theme.name, site.manifest.theme.type).then(layouts => {
            setAvailableCollectionLayouts(layouts.filter(l => l.type === 'collection'));
        });
    }
  }, [site]);

   useEffect(() => {
    const pathSegments = pathname.split('/');
    if (pathname.includes('/collection/')) {
        const slug = pathSegments[pathSegments.indexOf('collection') + 1];
        setActivePath(`content/${slug}`);
    } else if (pathname.includes('/content/')) {
        const contentPath = pathname.substring(pathname.indexOf('/content/') + 8).replace(/\/$/, '');
        const pathWithExt = `content/${contentPath}.md`;
        const existingFile = site?.contentFiles.find(f => f.path === pathWithExt);
        setActivePath(existingFile?.path);
    } else {
        setActivePath(undefined);
    }
  }, [pathname, site?.contentFiles]);


  const handleStructureChange = useCallback((reorderedNodes: StructureNode[]) => {
      if (!site) return;
      const newManifest = { ...site.manifest, structure: reorderedNodes };
      updateManifest(siteId, newManifest);
  }, [site, siteId, updateManifest]);

  const handleNavigateToNewFile = (parentPath: string = 'content') => {
    const parentSlugPart = parentPath === 'content' ? '' : parentPath.replace(/^content\/?/, '');
    const newFileRoute = `/edit/${siteId}/content/${parentSlugPart ? parentSlugPart + '/' : ''}${NEW_FILE_SLUG_MARKER}`;
    router.push(newFileRoute.replace(/\/\//g, '/'));
  };
  
   const handleCreateNewCollection = async (name: string, slug: string, layout: string) => {
    if (!site) return;
    await addNewCollection(siteId, name, slug, layout);
    toast.success(`Collection "${name}" created!`);
    router.push(`/edit/${siteId}/collection/${slug}`);
  };

  const handlePublishSite = async () => {
    if (!site) {
      toast.error("Site data not found. Cannot publish.");
      return;
    }
    setIsPublishing(true);
    toast.info("Generating site bundle for download...");
    try {
      const blob = await exportSiteToZip(site);
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${slugify(site.manifest.title || 'signum-site')}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      toast.success("Site bundle downloaded!");
    } catch (error) {
      console.error("Error publishing site to Zip:", error);
      toast.error(`Failed to generate Zip: ${(error as Error).message}`);
    } finally {
        setIsPublishing(false);
    }
  };
  
  const existingTopLevelSlugs = useMemo(() => site?.manifest.structure.map(c => c.slug) || [], [site?.manifest.structure]);

  if (!site) {
    return <div className="p-6">Loading site editor...</div>;
  }

  // UPDATED: Active link detection for new settings pages



  if (!site) {
    return <div className="p-6">Loading site editor...</div>;
  }

  const isSiteSettingsActive = pathname.startsWith(`/edit/${siteId}/settings/site`);
  const isAppearanceSettingsActive = pathname.startsWith(`/edit/${siteId}/settings/appearance`);

  return (
    <div className="flex h-screen bg-background overflow-hidden">
      <aside className="w-72 border-r bg-muted/40 p-4 flex flex-col shrink-0">
        <h2 className="text-xl font-semibold truncate mb-4" title={site.manifest.title}>
            {site.manifest.title || 'Site Editor'}
        </h2>

        <nav className="flex flex-col space-y-1 mb-4">
          <Button variant="ghost" asChild className={`justify-start ${isSiteSettingsActive ? 'bg-accent text-accent-foreground' : ''}`}>
            <Link href={`/edit/${siteId}/settings/site`}><Settings className="mr-2 h-4 w-4" /> Site Settings</Link>
          </Button>
          <Button variant="ghost" asChild className={`justify-start ${isAppearanceSettingsActive ? 'bg-accent text-accent-foreground' : ''}`}>
            <Link href={`/edit/${siteId}/settings/appearance`}><Palette className="mr-2 h-4 w-4" /> Appearance</Link>
          </Button>
        </nav>
        
        <div className="border-t pt-4 mt-4">
            <h3 className="px-3 text-xs font-semibold text-muted-foreground uppercase mb-2">Content</h3>
            <Button variant="ghost" onClick={() => handleNavigateToNewFile('content')} className="justify-start w-full">
              <PlusCircle className="mr-2 h-4 w-4" /> New Page
            </Button>
            <NewCollectionDialog 
                existingSlugs={existingTopLevelSlugs} 
                // CORRECTED: Pass the fetched layouts to the dialog.
                availableLayouts={availableCollectionLayouts}
                onSubmit={handleCreateNewCollection}
            >
                <Button variant="ghost" className="w-full justify-start">
                    <FolderPlus className="mr-2 h-4 w-4" /> New Collection
                </Button>
            </NewCollectionDialog>
        </div>

        <div className="flex-grow overflow-y-auto pr-1 -mr-1 mt-2">
          <FileTree 
            nodes={siteStructure} 
            baseEditPath={`/edit/${siteId}`}
            activePath={activePath}
            onFileCreate={handleNavigateToNewFile} 
            onStructureChange={handleStructureChange}
          />
        </div>

        <div className="mt-auto space-y-2 pt-4 border-t shrink-0">
            <Button variant="default" onClick={handlePublishSite} disabled={isPublishing} className="w-full">
              <UploadCloud className="mr-2 h-4 w-4" /> {isPublishing ? 'Publishing...' : 'Publish Site'}
            </Button>
            <Button variant="outline" asChild className="w-full">
                <Link href={`/${siteId}`} target="_blank"><Eye className="mr-2 h-4 w-4" /> View Site</Link>
            </Button>
            <Button variant="ghost" asChild className="w-full">
              <Link href="/"><Home className="mr-2 h-4 w-4" /> App Dashboard</Link>
            </Button>
        </div>
      </aside>
      <div className="flex-1 overflow-y-auto p-6">
        {children}
      </div>
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/page.tsx
// src/app/(publishing)/edit/[siteId]/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page now simply redirects to the site settings page by default.
export default function SiteEditorRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      router.replace(`/edit/${siteId}/settings/site`);
    }
  }, [siteId, router]);

  return (
    <div className="p-6 flex justify-center items-center h-full">
      <p>Redirecting to site settings...</p>
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/settings/appearance/page.tsx
// src/app/(publishing)/edit/[siteId]/settings/appearance/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import AppearanceSettingsForm from '@/components/publishing/AppearanceSettingsForm';
import { Button } from '@/components/ui/button';
import { Manifest, ThemeConfig } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
// CORRECTED: The getAvailableThemes function is no longer needed or available.
import { type ThemeInfo } from '@/lib/themeEngine';

// CORRECTED: Define the available themes as a hardcoded constant.
// This is the single source of truth for the UI and removes the async dependency.
const AVAILABLE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', type: 'core' },
  // { id: 'docs', name: 'Docs Theme', type: 'core' }, // Add future themes here
];

export default function AppearanceSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);
  const isStoreInitialized = useAppStore(state => state.isInitialized);

  // CORRECTED: selectedThemeInfo is now the primary state for the selected theme object.
  const [selectedThemeInfo, setSelectedThemeInfo] = useState<ThemeInfo | null>(null);
  const [themeConfig, setThemeConfig] = useState<ThemeConfig['config']>({});
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  // CORRECTED: This useEffect no longer needs to fetch themes. It now correctly
  // sets the selected theme based on the site data and the hardcoded list.
  useEffect(() => {
    if (site?.manifest.theme) {
      const themeTypeFromManifest = site.manifest.theme.type || 'core'; // Handle old data gracefully
      const currentThemeInfo = AVAILABLE_THEMES.find(t => 
        t.id === site.manifest.theme.name && t.type === themeTypeFromManifest
      );
      
      setSelectedThemeInfo(currentThemeInfo || null);
      setThemeConfig(site.manifest.theme.config);
      setHasChanges(false);
    }
  }, [site]);
  
  const handleConfigChange = useCallback((newConfig: ThemeConfig['config']) => {
    setThemeConfig(newConfig);
    setHasChanges(true);
  }, []);

  const handleThemeChange = (themeId: string) => {
    const theme = AVAILABLE_THEMES.find(t => t.id === themeId);
    if (theme) {
        setSelectedThemeInfo(theme);
        setThemeConfig({});
        setHasChanges(true);
    }
  };

  const handleSave = async () => {
    if (!site || !site.manifest || !selectedThemeInfo) return;
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      theme: {
        name: selectedThemeInfo.id,
        type: selectedThemeInfo.type,
        config: themeConfig,
      },
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Appearance settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving appearance settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!isStoreInitialized || !site) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  return (
    <div className="space-y-6 max-w-2xl">
      <div>
        <h1 className="text-2xl font-bold">Appearance</h1>
        <p className="text-muted-foreground">Customize the visual style of your site.</p>
      </div>

      <div className="border-t pt-6 space-y-6">
        <div>
            <Label htmlFor="theme-select">Active Theme</Label>
            <Select value={selectedThemeInfo?.id || ''} onValueChange={handleThemeChange}>
                <SelectTrigger id="theme-select" className="mt-1">
                    <SelectValue placeholder="Select a theme..." />
                </SelectTrigger>
                <SelectContent>
                    {/* The dropdown now renders from the reliable constant. */}
                    {AVAILABLE_THEMES.map(theme => (
                        <SelectItem key={`${theme.type}-${theme.id}`} value={theme.id}>
                            {theme.name}
                        </SelectItem>
                    ))}
                </SelectContent>
            </Select>
        </div>
        
        {selectedThemeInfo && (
            <AppearanceSettingsForm 
                themeId={selectedThemeInfo.id}
                themeType={selectedThemeInfo.type}
                themeConfig={themeConfig}
                onConfigChange={handleConfigChange}
            />
        )}
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Appearance'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/settings/site/page.tsx
// src/app/(publishing)/edit/[siteId]/settings/site/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import SiteSettingsForm from '@/components/publishing/SiteSettingsForm';
import { Button } from '@/components/ui/button';
import { Manifest } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import Link from 'next/link';

export default function SiteSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);
  const isStoreInitialized = useAppStore(state => state.isInitialized);

  const [formData, setFormData] = useState({ title: '', description: '', author: '' });
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  useEffect(() => {
    if (site?.manifest) {
      setFormData({
        title: site.manifest.title,
        description: site.manifest.description,
        author: site.manifest.author || '',
      });
      setHasChanges(false);
    }
  }, [site]);
  
  const handleFormChange = useCallback((newData: typeof formData) => {
    setFormData(newData);
    setHasChanges(true);
  }, []);

  const handleSave = async () => {
    if (!site || !site.manifest) return;
    if (!formData.title.trim()) {
      toast.error("Site title cannot be empty.");
      return;
    }
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      title: formData.title.trim(),
      description: formData.description.trim(),
      author: formData.author.trim(),
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Site settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving site settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!isStoreInitialized || (site && !formData.title && !site.manifest.title)) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  if (!site) {
    return (
      <div className="p-6 text-center">
        <h2 className="text-xl font-semibold">Site Not Found</h2>
        <Button asChild variant="outline" className="mt-4">
          <Link href="/">Go to Dashboard</Link>
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-6 max-w-2xl">
      <div>
        <h1 className="text-2xl font-bold">Site Settings</h1>
        <p className="text-muted-foreground">Manage the core details of your website.</p>
      </div>
      <div className="border-t pt-6">
        <SiteSettingsForm 
          formData={formData}
          onFormChange={handleFormChange} 
        />
      </div>
      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/(publishing)/edit/[siteId]/collection/[collectionName]/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import { useCallback, useMemo, useState, useEffect } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from 'sonner';
import { FileText, PlusCircle } from 'lucide-react';
import { StructureNode } from '@/types';
import { getAvailableLayouts, getLayoutSchema, type ThemeLayout } from '@/lib/themeEngine';
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';
import { RJSFSchema } from '@rjsf/utils';

type CollectionFrontmatter = {
    title: string;
    description?: string;
    [key: string]: unknown;
};

export default function EditCollectionPage() {
    const params = useParams();
    const siteId = params.siteId as string;
    const collectionName = params.collectionName as string;

    const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
    const updateManifest = useAppStore(state => state.updateManifest);

    const collectionPath = `content/${collectionName}`;

    // --- State Hooks ---
    const [selectedCollectionLayout, setSelectedCollectionLayout] = useState('');
    const [selectedItemLayout, setSelectedItemLayout] = useState('');
    const [availableCollectionLayouts, setAvailableCollectionLayouts] = useState<ThemeLayout[]>([]);
    const [availablePageLayouts, setAvailablePageLayouts] = useState<ThemeLayout[]>([]);
    const [collectionFrontmatter, setCollectionFrontmatter] = useState<CollectionFrontmatter>({ title: '' });
    const [formSchema, setFormSchema] = useState<RJSFSchema | null>(null);

    // --- Memoized Selectors ---
    const collectionNode = useMemo(() => {
        return site?.manifest.structure.find(node => node.path === collectionPath);
    }, [site, collectionPath]);

    // --- Effects ---
    useEffect(() => {
        if (site && collectionNode) {
            setSelectedCollectionLayout(collectionNode.layout);
            setSelectedItemLayout(collectionNode.itemLayout as string || 'page');
            
            setCollectionFrontmatter({
                ...collectionNode,
                title: collectionNode.title,
                description: collectionNode.description as string || '',
            });

             getAvailableLayouts(site.manifest.theme.name, site.manifest.theme.type).then(layouts => {
                setAvailableCollectionLayouts(layouts.filter(l => l.type === 'collection'));
                setAvailablePageLayouts(layouts.filter(l => l.type === 'page'));
            });
        }
    }, [collectionNode, site]);

    useEffect(() => {
        async function loadSchema() {
            if (site && selectedCollectionLayout) {
                const schemaData = await getLayoutSchema(site.manifest.theme.name, site.manifest.theme.type, selectedCollectionLayout);
                setFormSchema(schemaData?.schema || null);
            }
        }
        loadSchema();
    }, [selectedCollectionLayout, site]);

    // --- Event Handlers ---
    const handleSaveChanges = async () => {
        if (!site || !collectionNode) {
            toast.error("Cannot save, collection not found.");
            return;
        }

        const updateNode = (nodes: StructureNode[]): StructureNode[] => {
            return nodes.map(node => {
                if (node.path === collectionPath) {
                    return { 
                        ...node, 
                        ...collectionFrontmatter,
                        layout: selectedCollectionLayout,
                        itemLayout: selectedItemLayout,
                    };
                }
                return node;
            });
        };
        
        const newStructure = updateNode(site.manifest.structure);
        const newManifest = { ...site.manifest, structure: newStructure };
        await updateManifest(siteId, newManifest);

        toast.success(`Collection "${collectionFrontmatter.title}" updated successfully!`);
    };
    
    if (!site || !collectionNode) {
        return <div>Loading collection data...</div>;
    }

    return (
        <div className="flex flex-row h-full gap-6">
            <main className="flex-1 flex flex-col">
                <div className="flex justify-between items-center mb-4">
                    <h1 className="text-2xl font-bold">Editing Collection: {collectionNode.title}</h1>
                    <Button asChild>
                        <Link href={`/edit/${siteId}/content/${collectionName}/_new`}>
                            <PlusCircle className="mr-2 h-4 w-4" /> New Item
                        </Link>
                    </Button>
                </div>
                <div className="flex-grow p-4 border rounded-lg bg-background overflow-y-auto">
                    <h2 className="text-lg font-semibold mb-3">Items in this Collection</h2>
                    {collectionNode.children && collectionNode.children.length > 0 ? (
                        <ul className="space-y-2">
                            {collectionNode.children.map((item: StructureNode) => {
                                // CORRECTED: Generate the link from the full relative path to handle nested content correctly.
                                const relativeContentPath = item.path.replace(/^content\//, '').replace(/\.md$/, '');
                                return (
                                    <li key={item.path}>
                                        <Link href={`/edit/${siteId}/content/${relativeContentPath}`} className="flex items-center p-2 rounded-md hover:bg-muted transition-colors">
                                            <FileText className="h-4 w-4 mr-3 text-muted-foreground" />
                                            <span className="font-medium">{item.title || item.slug}</span>
                                        </Link>
                                    </li>
                                );
                            })}
                        </ul>
                    ) : (
                        <p className="text-muted-foreground text-center py-8">No items in this collection yet.</p>
                    )}
                </div>
            </main>

            <aside className="w-80 border-l bg-muted/20 p-4 space-y-6 overflow-y-auto h-full shrink-0">
                <h2 className="text-lg font-semibold border-b pb-2">Collection Settings</h2>
                
                <div>
                    <Label htmlFor="collection-layout-select">Listing Page Layout</Label>
                    <Select value={selectedCollectionLayout} onValueChange={setSelectedCollectionLayout}>
                        <SelectTrigger id="collection-layout-select"><SelectValue placeholder="Select a layout..." /></SelectTrigger>
                        <SelectContent>
                            {availableCollectionLayouts.map(layout => (
                              <SelectItem key={layout.id} value={layout.id}>{layout.name}</SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                </div>
                
                <div>
                    <Label htmlFor="item-layout-select">Default Layout for Items</Label>
                    <Select value={selectedItemLayout} onValueChange={setSelectedItemLayout}>
                        <SelectTrigger id="item-layout-select"><SelectValue placeholder="Select a layout..." /></SelectTrigger>
                        <SelectContent>
                            {availablePageLayouts.map(layout => (
                              <SelectItem key={layout.id} value={layout.id}>{layout.name}</SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                    <p className="text-xs text-muted-foreground mt-1">This layout will be used for all new items created in this collection.</p>
                </div>
                
                {formSchema ? (
                    <SchemaDrivenForm
                        schema={formSchema}
                        formData={collectionFrontmatter}
                        onFormChange={(data) => setCollectionFrontmatter(data as CollectionFrontmatter)}
                    />
                ) : (
                    <p className="text-sm text-muted-foreground">Select a layout to see its settings.</p>
                )}

                <Button onClick={handleSaveChanges} className="w-full">Save Collection Settings</Button>
            </aside>
        </div>
    );
}

================================================================================

File: app/(publishing)/edit/[siteId]/content/[[...slug]]/page.tsx
// src/app/(publishing)/edit/[siteId]/content/[[...slug]]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import MarkdownEditor from '@/components/publishing/MarkdownEditor';
import FrontmatterSidebar from '@/components/publishing/FrontmatterSidebar';
import { Button } from '@/components/ui/button';
import type { MarkdownFrontmatter } from '@/types';
import { useEffect, useState, useCallback, useMemo, useRef } from 'react';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { slugify } from '@/lib/utils';
import { toast } from "sonner";
import { Trash2, Save, Cloud, AlertCircle, CheckCircle } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Link } from '@/components/ui/link';
import { findNodeByPath } from '@/lib/fileTreeUtils';

const NEW_FILE_SLUG_MARKER = '_new';
const AUTOSAVE_DELAY = 2500;

type AutoSaveStatus = "unsaved" | "saving" | "saved" | "error";

export default function EditContentPage() {
  const params = useParams();
  const router = useRouter();
  const siteId = params.siteId as string;
  
  const slugSegments = useMemo(() => (params.slug as string[]) || [], [params.slug]);
  const isNewFileIntent = useMemo(() => slugSegments.includes(NEW_FILE_SLUG_MARKER), [slugSegments]);
  
  const parentPathForNewFile = useMemo(() => {
    if (!isNewFileIntent) return 'content';
    const newMarkerIndex = slugSegments.indexOf(NEW_FILE_SLUG_MARKER);
    const parentSlug = newMarkerIndex > 0 ? slugSegments.slice(0, newMarkerIndex).join('/') : '';
    return parentSlug ? `content/${parentSlug}` : 'content';
  }, [slugSegments, isNewFileIntent]);

  const targetPathForExistingFile = useMemo(() => {
    if (isNewFileIntent) return '';
    const pathParts = slugSegments.filter(s => s !== NEW_FILE_SLUG_MARKER);
    if (pathParts.length === 0 && siteId) return 'content/index.md';
    return `content/${pathParts.join('/')}.md`;
  }, [slugSegments, isNewFileIntent, siteId]);

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const addOrUpdateContentFileAction = useAppStore(state => state.addOrUpdateContentFile);
  const deleteContentFileAction = useAppStore(state => state.deleteContentFileAndState);

  const [currentFrontmatter, setCurrentFrontmatter] = useState<MarkdownFrontmatter | null>(null);
  const [currentBodyContent, setCurrentBodyContent] = useState<string>('');
  const [currentFilePath, setCurrentFilePath] = useState<string>('');
  const [layoutId, setLayoutId] = useState<string>('');
  const [slug, setSlug] = useState<string>('');

  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [isNewFileMode, setIsNewFileMode] = useState(false);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [autoSaveStatus, setAutoSaveStatus] = useState<AutoSaveStatus>("saved");

  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const frontmatterRef = useRef<MarkdownFrontmatter | null>(null);
  useEffect(() => {
    frontmatterRef.current = currentFrontmatter;
  }, [currentFrontmatter]);

  const handleSaveContent = useCallback(async (isAutosave: boolean = false) => {
    if (!currentFrontmatter || !siteId || !layoutId) {
      if (!isAutosave) toast.error("Cannot save: Critical data is missing.");
      setAutoSaveStatus("error");
      return;
    }
    if (!currentFrontmatter.title || !(currentFrontmatter.title as string).trim()) {
      if (!isAutosave) toast.error("Title is required to save.");
      setAutoSaveStatus(isNewFileMode ? "unsaved" : "error");
      return;
    }

    if (!isAutosave) setIsSaving(true);
    setAutoSaveStatus("saving");

    let filePathToSave = currentFilePath;

    if (isNewFileMode) {
      if (!slug || !slug.trim()) {
        if (!isAutosave) toast.error("A valid slug is required. It is usually generated from the title.");
        setAutoSaveStatus("unsaved");
        if (!isAutosave) setIsSaving(false);
        return;
      }
      
      filePathToSave = `${parentPathForNewFile}/${slug}.md`.replace(/\/\//g, '/');
      
      if (site?.contentFiles.some(f => f.path === filePathToSave)) {
        if (!isAutosave) toast.error(`A file with the slug "${slug}" already exists in this location.`);
        setAutoSaveStatus("error");
        if (!isAutosave) setIsSaving(false);
        return;
      }
    }

    const rawMarkdownToSave = stringifyToMarkdown(currentFrontmatter, currentBodyContent);

    try {
      const success = await addOrUpdateContentFileAction(siteId, filePathToSave, rawMarkdownToSave, layoutId);
      if (success) {
        if (!isAutosave) toast.success(`Content "${currentFrontmatter.title}" saved successfully!`);
        setHasUnsavedChanges(false);
        setAutoSaveStatus("saved");
        
        if (isNewFileMode) {
          setIsNewFileMode(false);
          setCurrentFilePath(filePathToSave);
          const newEditPathSegments = filePathToSave.replace(/^content\//, '').replace(/\.md$/, '');
          router.replace(`/edit/${siteId}/content/${newEditPathSegments}`);
        }
      } else {
        if (!isAutosave) toast.error("Failed to save: Invalid data. Check console for details.");
        setAutoSaveStatus("error");
      }
    } catch (error) {
      console.error("Error saving content:", error);
      if (!isAutosave) toast.error(`Failed to save content: ${(error as Error).message}`);
      setAutoSaveStatus("error");
    } finally {
      if (!isAutosave) setIsSaving(false);
    }
  }, [
    currentFrontmatter, siteId, currentFilePath, slug, isNewFileMode, 
    parentPathForNewFile, site?.contentFiles, currentBodyContent, 
    addOrUpdateContentFileAction, router, layoutId
  ]);


  const triggerAutoSave = useCallback(() => {
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }
    if (isNewFileMode && (!(currentFrontmatter?.title as string)?.trim() || !slug.trim())) {
        setAutoSaveStatus("unsaved");
        return;
    }
    if (!hasUnsavedChanges && autoSaveStatus !== "error") {
        setAutoSaveStatus("saved");
        return;
    }

    setAutoSaveStatus("unsaved");
    autoSaveTimeoutRef.current = setTimeout(async () => {
      if (isNewFileMode && (!(currentFrontmatter?.title as string)?.trim() || !slug.trim())) {
        console.log("Autosave for new file skipped: title or slug not ready.");
        setAutoSaveStatus("unsaved");
        return;
      }
      await handleSaveContent(true);
    }, AUTOSAVE_DELAY);
  }, [
    isNewFileMode, hasUnsavedChanges, currentFrontmatter?.title, slug,
    autoSaveStatus, handleSaveContent
  ]);


  useEffect(() => {
    setIsLoading(true);
    setHasUnsavedChanges(false);
    setAutoSaveStatus("saved");

    if (site) {
      if (isNewFileIntent) {
        setIsNewFileMode(true);
        const parentNode = findNodeByPath(site.manifest.structure, parentPathForNewFile);
        const newFileLayout = parentNode?.itemLayout as string || 'page';
        setLayoutId(newFileLayout);

        setCurrentFrontmatter({
          title: '',
          date: new Date().toISOString().split('T')[0],
          status: 'draft',
        });
        setCurrentBodyContent('');
        setSlug('');
        setCurrentFilePath('');
        setIsLoading(false);
      } else {
        setIsNewFileMode(false);
        const fileNode = findNodeByPath(site.manifest.structure, targetPathForExistingFile);
        const existingFile = site.contentFiles.find(f => f.path === targetPathForExistingFile);

        if (existingFile && fileNode) {
          setLayoutId(fileNode.layout);
          setCurrentFrontmatter(existingFile.frontmatter);
          setCurrentBodyContent(existingFile.content || '');
          setCurrentFilePath(existingFile.path);
          setSlug(existingFile.slug);
        } else {
          toast.error(`File or its manifest entry not found: ${targetPathForExistingFile}`);
          setCurrentFrontmatter(null);
          setCurrentBodyContent('');
          setLayoutId('');
          setSlug('');
        }
        setIsLoading(false);
      }
    } else if (useAppStore.getState().isInitialized && siteId) {
        toast.error(`Site with ID ${siteId} not found.`);
        setCurrentFrontmatter(null);
        setIsLoading(false);
    }
  }, [site, siteId, targetPathForExistingFile, isNewFileIntent, parentPathForNewFile]);


  useEffect(() => {
    if (!isLoading && hasUnsavedChanges) {
      triggerAutoSave();
    }
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, [currentFrontmatter, currentBodyContent, isLoading, hasUnsavedChanges, triggerAutoSave]);


  const handleFrontmatterChange = useCallback((newFrontmatter: MarkdownFrontmatter) => {
    const oldTitle = (frontmatterRef.current?.title as string) || '';
    const newTitle = (newFrontmatter.title as string) || '';

    if (isNewFileMode && slugify(oldTitle) === slug) {
        setSlug(slugify(newTitle));
    }

    setCurrentFrontmatter(newFrontmatter);
    setHasUnsavedChanges(true);
    setAutoSaveStatus("unsaved");
  }, [isNewFileMode, slug]); // slug is a dependency to ensure we have the latest value

  const handleBodyChange = useCallback((newBody: string) => {
    setCurrentBodyContent(newBody);
    setHasUnsavedChanges(true);
    setAutoSaveStatus("unsaved");
  }, []);

  const handleSlugChange = useCallback((newSlug: string) => {
    if (isNewFileMode) {
        setSlug(slugify(newSlug));
        setHasUnsavedChanges(true);
        setAutoSaveStatus("unsaved");
    }
  }, [isNewFileMode]);


  const handleDeleteContentFile = async () => {
    if (isNewFileMode || !currentFilePath || !site || !currentFrontmatter) {
        toast.info("Cannot delete an unsaved new file.");
        return;
    }
    try {
        await deleteContentFileAction(siteId, currentFilePath);
        toast.success(`File "${currentFrontmatter.title || currentFilePath}" deleted.`);
        const parentNodePath = currentFilePath.substring(0, currentFilePath.lastIndexOf('/'));
        const parentNode = findNodeByPath(site.manifest.structure, parentNodePath);
        if (parentNode?.type === 'collection') {
            router.push(`/edit/${siteId}/collection/${parentNode.slug}`);
        } else {
            router.push(`/edit/${siteId}/settings/site`);
        }
    } catch (error) {
        toast.error(`Failed to delete file: ${(error as Error).message}`);
        console.error("Error deleting file:", error);
    }
  };

  const renderAutoSaveIndicator = () => {
    switch (autoSaveStatus) {
      case "saving":
        return <><Cloud className="h-4 w-4 mr-1.5 animate-pulse text-blue-500" /> Saving...</>;
      case "saved":
        return <><CheckCircle className="h-4 w-4 mr-1.5 text-green-500" /> Saved</>;
      case "unsaved":
        return <><Save className="h-4 w-4 mr-1.5 text-amber-500" /> Unsaved changes</>;
      case "error":
        return <><AlertCircle className="h-4 w-4 mr-1.5 text-red-500" /> Save error!</>;
      default:
        return null;
    }
  };

  if (isLoading) {
    return <div className="p-6 flex justify-center items-center min-h-[calc(100vh-128px)]"><p>Loading editor...</p></div>;
  }
  if (!currentFrontmatter && !isNewFileMode && !isLoading) {
    return (
        <div className="p-6 text-center">
            <h2 className="text-xl font-semibold mb-4">Content Not Found</h2>
            <p className="text-muted-foreground mb-4">
            The content for path &quot;{targetPathForExistingFile.replace('content/', '')}&quot; could not be loaded. It may have been deleted or there could be an issue with your site&apos;s manifest.
            </p>
            <Button asChild variant="outline">
                <Link href={`/edit/${siteId}/settings/site`}>Go to Site Editor Home</Link>
            </Button>
        </div>
    );
  }

  return (
    <div className="flex flex-row h-full">
      <main className="flex-1 flex flex-col p-6 pr-0 overflow-hidden">
        <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-2 shrink-0">
          <h1 className="text-xl font-bold truncate">
            {isNewFileMode ? 'Create New Content' : `Edit: ${currentFrontmatter?.title || slug || 'Content'}`}
          </h1>
          <div className="flex items-center gap-2">
            <div className="text-sm text-muted-foreground flex items-center min-w-[120px]">
                {renderAutoSaveIndicator()}
            </div>
            {!isNewFileMode && (
                <AlertDialog>
                    <AlertDialogTrigger asChild>
                        <Button variant="outline" size="sm" className="text-destructive border-destructive hover:bg-destructive/10 hover:text-destructive focus-visible:ring-destructive/50">
                            <Trash2 className="h-4 w-4 mr-1.5" /> Delete
                        </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent> 
                        <AlertDialogHeader>
                        <AlertDialogTitle>Delete this content file?</AlertDialogTitle>
                        <AlertDialogDescription>
                            Are you sure you want to delete &quot;{currentFrontmatter?.title || currentFilePath}&quot;? This action cannot be undone.
                        </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={handleDeleteContentFile} className="bg-destructive hover:bg-destructive/90">
                            Yes, Delete File
                        </AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialog>
            )}
            <Button 
              onClick={() => handleSaveContent(false)}
              disabled={isSaving || (isNewFileMode && (!(currentFrontmatter?.title as string)?.trim() || !slug.trim()))}
              size="sm"
              title={isNewFileMode && (!(currentFrontmatter?.title as string)?.trim() || !slug.trim()) ? "Enter a title to enable saving" : "Save changes"}
            >
              <Save className="h-4 w-4 mr-1.5" />
              {isSaving ? 'Saving...' : 'Save Now'}
            </Button>
          </div>
        </div>
        {currentFrontmatter ? (
             <div className="flex-grow overflow-y-auto">
                <MarkdownEditor
                    key={currentFilePath || 'new-file-editor'}
                    initialValue={currentBodyContent}
                    onChange={handleBodyChange}
                />
            </div>
        ) : (
            <div className="flex-grow flex items-center justify-center text-muted-foreground">
                <p>Initializing editor...</p>
            </div>
        )}
      </main>
      {currentFrontmatter && site && (
        <FrontmatterSidebar
            frontmatter={currentFrontmatter}
            onFrontmatterChange={handleFrontmatterChange}
            layoutId={layoutId}
            themeId={site.manifest.theme.name}
            themeType={site.manifest.theme.type}
            isNewFileMode={isNewFileMode}
            slug={slug}
            onSlugChange={handleSlugChange}
        />
      )}
    </div>
  );
}

================================================================================

File: app/(publishing)/create-site/page.tsx
// src/app/(publishing)/create-site/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/stores/useAppStore';
import { LocalSiteData, ParsedMarkdownFile, MarkdownFrontmatter, StructureNode } from '@/types';
import { Button } from '@/components/ui/button';
import { generateSiteId } from '@/lib/utils';
import { toast } from "sonner";
import { getLayoutSchema, type ThemeInfo } from '@/lib/themeEngine';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

// CORRECTED: Define the available CORE themes as a hardcoded constant.
// This is the single source of truth for this page.
const CORE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', type: 'core' },
  // { id: 'docs', name: 'Docs Theme', type: 'core' }, // Add the docs theme here when ready
];

export default function CreateSitePage() {
  const router = useRouter();
  const addSite = useAppStore((state) => state.addSite);

  // --- State Hooks ---
  const [siteTitle, setSiteTitle] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  // CORRECTED: Initialize state directly from the constant. No useEffect needed.
  const [selectedThemeInfo, setSelectedThemeInfo] = useState<ThemeInfo | null>(CORE_THEMES[0] || null);

  // --- Event Handlers ---
  const handleSubmit = async () => {
    if (!siteTitle.trim() || !selectedThemeInfo) {
      toast.error('Site title and a theme are required.');
      return;
    }
    setIsLoading(true);

    const newSiteId = generateSiteId(siteTitle);
    const homepageLayoutId = 'page'; // The homepage is always a standard page for new sites.

    // 1. Fetch the 'page' layout's schema from the selected theme to get default frontmatter.
    const layoutSchemaData = await getLayoutSchema(selectedThemeInfo.id, selectedThemeInfo.type, homepageLayoutId);
    const schemaProperties = layoutSchemaData?.itemSchema?.properties || {};

    const defaultFrontmatter: MarkdownFrontmatter = {
        title: 'Welcome to your new site!',
    };

    for (const [key, prop] of Object.entries(schemaProperties)) {
        if (typeof prop === 'object' && prop !== null && 'default' in prop && defaultFrontmatter[key] === undefined) {
            defaultFrontmatter[key] = prop.default;
        }
    }
     if (!defaultFrontmatter.date) {
        defaultFrontmatter.date = new Date().toISOString().split('T')[0];
    }

    // 2. Create the default index.md file content
    const defaultIndexBody = `# Welcome to ${siteTitle}\n\nThis is your new site's homepage. Start editing!`;
    const defaultIndexFile: ParsedMarkdownFile = {
        slug: 'index',
        path: 'content/index.md',
        frontmatter: defaultFrontmatter,
        content: defaultIndexBody,
    };
    
    // 3. Create the initial structure node for the site manifest
    const indexStructureNode: StructureNode = {
        type: 'page',
        title: 'Home',
        path: 'content/index.md',
        slug: 'index',
        navOrder: 0,
        layout: homepageLayoutId,
    };

    // 4. Construct the final data object
    const newSiteData: LocalSiteData = {
      siteId: newSiteId,
      manifest: {
        siteId: newSiteId,
        generatorVersion: 'SignumClient/1.2.0',
        title: siteTitle.trim(),
        description: siteDescription.trim(),
        theme: {
          name: selectedThemeInfo.id,
          type: selectedThemeInfo.type,
          config: {},
        },
        structure: [indexStructureNode],
      },
      contentFiles: [defaultIndexFile],
    };

    try {
      await addSite(newSiteData);
      toast.success(`Site "${siteTitle}" created successfully!`);
      router.push(`/edit/${newSiteId}/content/index`);
    } catch (error) {
      console.error("Error creating site:", error);
      toast.error("Failed to create site.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-2xl">
      <div className="space-y-6">
        <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Create a New Site</h1>
            <Button onClick={() => router.push('/')} variant="outline">Cancel</Button>
        </div>

        <div className="space-y-4 p-6 border rounded-lg">
            <h2 className="text-lg font-semibold">Site Details</h2>
            <div>
                <Label htmlFor="site-title">Site Title</Label>
                <Input
                    id="site-title"
                    value={siteTitle}
                    onChange={(e) => setSiteTitle(e.target.value)}
                    placeholder="My Awesome Project"
                    required
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="site-description">Site Description (Optional)</Label>
                <Textarea
                    id="site-description"
                    value={siteDescription}
                    onChange={(e) => setSiteDescription(e.target.value)}
                    placeholder="A short and catchy description of your new site."
                    rows={3}
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="theme-select">Theme</Label>
                <Select 
                    value={selectedThemeInfo?.id || ''} 
                    onValueChange={(themeId) => {
                        const theme = CORE_THEMES.find(t => t.id === themeId);
                        if(theme) setSelectedThemeInfo(theme);
                    }} 
                >
                    <SelectTrigger id="theme-select" className="mt-1">
                        <SelectValue placeholder="Select a theme..." />
                    </SelectTrigger>
                    <SelectContent>
                        {CORE_THEMES.map(theme => (
                            <SelectItem key={theme.id} value={theme.id}>
                                {theme.name}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                 <p className="text-xs text-muted-foreground mt-1">
                    Choose the overall design for your site. You can change this later on the Appearance page.
                </p>
            </div>
        </div>

        <div className="flex justify-end">
            <Button onClick={handleSubmit} disabled={isLoading || !siteTitle.trim() || !selectedThemeInfo} size="lg">
                {isLoading ? 'Creating...' : 'Create Site'}
            </Button>
        </div>
      </div>
    </div>
  );
}

================================================================================

File: app/(browsing)/[siteId]/layout.tsx
// src/app/(browsing)/[siteId]/layout.tsx
'use client';

// Most imports can be removed as this layout is now just a shell.
import Link from 'next/link';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';

export default function SiteBrowsingLayout({ children }: { children: React.ReactNode; }) {
  // The complex logic for fetching data and building nav links is now handled by the page component.
  // This layout can be a simple pass-through or contain a minimal "back to dashboard" frame.
  const isInitialized = useAppStore(state => state.isInitialized);

  if (!isInitialized) {
    return <div className="p-4 text-center">Initializing...</div>;
  }

  return (
    <>
      {/* This top-level navbar is part of the Signum App UI, not the browsed site's UI */}
      <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur-sm">
        <div className="container flex h-14 items-center justify-end">
          <Button asChild variant="outline" size="sm">
            <Link href="/">Back to Signum Dashboard</Link>
          </Button>
        </div>
      </header>
      {/* The page component will render the full themed site below this bar */}
      {children}
    </>
  );
}

================================================================================

File: app/(browsing)/[siteId]/[[...slug]]/page.tsx
// src/app/(browsing)/[siteId]/[[...slug]]/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useEffect, useState, useMemo } from 'react';
//import { marked } from 'marked';
import * as localSiteFs from '@/lib/localSiteFs';
import { fetchRemoteSiteData } from '@/lib/remoteSiteFetcher';
import type { LocalSiteData } from '@/types';
import { Button } from '@/components/ui/button';
import { AlertTriangle } from 'lucide-react';
import { parseSiteIdentifier, type ParsedSiteIdentifier } from '@/lib/browsingUtils';
import Link from 'next/link';
import { resolvePageContent, PageType } from '@/lib/pageResolver';
import { render as renderWithTheme } from '@/lib/themeEngine';

enum PageRenderState { Loading, Display, NotFound, Error }

export default function CatchAllSitePage() {
  const paramsHook = useParams();
  const [siteData, setSiteData] = useState<LocalSiteData | null | undefined>(undefined);
  const [renderState, setRenderState] = useState<PageRenderState>(PageRenderState.Loading);
  const [pageHtmlContent, setPageHtmlContent] = useState<string>("");
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [pageMetaTitle, setPageMetaTitle] = useState<string>("Loading...");
  const [parsedPageIdentifier, setParsedPageIdentifier] = useState<ParsedSiteIdentifier | null>(null);

  const siteIdParamValue = useMemo(() => paramsHook.siteId as string, [paramsHook.siteId]);
  const slugArray = useMemo(() => (paramsHook.slug as string[] | undefined) || [], [paramsHook.slug]);

  useEffect(() => {
    setRenderState(PageRenderState.Loading);
    const localParsedResult = parseSiteIdentifier(siteIdParamValue);
    if (!localParsedResult) {
        setErrorMessage("Invalid site identifier in URL.");
        setRenderState(PageRenderState.Error);
        return;
    }
    setParsedPageIdentifier(localParsedResult);

    async function processAndRenderSiteContent(validParsedResult: ParsedSiteIdentifier) {
      let fetchedSiteData: LocalSiteData | null = null;
      if (validParsedResult.isRemote && validParsedResult.remoteBaseUrl) {
        fetchedSiteData = await fetchRemoteSiteData(validParsedResult.remoteBaseUrl);
        if (!fetchedSiteData) setErrorMessage(`Failed to fetch remote site: ${validParsedResult.remoteBaseUrl}.`);
      } else if (!validParsedResult.isRemote) {
        fetchedSiteData = await localSiteFs.getSiteById(validParsedResult.effectiveSiteId);
        if (!fetchedSiteData) setErrorMessage(`Local site "${validParsedResult.effectiveSiteId}" not found.`);
      }

      if (!fetchedSiteData) {
        setSiteData(null); 
        setRenderState(PageRenderState.Error); 
        return;
      }
      setSiteData(fetchedSiteData);

      const resolution = resolvePageContent(fetchedSiteData, slugArray);
      const siteRootPathForLinks = `/${validParsedResult.rawParam}`;
      
      if (resolution.type === PageType.NotFound) {
          setRenderState(PageRenderState.NotFound);
          setErrorMessage(resolution.errorMessage || "Page not found.");
          setPageMetaTitle("Page Not Found");
          return;
      }
      
      setPageMetaTitle(resolution.pageTitle || 'Untitled');
      
      try {
        const fullPageHtml = await renderWithTheme(
          fetchedSiteData,
          resolution,
          siteRootPathForLinks
        );
        setPageHtmlContent(fullPageHtml);
        setRenderState(PageRenderState.Display);
      } catch (e) {
          console.error("Theme rendering failed:", e);
          setErrorMessage(`Theme Error: ${(e as Error).message}`);
          setRenderState(PageRenderState.Error);
      }
    }
    processAndRenderSiteContent(localParsedResult);
  }, [siteIdParamValue, slugArray]);

  useEffect(() => {
    if (renderState === PageRenderState.Loading) {
        document.title = "Loading... | Signum";
    } else {
        let title = pageMetaTitle;
        if (siteData?.manifest?.title) title += ` | ${siteData.manifest.title}`;
        document.title = title;
    }
  }, [renderState, pageMetaTitle, siteData]);

  if (renderState === PageRenderState.Loading) {
    return <div className="container mx-auto p-8"><p>Loading content...</p></div>;
  }

  const siteHomeLinkForError = parsedPageIdentifier?.rawParam ? `/${parsedPageIdentifier.rawParam}` : '/';
  if (renderState === PageRenderState.Error || renderState === PageRenderState.NotFound) {
      return (
        <div className="container mx-auto p-8 text-center">
          <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
          <h1 className="text-2xl font-bold mb-2">{pageMetaTitle}</h1>
          <p className="text-muted-foreground">{errorMessage || "The requested content could not be loaded."}</p>
          <Button asChild variant="outline" className="mt-6">
              <Link href={siteData ? siteHomeLinkForError : '/'}>
                  {siteData ? 'Go to Site Home' : 'Go to Dashboard'}
              </Link>
          </Button>
        </div>
      );
  }

  return <div dangerouslySetInnerHTML={{ __html: pageHtmlContent }} />;
}

================================================================================

File: stores/useAppStore.ts
// src/stores/useAppStore.ts
import { create } from 'zustand';
import { AppState, LocalSiteData, Manifest, StructureNode, ParsedMarkdownFile } from '@/types';
import * as localSiteFs from '@/lib/localSiteFs';
import { parseMarkdownString, stringifyToMarkdown } from '@/lib/markdownParser';
import { getParentPath } from '@/lib/fileTreeUtils';

// Helper function to recursively find and update a node in the structure tree.
const mapStructure = (nodes: StructureNode[], predicate: (node: StructureNode) => boolean, transform: (node: StructureNode) => StructureNode): StructureNode[] => {
  return nodes.map(node => {
    let transformedNode = node;
    if (predicate(node)) {
      transformedNode = transform(node);
    }
    if (transformedNode.children) {
      transformedNode.children = mapStructure(transformedNode.children, predicate, transform);
    }
    return transformedNode;
  });
};

// Helper function to recursively find and remove a node from the tree.
const filterStructure = (nodes: StructureNode[], predicate: (node: StructureNode) => boolean): StructureNode[] => {
  return nodes.filter(predicate).map(node => {
    if (node.children) {
      node.children = filterStructure(node.children, predicate);
    }
    return node;
  });
};

interface AppStore extends AppState {
  isInitialized: boolean;
  initialize: () => Promise<void>;
}

export const useAppStore = create<AppStore>()(
  (set, get) => ({
    sites: [],
    isInitialized: false,

    initialize: async () => {
      if (get().isInitialized) return;
      const sites = await localSiteFs.loadAllSites();
      set({ sites, isInitialized: true });
    },

    addSite: async (newSiteData: LocalSiteData) => {
      await localSiteFs.saveSite(newSiteData);
      set((state) => ({ sites: [...state.sites, newSiteData] }));
    },

    updateManifest: async (siteId: string, newManifest: Manifest) => {
      await localSiteFs.saveManifest(siteId, newManifest);
      set((state) => ({
        sites: state.sites.map((s) => (s.siteId === siteId ? { ...s, manifest: newManifest } : s)),
      }));
    },

    addNewCollection: async (siteId: string, name: string, slug: string, layout: string) => {
      const site = get().sites.find(s => s.siteId === siteId);
      if (!site) return;

      const newCollectionNode: StructureNode = {
        type: 'collection',
        title: name.trim(),
        path: `content/${slug}`,
        slug: slug,
        children: [],
        navOrder: site.manifest.structure.length,
        layout: layout,
        itemLayout: 'page', // Default item layout for new collections
      };
      
      const newStructure = [...site.manifest.structure, newCollectionNode];
      const newManifest = { ...site.manifest, structure: newStructure };
      
      await get().updateManifest(siteId, newManifest);
    },
    
    // UPDATED: Signature now includes layoutId.
    addOrUpdateContentFile: async (siteId: string, filePath: string, rawMarkdownContent: string, layoutId: string): Promise<boolean> => {
      const site = get().sites.find(s => s.siteId === siteId);
      if (!site) return false;

      const { frontmatter: parsedFm, content } = parseMarkdownString(rawMarkdownContent);
      const isNewFile = !site.contentFiles.some(f => f.path === filePath);
      
      const fileSlug = filePath.substring(filePath.lastIndexOf('/') + 1).replace('.md', '');
      const savedFile: ParsedMarkdownFile = { slug: fileSlug, path: filePath, frontmatter: parsedFm, content };

      await localSiteFs.saveContentFile(siteId, filePath, stringifyToMarkdown(parsedFm, content));
      
      const updatedContentFiles = isNewFile
          ? [...site.contentFiles, savedFile]
          : site.contentFiles.map(f => f.path === filePath ? savedFile : f);
      set(state => ({
        sites: state.sites.map(s => s.siteId === siteId ? { ...s, contentFiles: updatedContentFiles } : s),
      }));

      let manifestChanged = false;
      let newStructure = site.manifest.structure;

      if (isNewFile) {
        manifestChanged = true;
        let parentFound = false;
        const parentPath = getParentPath(filePath);

        // Try to add the new file as a child of its parent in the structure
        newStructure = mapStructure(site.manifest.structure, node => node.path === parentPath, parentNode => {
          parentFound = true;
          return {
            ...parentNode,
            children: [
              ...(parentNode.children || []),
              {
                type: 'page',
                title: parsedFm.title,
                path: filePath,
                slug: fileSlug,
                layout: layoutId, // Use the provided layoutId
              },
            ],
          };
        });
        
        // If no parent was found (e.g., a new top-level page), add it to the root.
        if (!parentFound && parentPath === 'content') {
            newStructure.push({ type: 'page', title: parsedFm.title, path: filePath, slug: fileSlug, layout: layoutId, navOrder: newStructure.length });
        }
      } else {
        // If an existing file's title changed, update it in the manifest.
        newStructure = mapStructure(site.manifest.structure, node => node.path === filePath, node => {
          if (node.title !== parsedFm.title) {
            manifestChanged = true;
            return { ...node, title: parsedFm.title };
          }
          return node;
        });
      }

      if (manifestChanged) {
        await get().updateManifest(siteId, { ...site.manifest, structure: newStructure });
      }

      return true;
    },
    
    deleteContentFileAndState: async (siteId: string, filePath: string) => {
      await localSiteFs.deleteContentFile(siteId, filePath);
      const site = get().sites.find(s => s.siteId === siteId);
      if (!site) return;

      const newStructure = filterStructure(site.manifest.structure, node => node.path !== filePath);
      await get().updateManifest(siteId, { ...site.manifest, structure: newStructure });

      set(state => ({
          sites: state.sites.map(s => {
              if (s.siteId === siteId) {
                  return { ...s, contentFiles: s.contentFiles.filter(f => f.path !== filePath) };
              }
              return s;
          }),
      }));
    },
    
    deleteSiteAndState: async (siteId: string) => {
        await localSiteFs.deleteSite(siteId);
        set(state => ({
            sites: state.sites.filter(s => s.siteId !== siteId),
        }));
    },

    getSiteById: (siteId: string): LocalSiteData | undefined => {
      return get().sites.find((s) => s.siteId === siteId);
    },
  })
);

================================================================================

File: components/publishing/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useEffect, useRef, useState } from 'react';
import { Textarea } from '@/components/ui/textarea';

interface MarkdownEditorProps {
  initialValue: string;
  onChange: (bodyContent: string) => void;
}

export default function MarkdownEditor({ initialValue, onChange }: MarkdownEditorProps) {
  const [currentValue, setCurrentValue] = useState(initialValue);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    // Only update if initialValue truly differs from currentValue to avoid cursor jumps
    // This is important if parent re-renders frequently but initialValue for editor hasn't changed
    if (initialValue !== currentValue) {
      setCurrentValue(initialValue);
    }
  }, [initialValue, currentValue]); // Added currentValue back as per ESLint, condition handles loops

  const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newValue = event.target.value;
    setCurrentValue(newValue);
    onChange(newValue); 
  };

  const handleKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (event.key === 'Tab' && !event.shiftKey) {
      event.preventDefault();
      const target = event.target as HTMLTextAreaElement;
      const { selectionStart, selectionEnd } = target;
      const tab = '  ';
      
      const newValue = currentValue.substring(0, selectionStart) + tab + currentValue.substring(selectionEnd);
      
      setCurrentValue(newValue);
      onChange(newValue);

      setTimeout(() => {
        if (textareaRef.current) {
          textareaRef.current.selectionStart = textareaRef.current.selectionEnd = selectionStart + tab.length;
        }
      }, 0);
    }
  };

  return (
    <Textarea
      ref={textareaRef}
      value={currentValue}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
      placeholder={
`# Your Main Heading

Start writing your Markdown content here.`}
      className="w-full flex-1 font-mono text-sm min-h-[calc(100%-50px)] 
                 p-4 border rounded-md shadow-sm 
                 focus-visible:ring-1 focus-visible:ring-ring"
      // Adjusted min-height assuming parent provides fixed height for overall editor area
    />
  );
}

================================================================================

File: components/publishing/NewCollectionDialog.tsx
// src/components/publishing/NewCollectionDialog.tsx
'use client';

import { useState, useEffect, type ReactNode } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import { type ThemeLayout } from '@/lib/themeEngine'; // Import the layout type

interface NewCollectionDialogProps {
  children: ReactNode;
  existingSlugs: string[];
  availableLayouts: ThemeLayout[]; // Pass in available layouts
  onSubmit: (name: string, slug: string, layout: string) => Promise<void>; // Update signature
}

export default function NewCollectionDialog({ children, existingSlugs, availableLayouts, onSubmit }: NewCollectionDialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');
  const [selectedLayout, setSelectedLayout] = useState('');

  useEffect(() => {
    if (name) {
      setSlug(slugify(name));
    } else {
      setSlug('');
    }
  }, [name]);
  
  // Set a default layout when the dialog opens
  useEffect(() => {
    if (isOpen && availableLayouts.length > 0) {
      setSelectedLayout(availableLayouts[0].id);
    }
  }, [isOpen, availableLayouts]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !slug.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }
    if (!selectedLayout) {
        toast.error("You must select a layout for the collection.");
        return;
    }
    if (existingSlugs.includes(slug)) {
      toast.error(`A collection or page with the folder name "${slug}" already exists.`);
      return;
    }

    await onSubmit(name, slug, selectedLayout);
    
    setIsOpen(false);
    setName('');
    setSlug('');
    setSelectedLayout('');
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection</DialogTitle>
            <DialogDescription>
              Create a new folder to organize your content. All items in this collection will share a common layout.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
            <div className="space-y-1">
              <Label htmlFor="layout-select">Layout</Label>
               <Select value={selectedLayout} onValueChange={setSelectedLayout}>
                    <SelectTrigger id="layout-select"><SelectValue placeholder="Select a layout..." /></SelectTrigger>
                    <SelectContent>
                        {availableLayouts.map(layout => (
                            <SelectItem key={layout.id} value={layout.id}>{layout.name}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name || !selectedLayout}>Create Collection</Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: components/publishing/AppearanceSettingsForm.tsx
// src/components/publishing/AppearanceSettingsForm.tsx
'use client';

import { useEffect, useState } from 'react';
import { RJSFSchema } from '@rjsf/utils';
import { getThemeAppearanceSchema } from '@/lib/themeEngine';
import SchemaDrivenForm from './SchemaDrivenForm';
import { ThemeConfig } from '@/types';

interface AppearanceSettingsFormProps {
  themeId: string;
  themeType: 'core' | 'contrib';
  themeConfig: ThemeConfig['config'];
  onConfigChange: (newConfig: ThemeConfig['config']) => void;
}

export default function AppearanceSettingsForm({ themeId, themeType, themeConfig, onConfigChange }: AppearanceSettingsFormProps) {
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function loadSchema() {
      setIsLoading(true);
      // CORRECTED: Pass both themeId and themeType
      const appearanceSchema = await getThemeAppearanceSchema(themeId, themeType);
      setSchema(appearanceSchema);
      setIsLoading(false);
    }
    if (themeId && themeType) {
        loadSchema();
    }
  }, [themeId, themeType]);

  if (isLoading) {
    return <p className="text-muted-foreground">Loading appearance settings...</p>;
  }

  if (!schema) {
    return (
      <div className="text-center border-2 border-dashed p-6 rounded-lg">
        <p className="font-semibold">No Appearance Options</p>
        <p className="text-sm text-muted-foreground">The current theme (&quot;{themeId}&quot;) does not provide any customizable appearance settings.</p>
      </div>
    );
  }

  return (
    <SchemaDrivenForm
      schema={schema}
      formData={themeConfig}
      onFormChange={(data) => onConfigChange(data as ThemeConfig['config'])}
    />
  );
}

================================================================================

File: components/publishing/SiteSettingsForm.tsx
// src/components/publishing/SiteSettingsForm.tsx
'use client';

//import { Manifest } from '@/types';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

interface SiteSettingsFormProps {
  formData: {
    title: string;
    description: string;
    author: string;
  };
  onFormChange: (newData: SiteSettingsFormProps['formData']) => void;
}

export default function SiteSettingsForm({ formData, onFormChange }: SiteSettingsFormProps) {
  const handleChange = (field: keyof typeof formData, value: string) => {
    onFormChange({ ...formData, [field]: value });
  };

  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Label htmlFor="title">Site Title</Label>
        <Input
          id="title"
          value={formData.title}
          onChange={(e) => handleChange('title', e.target.value)}
          placeholder="My Awesome Site"
        />
        <p className="text-sm text-muted-foreground">The main title for your website.</p>
      </div>
      <div className="space-y-2">
        <Label htmlFor="description">Site Description</Label>
        <Textarea
          id="description"
          value={formData.description}
          onChange={(e) => handleChange('description', e.target.value)}
          placeholder="A short, catchy description."
          rows={3}
        />
         <p className="text-sm text-muted-foreground">Used for search engines and social media previews.</p>
      </div>
       <div className="space-y-2">
        <Label htmlFor="author">Author (Optional)</Label>
        <Input
          id="author"
          value={formData.author}
          onChange={(e) => handleChange('author', e.target.value)}
          placeholder="Your Name or Organization"
        />
         <p className="text-sm text-muted-foreground">The default author for content on this site.</p>
      </div>
    </div>
  );
}

================================================================================

File: components/publishing/FileTree.tsx
// src/components/publishing/FileTree.tsx
'use client';

import React, { useState, useMemo } from 'react';
import Link from 'next/link';
import { type StructureNode } from '@/types';
import { Folder, FileText as FileTextIcon, PlusSquare, GripVertical, ChevronRight, FolderGit2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { DndContext, closestCenter, DragEndEvent } from '@dnd-kit/core';
import { SortableContext, useSortable, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

interface FileTreeProps {
  nodes: StructureNode[];
  baseEditPath: string;
  activePath?: string;
  onFileCreate: (parentPath: string) => void;
  onStructureChange: (nodes: StructureNode[]) => void;
}

interface FileTreeNodeProps extends Omit<FileTreeProps, 'nodes'> {
  node: StructureNode;
}

// A single sortable tree node.
const SortableNode: React.FC<FileTreeNodeProps> = ({ node, baseEditPath, activePath, onFileCreate, onStructureChange }) => {
    const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: node.path });
    const [isOpen, setIsOpen] = useState(true);
    
    const style = { transform: CSS.Transform.toString(transform), transition };

    const isFolderType = node.type === 'collection' || (node.type === 'page' && node.children && node.children.length > 0);
    
    // CORRECTED: Generate links robustly using the full relative path for pages.
    const relativeContentPath = node.path.replace(/^content\//, '').replace(/\.md$/, '');
    const href = node.type === 'collection'
        ? `${baseEditPath}/collection/${node.slug}`
        : `${baseEditPath}/content/${relativeContentPath}`;

    const isSelected = activePath === node.path;
    const NodeIcon = node.type === 'collection' ? Folder : (node.type === 'page' && node.children && node.children.length > 0 ? FolderGit2 : FileTextIcon);

    const handleChildrenStructureChange = (reorderedChildren: StructureNode[]) => {
        onStructureChange([{ ...node, children: reorderedChildren }]);
    };

    return (
        <div ref={setNodeRef} style={style} className="flex flex-col">
            <div className="flex items-center group w-full my-0.5">
                <div {...attributes} {...listeners} className="p-1 cursor-grab touch-none">
                    <GripVertical className="h-4 w-4 text-muted-foreground/50" />
                </div>
                <div className={cn("flex-grow flex items-center py-1.5 pl-1 pr-1 rounded-md hover:bg-muted relative", isSelected && "bg-accent text-accent-foreground")}>
                    {isFolderType && (
                        <ChevronRight 
                            className={cn("h-4 w-4 mr-1 shrink-0 transition-transform duration-200 cursor-pointer", isOpen && "rotate-90", !node.children?.length && "invisible")} 
                            onClick={() => setIsOpen(!isOpen)} 
                        />
                    )}
                    <NodeIcon className={cn("h-4 w-4 shrink-0", isFolderType ? 'text-amber-500' : 'text-sky-500', !isFolderType && 'ml-5')} />
                    
                    <Link href={href} className="truncate flex-grow mx-1.5" title={node.title}>
                        {node.title}
                    </Link>

                    {isFolderType && (
                        <div className="ml-auto opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button variant="ghost" size="icon" className="h-6 w-6" title="New File" onClick={(e) => { e.stopPropagation(); onFileCreate(node.path); }}>
                                <PlusSquare className="h-3.5 w-3.5" />
                            </Button>
                        </div>
                    )}
                </div>
            </div>
            {isFolderType && isOpen && node.children && node.children.length > 0 && (
                <div className="pl-6">
                    <FileTree
                        nodes={node.children}
                        baseEditPath={baseEditPath}
                        activePath={activePath}
                        onFileCreate={onFileCreate}
                        onStructureChange={handleChildrenStructureChange}
                    />
                </div>
            )}
        </div>
    );
};

// The main FileTree component that sets up the DndContext.
export default function FileTree({ nodes, baseEditPath, activePath, onFileCreate, onStructureChange }: FileTreeProps) {
  const nodeIds = useMemo(() => nodes.map(n => n.path), [nodes]);

  if (!nodes || nodes.length === 0) {
    return <p className="p-2 text-sm text-muted-foreground">(No content files yet)</p>;
  }

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
        const oldIndex = nodeIds.indexOf(active.id as string);
        const newIndex = nodeIds.indexOf(over.id as string);
        if (oldIndex !== -1 && newIndex !== -1) {
            const reorderedNodes = arrayMove(nodes, oldIndex, newIndex);
            const updatedNavOrderNodes = reorderedNodes.map((node, index) => {
                if (node.navOrder !== undefined) {
                    return { ...node, navOrder: index };
                }
                return node;
            });
            onStructureChange(updatedNavOrderNodes);
        }
    }
  };

  return (
    <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
        <SortableContext items={nodeIds} strategy={verticalListSortingStrategy}>
            <div className="space-y-0">
                {nodes.map(node => (
                    <SortableNode 
                        key={node.path} 
                        node={node} 
                        baseEditPath={baseEditPath} 
                        activePath={activePath} 
                        onFileCreate={onFileCreate} 
                        onStructureChange={(updatedChildNode) => {
                            const newNodes = nodes.map(n => n.path === updatedChildNode[0].path ? updatedChildNode[0] : n);
                            onStructureChange(newNodes);
                        }}
                    />
                ))}
            </div>
        </SortableContext>
    </DndContext>
  );
}

================================================================================

File: components/publishing/NewFolderDialog.tsx
// src/components/publishing/NewFolderDialog.tsx
'use client';

import { useState, type ReactNode } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { toast } from 'sonner';

interface NewFolderDialogProps {
  children: ReactNode;
  onSubmit: (folderName: string) => Promise<void>;
}

export default function NewFolderDialog({ children, onSubmit }: NewFolderDialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) {
      toast.error("Folder name cannot be empty.");
      return;
    }
    
    try {
        await onSubmit(name);
        toast.success(`Folder "${name}" created!`);
        setIsOpen(false);
        setName('');
    } catch (error) {
        toast.error(`Failed to create folder: ${(error as Error).message}`);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
            <DialogHeader>
            <DialogTitle>Create New Folder</DialogTitle>
            <DialogDescription>
                Create a folder to organize pages. An `index.md` file will be automatically created inside it.
            </DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="name" className="text-right">
                Name
                </Label>
                <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="col-span-3"
                placeholder="e.g., About Us"
                autoComplete="off"
                />
            </div>
            </div>
            <DialogFooter>
                <DialogClose asChild>
                    <Button type="button" variant="outline">Cancel</Button>
                </DialogClose>
                <Button type="submit">Create Folder</Button>
            </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: components/publishing/SchemaDrivenForm.tsx
'use client';

import Form from '@rjsf/shadcn';
import validator from '@rjsf/validator-ajv8';
import { RJSFSchema, UiSchema, FieldTemplateProps, ObjectFieldTemplateProps } from '@rjsf/utils';
import { Label } from '../ui/label';
// REMOVED: Unused 'Button' import
// import { Button } from '../ui/button'; 

// --- Props Definition ---
interface SchemaDrivenFormProps {
  /** The JSON Schema object that defines the form fields, types, and validation. */
  schema: RJSFSchema;
  /** The UI Schema object for customizing widget types and field appearances. */
  uiSchema?: UiSchema;
  /** The current data/state of the form. */
  formData: object;
  /** Callback function that is triggered every time the form data changes. */
  onFormChange: (data: object) => void;
  /** Set to true to enable live validation as the user types. Defaults to false. */
  liveValidate?: boolean;
}


// --- Custom Field Template (for better layout and labels) ---
function CustomFieldTemplate(props: FieldTemplateProps) {
  const { id, classNames, label, help, required, description, errors, children, schema } = props;

  if (props.hidden) {
    return <div className="hidden">{children}</div>;
  }
  
  const isCheckbox = schema.type === 'boolean' && (props.uiSchema?.['ui:widget'] === 'checkbox' || props.uiSchema?.['ui:widget'] === undefined);

  if (isCheckbox) {
      return <div className={classNames}>{children}</div>
  }

  return (
    <div className={classNames}>
      {label && (
        <Label htmlFor={id} className="block text-sm font-medium mb-1">
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}
      
      {description}
      
      {children}
      
      {errors}
      
      {help}
    </div>
  );
}

// --- Custom Object Field Template (for overall form layout) ---
function CustomObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  return (
    <div>
        {props.title && <h3 className="text-lg font-semibold">{props.title}</h3>}
        {props.description && <p className="text-sm text-muted-foreground">{props.description}</p>}
        <div className="mt-4">
            {props.properties.map(element => (
                <div key={element.name} className="mb-4">
                    {element.content}
                </div>
            ))}
        </div>
    </div>
  );
}

// --- Custom Submit Button Template (to hide it) ---
// FIXED: The 'props' parameter was defined but never used, so it has been removed.
function HideSubmitButton() {
    return null;
}

/**
 * A reusable component that dynamically generates a form from a given JSON Schema.
 * It uses react-jsonschema-form with a shadcn/ui theme for a consistent look and feel.
 */
export default function SchemaDrivenForm({ 
  schema, 
  uiSchema, 
  formData, 
  onFormChange, 
  liveValidate = false 
}: SchemaDrivenFormProps) {

  const safeFormData = formData || {};

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={safeFormData}
      validator={validator}
      onChange={(e) => onFormChange(e.formData)}
      liveValidate={liveValidate}
      showErrorList={false}
      
      templates={{
        FieldTemplate: CustomFieldTemplate,
        ObjectFieldTemplate: CustomObjectFieldTemplate,
        ButtonTemplates: {
            SubmitButton: HideSubmitButton,
        }
      }}
    />
  );
}

================================================================================

File: components/publishing/FrontmatterSidebar.tsx
// src/components/publishing/FrontmatterSidebar.tsx
'use client';

import React, { useState, useEffect } from 'react';
import type { MarkdownFrontmatter } from '@/types';
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';
import { getLayoutSchema } from '@/lib/themeEngine';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';

interface FrontmatterSidebarProps {
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: MarkdownFrontmatter) => void;
  layoutId: string;
  themeId: string;
  themeType: 'core' | 'contrib';
  isNewFileMode: boolean;
  slug: string;
  onSlugChange: (newSlug: string) => void;
}

export default function FrontmatterSidebar({
  frontmatter,
  onFrontmatterChange,
  layoutId,
  themeId,
  themeType,
  isNewFileMode,
  slug,
  onSlugChange,
}: FrontmatterSidebarProps) {
  
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [uiSchema, setUiSchema] = useState<UiSchema | undefined>(undefined);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function loadSchemaForLayout() {
      setIsLoading(true);
      try {
        const layoutSchemaData = await getLayoutSchema(themeId, themeType, layoutId);
        if (layoutSchemaData) {
          const isItemSchema = !!layoutSchemaData.itemSchema;
          setSchema(isItemSchema ? layoutSchemaData.itemSchema! : layoutSchemaData.schema);
          setUiSchema(isItemSchema ? layoutSchemaData.itemUiSchema : layoutSchemaData.uiSchema);
        } else {
          setSchema(null);
        }
      } catch (error) {
        console.error(`Failed to load schema for layout '${layoutId}':`, error);
        setSchema(null);
      } finally {
        setIsLoading(false);
      }
    }
    
    if (layoutId && themeId && themeType) {
      loadSchemaForLayout();
    } else {
        setIsLoading(false);
        setSchema(null);
    }
  }, [layoutId, themeId, themeType]);

  const handleFormChange = (data: object) => {
    onFrontmatterChange(data as MarkdownFrontmatter);
  };

  if (isLoading) {
    return (
      <aside className="w-80 border-l bg-muted/20 p-4 shrink-0">
        <p className="text-sm text-muted-foreground">Loading Form...</p>
      </aside>
    );
  }

  return (
    <aside className="w-80 border-l bg-muted/20 p-4 space-y-6 overflow-y-auto h-full shrink-0">
      <div>
        <h2 className="text-lg font-semibold border-b pb-2 mb-4">Content Settings</h2>
        
        <div className="space-y-2">
            <Label htmlFor="slug-input">Slug (URL Path)</Label>
            <Input 
                id="slug-input"
                value={slug}
                onChange={(e) => onSlugChange(e.target.value)}
                // CORRECTED: The field is now a normal, editable input.
                // It is only disabled for EXISTING files, where the slug cannot be changed.
                disabled={!isNewFileMode}
                className={!isNewFileMode ? 'bg-muted/50 focus-visible:ring-0 focus-visible:ring-offset-0' : ''}
            />
            <p className="text-xs text-muted-foreground">
              {isNewFileMode 
                ? "Auto-generates from title, but you can edit it for a custom URL." 
                : "The slug cannot be changed after the file is created."}
            </p>
        </div>
      </div>
      
      {schema ? (
        <div className="border-t pt-6">
            <SchemaDrivenForm
                schema={schema}
                uiSchema={uiSchema}
                formData={frontmatter}
                onFormChange={handleFormChange}
            />
        </div>
      ) : (
        <div className="text-sm text-destructive-foreground bg-destructive p-3 rounded-md mt-4">
            <p className="font-bold">Schema Error</p>
            <p>Could not find a valid schema for the layout &quot;{layoutId || 'none'}&quot;.</p>
        </div>
      )}
    </aside>
  );
}

================================================================================

File: components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: components/ui/link.tsx
/**
 * TODO: Update this component to use your client-side framework's link
 * component. We've provided examples of how to do this for Next.js, Remix, and
 * Inertia.js in the Catalyst documentation:
 *
 * https://catalyst.tailwindui.com/docs#client-side-router-integration
 */

import * as Headless from '@headlessui/react'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: { href: string } & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <a {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})


================================================================================

File: components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: components/core/Navbar.tsx
// src/components/core/Navbar.tsx
'use client';

import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation'; // Import useRouter
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input'; // Import Input
import React, { useState } from 'react';

// ... (NavLink component remains the same) ...
const NavLink: React.FC<{ href: string; label: string; icon?: React.ReactNode; }> = ({ href, label, icon }) => {
  const pathname = usePathname();
  const isActive = pathname === href || (href !== '/' && pathname.startsWith(href));
  return (
    <Button  className={`justify-start ${isActive ? 'bg-accent text-accent-foreground' : ''}`}>
      <Link href={href} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};


export default function Navbar() {
  const router = useRouter();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim()); // Basic URL validation
        // We need a way to signify this is a remote URL to our browsing pages.
        // Option 1: Special prefix for siteId, e.g., "remote::http://localhost:8080"
        // Option 2: A different route, e.g., /browse/remote?url=...
        // Option 3: Pass state via router.push (can be complex with SSR/layouts)

        // Let's use Option 1: Prefix the siteId with "remote@" or similar marker
        // and encode the URL. The browsing page will then decode it.
        const encodedUrl = encodeURIComponent(url.origin); // Use origin (scheme + hostname + port)
        router.push(`/remote@${encodedUrl}`); // Navigate to /remote@http%3A%2F%2Flocalhost%3A8080
        setRemoteUrl(''); // Clear input
      } catch (error) {
        alert("Invalid URL entered.");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        <Link href="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
        </Link>
        
        {/* Remote Site URL Input */}
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Signum site URL (e.g., http://localhost:8080)"
              className="pl-9" // Padding for the icon
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          <NavLink href="/" label="Dashboard" icon={<Home className="h-4 w-4" />} />
          {/* ... other links ... */}
        </nav>

        <div className="md:hidden">
          <Button  >
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: components/core/Footer.tsx
// src/components/core/Footer.tsx
import Link from 'next/link';
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p> {currentYear} Signum Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: components/core/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: components/browsing/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; // It uses `dangerouslySetInnerHTML`, making it client-side for this pattern.
              // Alternatively, HTML parsing can be done on the server and HTML passed as prop.

import { marked } from 'marked';
import { useEffect, useMemo } from 'react'; // useMemo for parsing, useEffect if parsing were async
// Optional: Add DOMPurify for sanitization if markdown source is not 100% trusted
// import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {
        // If running in an SSR context where marked might be called without DOMPurify (if used),
        // or if you want to ensure it's only parsed once.
        // However, for this component marked as 'use client', this check is less critical
        // as it primarily renders client-side.
    }
    const rawHtml = marked.parse(markdown) as string;
    // Example of sanitization if you were to use DOMPurify:
    // if (typeof window !== 'undefined') { // DOMPurify only runs in browser
    //   return DOMPurify.sanitize(rawHtml);
    // }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Signum, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: lib/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { Input } from 'gray-matter'; // Import GrayMatterOption and Input
//import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { MarkdownFrontmatter, ParsedMarkdownFile } from '@/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Signum focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: lib/pageResolver.ts
// src/lib/pageResolver.ts
import { LocalSiteData, ParsedMarkdownFile, StructureNode } from '@/types';

export enum PageType {
  SinglePage,
  Collection,
  NotFound,
}

export type PageResolutionResult = {
  type: PageType.SinglePage;
  pageTitle: string;
  contentFile: ParsedMarkdownFile;
  layout: string;
} | {
  type: PageType.Collection;
  pageTitle: string;
  collectionNode: StructureNode;
  items: ParsedMarkdownFile[];
  layout: string;
} | {
  type: PageType.NotFound;
  errorMessage: string;
};

function findNodeBySlugPath(nodes: StructureNode[], slugSegments: string[]): StructureNode | null {
  if (!slugSegments || slugSegments.length === 0) {
    return nodes.find(node => node.slug === 'index' || node.path === 'content/index.md') || null;
  }

  const currentSlug = slugSegments[0];
  const remainingSlugs = slugSegments.slice(1);
  const foundNode = nodes.find(node => node.slug === currentSlug);

  if (!foundNode) return null;
  if (remainingSlugs.length === 0) return foundNode;
  if (foundNode.children) return findNodeBySlugPath(foundNode.children, remainingSlugs);

  return null;
}

export function resolvePageContent(siteData: LocalSiteData, slugArray: string[]): PageResolutionResult {
  const targetNode = findNodeBySlugPath(siteData.manifest.structure, slugArray);

  if (!targetNode) {
    return { type: PageType.NotFound, errorMessage: `Content not found for path: /${slugArray.join('/')}` };
  }

  if (targetNode.type === 'page') {
    const contentFile = siteData.contentFiles.find(f => f.path === targetNode.path);
    if (!contentFile) {
      return { type: PageType.NotFound, errorMessage: `Manifest references "${targetNode.path}" but its content file is missing.` };
    }
    return {
      type: PageType.SinglePage,
      pageTitle: targetNode.title,
      contentFile,
      layout: targetNode.layout,
    };
  }

  if (targetNode.type === 'collection') {
    const items = (targetNode.children || [])
      .map(childNode => siteData.contentFiles.find(f => f.path === childNode.path))
      .filter((file): file is ParsedMarkdownFile => !!file);
    
    // Future: Add sorting logic here based on collectionNode properties
    
    return {
      type: PageType.Collection,
      pageTitle: targetNode.title,
      collectionNode: targetNode,
      items,
      layout: targetNode.layout,
    };
  }

  return { type: PageType.NotFound, errorMessage: `Unknown node type encountered for path: /${slugArray.join('/')}` };
}

================================================================================

File: lib/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: lib/siteExporter.ts
// src/lib/siteExporter.ts
import JSZip from 'jszip';
import { LocalSiteData, ParsedMarkdownFile, StructureNode } from '@/types';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { flattenStructureToRenderableNodes } from './fileTreeUtils';
import { resolvePageContent, PageType } from './pageResolver';
import { render as renderWithTheme } from './themeEngine';

function escapeForXml(str: string | undefined | unknown): string {
    if (str === undefined || str === null) return '';
    return String(str).replace(/[&<>"']/g, (match) => {
      return { '<': '<', '>': '>', '&': '&', '"': '"', "'": "'" }[match] || match;
    });
}
  
function getUrlForNode(node: { slug: string, path: string, type: 'page' | 'collection' }, basePath: string = '/'): string {
    if (node.slug === 'index' && node.type === 'page' && !node.path.includes('/')) {
        return `${basePath}index.html`;
    }

    if (node.type === 'collection') {
        return `${basePath}${node.slug}/index.html`.replace(/\/\//g, '/');
    }
    
    const pathSegments = node.path.replace(/^content\//, '').replace(/\.md$/, '');
    const path = `${basePath}${pathSegments}.html`;
    return path.replace(/\/\//g, '/');
}


// --- Main Export Function ---
export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
  const zip = new JSZip();
  const themeId = siteData.manifest.theme.name;
  const themeType = siteData.manifest.theme.type;
  const themePath = `/themes/${themeType}/${themeId}`;

  // 1. Correctly bundle all theme assets (CSS, JS)
  try {
    const themeManifest = await fetch(`${themePath}/theme.json`).then(r => r.json());
    let finalCss = '';
    
    const baseCssPath = `${themePath}/assets/base.css`;
    const baseCss = await fetch(baseCssPath).then(r => r.ok ? r.text() : '').catch(() => '');
    finalCss += baseCss + '\n';
    
    if (themeManifest.layouts) {
        for (const layoutId of themeManifest.layouts) {
            const layoutCssPath = `${themePath}/layouts/${layoutId}/style.css`;
            const layoutCss = await fetch(layoutCssPath).then(r => r.ok ? r.text() : '').catch(() => '');
            finalCss += layoutCss + '\n';
        }
    }
    zip.file('style.css', finalCss);

    const scriptsJsPath = `${themePath}/scripts.js`;
    const scriptsJs = await fetch(scriptsJsPath).then(r => r.ok ? r.text() : '').catch(() => '');
    if (scriptsJs) {
        zip.file('scripts.js', scriptsJs);
    }

  } catch (e) {
      console.warn("Could not bundle theme assets for export.", e);
  }

  // 2. Generate all HTML pages using the correct node list
  const allRenderableNodes = flattenStructureToRenderableNodes(siteData.manifest.structure);
  
  for (const node of allRenderableNodes) {
      const slugArray = (node.type === 'collection') 
          ? [node.slug] 
          : node.path.replace(/^content\//, '').replace(/\.md$/, '').split('/').filter(Boolean);
      
      const resolution = resolvePageContent(siteData, slugArray);
      
      if (resolution.type === PageType.NotFound) {
        console.warn(`Skipping export for node with missing content: ${node.path}`);
        continue;
      }
      
      const finalHtml = await renderWithTheme(siteData, resolution, '/');
      
      let outputPath = getUrlForNode({ ...node, type: node.type as 'page' | 'collection' }, '/');
      outputPath = outputPath.startsWith('/') ? outputPath.substring(1) : outputPath;

      zip.file(outputPath, finalHtml);
  }

  // 3. Add _signum source files
  zip.file(`_signum/manifest.json`, JSON.stringify(siteData.manifest, null, 2));
  for (const file of siteData.contentFiles) {
    const rawMd = stringifyToMarkdown(file.frontmatter, file.content);
    zip.file(`_signum/${file.path}`, rawMd);
  }

  // 4. Conditionally bundle custom theme source files
  if (themeType === 'contrib') {
    console.log(`Bundling 'contrib' theme source for: ${themeId}`);
    const themeZipPrefix = `_signum/themes/contrib/${themeId}`;
    const themeFetchPrefix = `/themes/contrib/${themeId}`;

    const themeManifest = await fetch(`${themeFetchPrefix}/theme.json`).then(r => r.json());
    
    zip.file(`${themeZipPrefix}/theme.json`, JSON.stringify(themeManifest, null, 2));
    
    const addFileToTheme = async (filePath: string) => {
        try {
            const response = await fetch(filePath);
            if (response.ok) {
                const content = await response.text();
                const zipPath = filePath.replace(themeFetchPrefix, themeZipPrefix);
                zip.file(zipPath, content);
            }
        } catch {}
    };

    await addFileToTheme(`${themeFetchPrefix}/assets/base.css`);
    await addFileToTheme(`${themeFetchPrefix}/scripts.js`);

    // CORRECTED: Only bundle partials that are explicitly defined in the manifest.
    if(themeManifest.partials) {
        for (const key in themeManifest.partials) {
            await addFileToTheme(themeManifest.partials[key]);
        }
    }

    for (const layoutId of themeManifest.layouts) {
        const layoutPath = `${themeFetchPrefix}/layouts/${layoutId}`;
        await addFileToTheme(`${layoutPath}/schema.json`);
        await addFileToTheme(`${layoutPath}/item.schema.json`);
        await addFileToTheme(`${layoutPath}/index.hbs`);
        await addFileToTheme(`${layoutPath}/item.hbs`);
        await addFileToTheme(`${layoutPath}/style.css`);
    }
  }

  // 5. RSS and Sitemap Generation
  const allPageNodes = allRenderableNodes.filter((n: StructureNode) => n.type === 'page');
  const siteBaseUrl = `https://${siteData.manifest.title.toLowerCase().replace(/\s+/g, '-') || 'example'}.com`;

  type RssItem = { node: StructureNode, file?: ParsedMarkdownFile };

  const rssItems = allPageNodes
    .map((p: StructureNode): RssItem => ({ node: p, file: siteData.contentFiles.find(f => f.path === p.path) }))
    .filter((item: RssItem) => item.file && item.file.frontmatter.date)
    .sort((a: RssItem, b: RssItem) => new Date(b.file!.frontmatter.date as string).getTime() - new Date(a.file!.frontmatter.date as string).getTime())
    .slice(0, 20)
    .map((item: RssItem) => {
        const url = new URL(getUrlForNode({ ...item.node!, type: 'page' }, '/'), siteBaseUrl).href;
        const description = escapeForXml(item.file!.frontmatter.summary || '');
        return `<item><title>${escapeForXml(item.node!.title)}</title><link>${escapeForXml(url)}</link><guid isPermaLink="true">${escapeForXml(url)}</guid><pubDate>${new Date(item.file!.frontmatter.date as string).toUTCString()}</pubDate><description>${description}</description></item>`;
    }).join('');
  const rssFeed = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(siteData.manifest.title)}</title><link>${siteBaseUrl}</link><description>${escapeForXml(siteData.manifest.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrl).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;
  zip.file('rss.xml', rssFeed);

  const sitemapUrls = allPageNodes.map((node: StructureNode) => {
      const file = siteData.contentFiles.find(f => f.path === node.path);
      const url = new URL(getUrlForNode({ ...node, type: 'page' }, '/'), siteBaseUrl).href;
      const lastMod = (file?.frontmatter.date as string || new Date().toISOString()).split('T')[0];
      return `<url><loc>${escapeForXml(url)}</loc><lastmod>${lastMod}</lastmod></url>`;
  }).join('');
  const sitemapXml = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
  zip.file('sitemap.xml', sitemapXml);

  return zip.generateAsync({ type: 'blob' });
}

================================================================================

File: lib/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: lib/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { LocalSiteData, ParsedMarkdownFile, Manifest } from '@/types';
import { parseMarkdownString } from './markdownParser';
import { flattenStructureToPages } from './fileTreeUtils';

async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const url = new URL(filePath, baseUrl).href;
  const response = await fetch(url, { cache: 'no-store' });
  if (!response.ok) {
    throw new Error(`Fetch failed for ${url}: ${response.statusText}`);
  }
  return response.text();
}

/**
 * Fetches and reconstructs an entire remote Signum site into the LocalSiteData format.
 * It fetches the manifest, then fetches all content files listed within it.
 * @param remoteSiteUrl The base URL of the remote Signum site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json, which is now the single source of truth.
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_signum/manifest.json');
    const manifest: Manifest = JSON.parse(manifestString);

    if (!manifest || !manifest.siteId || !manifest.structure) {
        throw new Error("Invalid manifest structure fetched from remote site.");
    }
    
    // 2. Collect all unique file paths from the manifest structure.
    const allPageNodes = flattenStructureToPages(manifest.structure);
    const contentFilePaths = [...new Set(allPageNodes.map(node => node.path))];

    // 3. Fetch all content files in parallel.
    const contentFilesPromises = contentFilePaths.map(async (path) => {
        try {
            const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, `_signum/${path}`);
            const { frontmatter, content } = parseMarkdownString(rawMarkdown);
            const slug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
            return { slug, path, frontmatter, content };
        } catch (error) {
            console.warn(`Could not fetch or parse content file: ${path}`, error);
            return null; // Return null on failure for this specific file
        }
    });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];

    // 4. Construct the final LocalSiteData object.
    const finalSiteData: LocalSiteData = {
      siteId: `remote-${manifest.siteId}`, // Prefix to distinguish in local state
      manifest: manifest,
      contentFiles: validContentFiles,
    };

    return finalSiteData;

  } catch (error) {
    console.error(`CRITICAL ERROR fetching remote site data for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

File: lib/fileTreeUtils.ts
// src/lib/fileTreeUtils.ts
import { StructureNode } from '@/types';

/**
 * Finds a node in a structure tree by its exact `path`.
 * @param nodes The array of nodes to search within.
 * @param path The path of the node to find (e.g., "content/blog/first-post.md").
 * @returns The found StructureNode or undefined.
 */
export function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) {
      return node;
    }
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) {
        return found;
      }
    }
  }
  return undefined;
}

/**
 * Recursively traverses the structure tree and collects all nodes that are pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all page-type StructureNodes.
 */
export function flattenStructureToPages(nodes: StructureNode[]): StructureNode[] {
  let pages: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page') {
      pages.push(node);
    }
    if (node.children) {
      pages = pages.concat(flattenStructureToPages(node.children));
    }
  }
  return pages;
}

/**
 * Recursively traverses the structure tree and collects all nodes that can be rendered as a page.
 * This includes single pages AND collection listing pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all renderable StructureNodes.
 */
export function flattenStructureToRenderableNodes(nodes: StructureNode[]): StructureNode[] {
  let renderableNodes: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page' || node.type === 'collection') {
      renderableNodes.push(node);
    }
    if (node.children) {
      renderableNodes = renderableNodes.concat(flattenStructureToRenderableNodes(node.children));
    }
  }
  return renderableNodes;
}

/**
 * Gets the parent directory path for a given file path.
 * e.g., "content/blog/post.md" -> "content/blog"
 * @param path The full path of a file or folder.
 * @returns The path of the parent directory.
 */
export function getParentPath(path: string): string {
  if (!path.includes('/')) return 'content';
  return path.substring(0, path.lastIndexOf('/'));
}

================================================================================

File: lib/themeEngine.ts
// src/lib/themeEngine.ts
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import Handlebars from 'handlebars';
import { marked } from 'marked';
import { PageResolutionResult, PageType } from './pageResolver';
import { LocalSiteData, Manifest, NavLinkItem, ParsedMarkdownFile, StructureNode, ThemeConfig } from '@/types';
import { generateNavLinks } from './navigationUtils';

import baseSchemaFile from '@/config/base.schema.json';

// --- Type Definitions for this module ---

export interface ThemeInfo {
  id: string;
  name: string;
  type: 'core' | 'contrib';
}

export interface ThemeLayout {
  id: string;
  name: string;
  type: 'page' | 'collection';
}

export interface LayoutSchema {
  schema: RJSFSchema;
  uiSchema?: UiSchema;
  itemSchema?: RJSFSchema;
  itemUiSchema?: UiSchema;
}

interface SchemaFile {
    schema: RJSFSchema;
    uiSchema?: UiSchema;
}
interface ThemeManifestFile {
    layouts: string[];
    partials?: { [key: string]: string };
    appearanceSchema?: RJSFSchema;
}

interface TemplateContext {
    manifest: Manifest;
    themeConfig: ThemeConfig['config'];
    navLinks: NavLinkItem[];
    year: number;
    pageTitle: string;
    body: string;
    frontmatter?: ParsedMarkdownFile['frontmatter'];
    contentHtml?: string;
    collectionNode?: StructureNode;
    items?: ParsedMarkdownFile[];
}

// --- Caching and Private Helpers ---
const templateCache: { [key: string]: Handlebars.TemplateDelegate } = {};
const jsonCache: { [key: string]: object } = {};
let lastRegisteredTheme = '';
// CORRECTED: Use a simple boolean flag at the module level.
let helpersHaveBeenRegistered = false;

async function getJsonFile<T extends object>(path: string): Promise<T | null> {
  if (jsonCache[path]) {
    return jsonCache[path] as T;
  }
  try {
    const response = await fetch(path);
    if (!response.ok) return null;
    const data = await response.json();
    jsonCache[path] = data;
    return data as T;
  } catch {
    return null;
  }
}

async function getTemplate(path: string): Promise<Handlebars.TemplateDelegate> {
  if (templateCache[path]) return templateCache[path];
  const res = await fetch(path);
  if (!res.ok) throw new Error(`Template not found: ${path}`);
  const source = await res.text();
  const template = Handlebars.compile(source);
  templateCache[path] = template;
  return template;
}

function registerHelpers() {
    // CORRECTED: Check the simple boolean flag. This is cleaner and type-safe.
    if (helpersHaveBeenRegistered) return;
    
    Handlebars.registerHelper('eq', (a: unknown, b: unknown) => a === b);
    Handlebars.registerHelper('formatDate', (date: string | Date) => {
        try {
            const d = new Date(date);
            return new Intl.DateTimeFormat('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            }).format(d);
        } catch {
            return String(date);
        }
    });
    // Set the flag after registration.
    helpersHaveBeenRegistered = true;
}


async function registerPartials(themeId: string, themeType: 'core' | 'contrib') {
    const themeIdentifier = `${themeType}-${themeId}`;
    if (lastRegisteredTheme === themeIdentifier) return;

    const partialNames = Object.keys(Handlebars.partials);
    partialNames.forEach(name => Handlebars.unregisterPartial(name));

    const themePath = `/themes/${themeType}/${themeId}`;
    const themeManifest = await getJsonFile<ThemeManifestFile>(`${themePath}/theme.json`);
    
    const partialsToRegister = themeManifest?.partials || {};

    for (const name in partialsToRegister) {
        try {
            const path = partialsToRegister[name as keyof typeof partialsToRegister];
            const templateString = await fetch(path).then(res => res.text());
            Handlebars.registerPartial(name, templateString);
        } catch (e) {
            console.warn(`Could not register partial: ${name} from path ${partialsToRegister[name as keyof typeof partialsToRegister]}`, e);
        }
    }
    lastRegisteredTheme = themeIdentifier;
}


function mergeSchemas(base: SchemaFile, extension: SchemaFile | null): SchemaFile {
    if (!extension) return base;

    const mergedSchema: RJSFSchema = {
        ...base.schema,
        ...extension.schema,
        properties: {
            ...(base.schema.properties || {}),
            ...(extension.schema.properties || {}),
        },
    };
    if (extension.schema.required) {
        mergedSchema.required = [...new Set([...(base.schema.required || []), ...extension.schema.required])];
    }

    const mergedUiSchema: UiSchema = {
        ...base.uiSchema,
        ...extension.uiSchema,
    };

    return { schema: mergedSchema, uiSchema: mergedUiSchema };
}


// --- Public API ---

export async function getAvailableThemes(): Promise<ThemeInfo[]> {
    const coreThemesPromise = getJsonFile<Omit<ThemeInfo, 'type'>[]>(`/themes/core/themes.json`);
    const contribThemesPromise = getJsonFile<Omit<ThemeInfo, 'type'>[]>(`/themes/contrib/themes.json`);

    const [coreThemes, contribThemes] = await Promise.all([coreThemesPromise, contribThemesPromise]);

    const allThemes: ThemeInfo[] = [];

    if (coreThemes) {
        allThemes.push(...coreThemes.map(t => ({ ...t, type: 'core' as const })));
    }
    if (contribThemes) {
        allThemes.push(...contribThemes.map(t => ({ ...t, type: 'contrib' as const })));
    }
    
    allThemes.sort((a, b) => a.name.localeCompare(b.name));

    return allThemes;
}

export async function getThemeAppearanceSchema(themeId: string, themeType: 'core' | 'contrib'): Promise<RJSFSchema | null> {
    const themeManifest = await getJsonFile<ThemeManifestFile>(`/themes/${themeType}/${themeId}/theme.json`);
    return themeManifest?.appearanceSchema || null;
}


export async function getLayoutSchema(themeId: string, themeType: 'core' | 'contrib', layoutId: string): Promise<LayoutSchema | null> {
  const layoutPath = `/themes/${themeType}/${themeId}/layouts/${layoutId}`;

  const coreBaseSchema = baseSchemaFile as SchemaFile;

  const mainLayoutSchemaFile = await getJsonFile<SchemaFile>(`${layoutPath}/schema.json`);
  const itemLayoutSchemaFile = await getJsonFile<SchemaFile>(`${layoutPath}/item.schema.json`);

  let finalItemSchema: SchemaFile | null = null;
  
  if (itemLayoutSchemaFile) {
    finalItemSchema = mergeSchemas(coreBaseSchema, itemLayoutSchemaFile);
  } else {
    finalItemSchema = coreBaseSchema;
  }

  const primarySchema = mainLayoutSchemaFile || finalItemSchema;

  if (!primarySchema) {
    return null;
  }

  return {
    schema: primarySchema.schema,
    uiSchema: primarySchema.uiSchema,
    itemSchema: finalItemSchema?.schema,
    itemUiSchema: finalItemSchema?.uiSchema,
  };
}

export async function getAvailableLayouts(themeId: string, themeType: 'core' | 'contrib'): Promise<ThemeLayout[]> {
  const themePath = `/themes/${themeType}/${themeId}/theme.json`;
  const themeManifest = await getJsonFile<ThemeManifestFile>(themePath);

  if (!themeManifest || !Array.isArray(themeManifest.layouts)) {
    console.error(`Theme manifest not found or invalid for theme: ${themeId}`);
    return [];
  }

  const layouts: ThemeLayout[] = [];

  for (const layoutId of themeManifest.layouts) {
    const schemaData = await getLayoutSchema(themeId, themeType, layoutId);
    if (!schemaData) {
      console.warn(`Layout "${layoutId}" in theme "${themeId}" is missing its required schema files.`);
      continue;
    }

    const isCollection = !!schemaData.itemSchema;
    
    const relevantSchema = isCollection ? schemaData.schema : schemaData.itemSchema;
    
    layouts.push({
      id: layoutId,
      name: relevantSchema?.title || layoutId.charAt(0).toUpperCase() + layoutId.slice(1),
      type: isCollection ? 'collection' : 'page',
    });
  }
  return layouts;
}

export async function render(
    siteData: LocalSiteData, 
    resolution: PageResolutionResult,
    siteRootPath: string
): Promise<string> {
  const themeId = siteData.manifest.theme.name;
  const themeType = siteData.manifest.theme.type;
  const themePath = `/themes/${themeType}/${themeId}`;

  registerHelpers();
  await registerPartials(themeId, themeType);
  
  const baseTemplate = await getTemplate(`${themePath}/base.hbs`);
  const navLinks = generateNavLinks(siteData, { isStaticExport: false, siteRootPath });

  let bodyHtml = '<h1>Error</h1><p>Could not render content.</p>';
  let pageTitle = 'Error';

  const context: Partial<TemplateContext> = {
      manifest: siteData.manifest,
      themeConfig: siteData.manifest.theme.config,
      navLinks,
      year: new Date().getFullYear(),
  };

  switch(resolution.type) {
    case PageType.SinglePage: {
        const layoutTemplatePath = `${themePath}/layouts/${resolution.layout}/item.hbs`;
        const layoutTemplate = await getTemplate(layoutTemplatePath);
        
        pageTitle = resolution.pageTitle;
        context.frontmatter = resolution.contentFile.frontmatter;
        context.contentHtml = await marked.parse(resolution.contentFile.content);
        bodyHtml = layoutTemplate(context);
        break;
    }
    case PageType.Collection: {
        const layoutTemplatePath = `${themePath}/layouts/${resolution.layout}/index.hbs`;
        const layoutTemplate = await getTemplate(layoutTemplatePath);
        
        pageTitle = resolution.pageTitle;
        context.collectionNode = resolution.collectionNode;
        context.items = resolution.items.map(item => ({
            ...item,
            contentHtml: marked.parse(item.content)
        }));
        bodyHtml = layoutTemplate(context);
        break;
    }
    case PageType.NotFound: {
        pageTitle = 'Not Found';
        bodyHtml = `<h1>404 - Not Found</h1><p>${resolution.errorMessage}</p>`;
        break;
    }
  }

  context.body = bodyHtml;
  context.pageTitle = pageTitle;

  return baseTemplate(context as TemplateContext);
}

================================================================================

File: lib/localSiteFs.ts
// src/lib/localSiteFs.ts

import { LocalSiteData, Manifest, ParsedMarkdownFile } from '@/types';
import { parseMarkdownString } from './markdownParser';

const LOCAL_STORAGE_KEY = 'signum-sites-data';

function _isBrowser(): boolean {
  return typeof window !== 'undefined';
}

function _readAllSitesFromStorage(): LocalSiteData[] {
  if (!_isBrowser()) return [];
  try {
    const jsonData = localStorage.getItem(LOCAL_STORAGE_KEY);
    return jsonData ? JSON.parse(jsonData) : [];
  } catch (error) {
    console.error("Error reading sites from localStorage:", error);
    return [];
  }
}

function _writeAllSitesToStorage(sites: LocalSiteData[]): void {
  if (!_isBrowser()) return;
  try {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(sites));
  } catch (error) {
    console.error("Error writing sites to localStorage:", error);
  }
}

export async function loadAllSites(): Promise<LocalSiteData[]> {
  return Promise.resolve(_readAllSitesFromStorage());
}

export async function getSiteById(siteId: string): Promise<LocalSiteData | null> {
  const sites = _readAllSitesFromStorage();
  const site = sites.find(s => s.siteId === siteId);
  return Promise.resolve(site || null);
}

export async function saveSite(siteData: LocalSiteData): Promise<void> {
  const sites = _readAllSitesFromStorage();
  const existingSiteIndex = sites.findIndex(s => s.siteId === siteData.siteId);
  if (existingSiteIndex > -1) {
    sites[existingSiteIndex] = siteData;
  } else {
    sites.push(siteData);
  }
  _writeAllSitesToStorage(sites);
  return Promise.resolve();
}

export async function deleteSite(siteId: string): Promise<void> {
  let sites = _readAllSitesFromStorage();
  sites = sites.filter(s => s.siteId !== siteId);
  _writeAllSitesToStorage(sites);
  return Promise.resolve();
}

// REPLACES saveSiteConfig
export async function saveManifest(siteId: string, manifest: Manifest): Promise<void> {
  const sites = _readAllSitesFromStorage();
  const siteIndex = sites.findIndex(s => s.siteId === siteId);
  if (siteIndex > -1) {
    sites[siteIndex].manifest = manifest;
    _writeAllSitesToStorage(sites);
  } else {
    throw new Error(`Site with ID ${siteId} not found for saving manifest.`);
  }
  return Promise.resolve();
}

export async function saveContentFile(siteId: string, path: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile | undefined> {
  const sites = _readAllSitesFromStorage();
  const siteIndex = sites.findIndex(s => s.siteId === siteId);
  if (siteIndex > -1) {
    try {
      const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
      const fileSlug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
      const newOrUpdatedFile: ParsedMarkdownFile = {
        slug: fileSlug,
        path: path,
        frontmatter: frontmatter,
        content: content,
      };
      const contentFileIndex = sites[siteIndex].contentFiles.findIndex(f => f.path === path);
      if (contentFileIndex > -1) {
        sites[siteIndex].contentFiles[contentFileIndex] = newOrUpdatedFile;
      } else {
        sites[siteIndex].contentFiles.push(newOrUpdatedFile);
      }
      _writeAllSitesToStorage(sites);
      return Promise.resolve(newOrUpdatedFile);
    } catch (parseError) {
      console.error(`Error parsing markdown for ${path} in site ${siteId}:`, parseError);
      return Promise.resolve(undefined);
    }
  } else {
    console.warn(`Site with ID ${siteId} not found for saving content file.`);
    return Promise.resolve(undefined);
  }
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
  const sites = _readAllSitesFromStorage();
  const siteIndex = sites.findIndex(s => s.siteId === siteId);
  if (siteIndex > -1) {
    sites[siteIndex].contentFiles = sites[siteIndex].contentFiles.filter(f => f.path !== filePath);
    _writeAllSitesToStorage(sites);
  } else {
    console.warn(`Site with ID ${siteId} not found for deleting content file.`);
  }
  return Promise.resolve();
}

================================================================================

File: lib/navigationUtils.ts
// src/lib/navigationUtils.ts
import { LocalSiteData, NavLinkItem, StructureNode } from '@/types';

function buildNavLinks(nodes: StructureNode[], basePath: string, isStaticExport: boolean): NavLinkItem[] {
  return nodes
    .filter(node => node.navOrder !== undefined) // Only include items marked for navigation
    .sort((a, b) => (a.navOrder || 0) - (b.navOrder || 0))
    .map(node => {
      let href = '';
      if (isStaticExport) {
        href = node.type === 'page' && node.slug !== 'index'
          ? `${basePath}/${node.slug}.html`
          : `${basePath}/${node.slug}/index.html`;
      } else {
        href = `${basePath}/${node.slug}`;
      }
      
      return {
        href: href.replace(/\/index$/, '').replace(/\/\//g, '/') || '/',
        label: node.title,
        children: node.children ? buildNavLinks(node.children, `${basePath}/${node.slug}`, isStaticExport) : [],
      };
    });
}

export function generateNavLinks(
  siteData: LocalSiteData,
  options: { isStaticExport: boolean; siteRootPath: string }
): NavLinkItem[] {
  const { structure } = siteData.manifest;
  return buildNavLinks(structure, options.siteRootPath, options.isStaticExport);
}

================================================================================

