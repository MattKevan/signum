FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: ios, public, node_modules
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html, *.json, *.hbs
================================================================================

File: types/index.ts
// src/types/index.ts

/**
 * Represents a node in the site's hierarchical structure, as defined in `manifest.json`.
 * Can represent a standard page or a page that also acts as a collection container.
 */
export interface StructureNode {
  type: 'page' | 'collection'; // A page is a file, a collection is a virtual folder.
  title: string;
  path: string; // For pages, this is a file path. For collections, a directory path.
  slug: string;
  navOrder?: number;
  children?: StructureNode[];
  layout: string; // Layout for the page itself, or 'none' for a collection.
  itemLayout?: string; // Default layout for children within this collection.
  [key: string]: unknown;
}

/**
 * Represents the theme configuration saved in the manifest, including
 * the theme's name and any user-defined overrides.
 */
export interface ThemeConfig {
  name: string;
  config: {
    [key: string]: string | boolean | number;
  };
}

/**
 * Represents metadata for a layout asset, used for populating UI selectors.
 */
export interface LayoutInfo {
  id: string;
  name: string;
  // 'page' is for standard content pages.
  // 'view' is for pages that list content.
  // 'item' is for rendering a single item within a view list.
  type: 'page' | 'view' | 'item';
  path: string;
  description?: string;
}

/**
 * Represents metadata for a theme asset, used for populating UI selectors.
 */
export interface ThemeInfo {
  id: string;
  name: string;
  path: string;
}

/**
 * Defines the structure for a remote data source query (future feature).
 */
export interface DataSourceConfig {
  url: string;
  format: 'json' | 'csv';
  array_path?: string; // e.g., "results.items" for nested JSON
}

/**
 * Defines the configuration for a View, stored in a page's frontmatter.
 * It specifies the view template and the data source for the content list.
 */
export interface ViewConfig {
  template: string; // The ID of the /views/ asset to use (e.g., "list")
  source_collection?: string; // The slug of an internal collection
  data_source?: DataSourceConfig;
  item_layout: string; // The layout for items in the list (e.g., "teaser")
  item_page_layout: string; // The layout for the full page of an item (e.g., "page")

  // Standard query parameters
  sort_by?: string;
  sort_order?: 'asc' | 'desc';
  show_pager?: boolean;
  items_per_page?: number;
  
  // Future extensibility for filtering
  filter?: {
    field: string;
    operator: 'eq' | 'neq' | 'contains';
    value: string | number | boolean;
  }[];
}

/**
 * Represents metadata for a view asset, used for populating UI selectors.
 */
export interface ViewInfo {
  id: string;      // The directory name, e.g., "list"
  name: string;    // The user-friendly name from its manifest, e.g., "Simple List"
  path: string;    // The directory name, same as id
}

/**
 * Represents the fields within a content file's YAML frontmatter.
 */
export interface MarkdownFrontmatter {
  title: string;
  layout: string; // The layout for this specific page's content.
  view?: ViewConfig; // Optional view configuration block.
  [key: string]: unknown;
}

/**
 * Represents a raw markdown file that has been parsed from storage into its constituent parts.
 */
export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

/**
 * Represents a generic raw file (e.g., theme CSS, layout JSON) read from storage.
 */
export interface RawFile {
  path: string;
  content: string;
}

/**
 * Represents the data required for rendering pager controls.
 */
export interface PaginationData {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    hasPrevPage: boolean;
    hasNextPage: boolean;
    prevPageUrl?: string;
    nextPageUrl?: string;
}

/**
 * Represents the main `manifest.json` file for a single site. This is the
 * top-level configuration and site map.
 */
export interface Manifest {
  siteId: string;
  generatorVersion: string;
  title: string;
  description: string;
  author?: string;
  baseUrl?: string;
  theme: ThemeConfig;
  structure: StructureNode[];
  layouts?: LayoutInfo[];
  themes?: ThemeInfo[];
}

/**
 * Represents the complete data for a single site when held in the application's memory.
 */
export interface LocalSiteData {
  siteId: string;
  manifest: Manifest;
  contentFiles?: ParsedMarkdownFile[];
  layoutFiles?: RawFile[];
  themeFiles?: RawFile[];
  // Future: viewFiles?: RawFile[]
}

/**
 * Represents a link used for rendering navigation menus.
 * This is a derived type, not part of the core manifest data.
 */
export interface NavLinkItem {
  href: string;
  label: string;
  isActive?: boolean;
  children?: NavLinkItem[];
}

/**
 * An enum to clearly distinguish the outcome of a page resolution attempt.
 */
export enum PageType {
  SinglePage,
  NotFound,
}

/**
 * Represents the complete, resolved data package for a single page render.
 * This object is the output of the pageResolver and the input for the themeEngine.
 */
export type PageResolutionResult = {
  type: PageType.SinglePage;
  pageTitle: string;
  contentFile: ParsedMarkdownFile;
  layoutPath: string;
  viewItems?: ParsedMarkdownFile[];
  pagination?: PaginationData;
} | {
  type: PageType.NotFound;
  errorMessage: string;
};

================================================================================

File: core/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/state/uiStore.ts
// src/core/state/uiStore.ts

import { create, StateCreator } from 'zustand';
import { ReactNode } from 'react';

// --- Helper for screen size ---
const isDesktopView = () => typeof window !== 'undefined' && window.innerWidth >= 1024;

// --- Type Definitions for the store structure ---

// Defines the shape of the data in the sidebar slice
interface SidebarState {
  isLeftOpen: boolean;
  isRightOpen: boolean;
  isLeftAvailable: boolean;
  isRightAvailable: boolean;
  leftSidebarContent: ReactNode | null;
  rightSidebarContent: ReactNode | null;
}

// Defines the actions available in the sidebar slice
interface SidebarActions {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  setLeftAvailable: (available: boolean) => void;
  setRightAvailable: (available: boolean) => void;
  setRightOpen: (isOpen: boolean) => void;
  setLeftSidebarContent: (content: ReactNode | null) => void;
  setRightSidebarContent: (content: ReactNode | null) => void;
}

// Defines the shape of the data in the screen slice
interface ScreenState {
  isDesktop: boolean;
}

// Defines the actions available in the screen slice
interface ScreenActions {
    initializeScreenSize: () => void;
}

// The full store shape, combining state and actions
type UIState = {
    sidebar: SidebarState & SidebarActions;
    screen: ScreenState & ScreenActions;
}

// --- Store Slice Implementations ---

// Creates the sidebar slice of the store
const createSidebarSlice: StateCreator<UIState, [], [], { sidebar: SidebarState & SidebarActions }> = (set, get) => ({
  sidebar: {
    isLeftOpen: isDesktopView(),
    isRightOpen: isDesktopView(),
    isLeftAvailable: false,
    isRightAvailable: false,
    leftSidebarContent: null,
    rightSidebarContent: null,
    toggleLeftSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isLeftOpen: !state.sidebar.isLeftOpen, 
            // On mobile, opening one sidebar closes the other
            isRightOpen: !get().screen.isDesktop && !state.sidebar.isLeftOpen ? false : state.sidebar.isRightOpen 
        }
    })),
    toggleRightSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isRightOpen: !state.sidebar.isRightOpen, 
            isLeftOpen: !get().screen.isDesktop && !state.sidebar.isRightOpen ? false : state.sidebar.isLeftOpen 
        }
    })),
    setLeftAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isLeftAvailable: available }})),
    setRightAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isRightAvailable: available }})),
    setRightOpen: (isOpen) => set(state => ({ sidebar: { ...state.sidebar, isRightOpen: isOpen }})),
    setLeftSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, leftSidebarContent: content }})),
    setRightSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, rightSidebarContent: content }})),

  }
});

// Creates the screen slice of the store
const createScreenSlice: StateCreator<UIState, [], [], { screen: ScreenState & ScreenActions }> = (set, get) => ({
    screen: {
        isDesktop: isDesktopView(),
        initializeScreenSize: () => {
          if (typeof window === 'undefined') return;

          const handleResize = () => {
            const desktop = isDesktopView();
            // Only update state if the view mode has actually changed
            if (desktop !== get().screen.isDesktop) {
              set({ 
                  screen: { ...get().screen, isDesktop: desktop }, 
                  // When the breakpoint is crossed, reset sidebars to default for that size
                  sidebar: { ...get().sidebar, isLeftOpen: desktop, isRightOpen: desktop }
                });
            }
          };
          window.addEventListener('resize', handleResize);
          handleResize(); // Set initial state on mount
        },
    }
});


// Combine the slices to create the final store
export const useUIStore = create<UIState>()((...a) => ({
    ...createSidebarSlice(...a),
    ...createScreenSlice(...a),
}));

================================================================================

File: core/state/useAppStore.ts
// src/stores/useAppStore.ts
import { create } from 'zustand';
import { produce, enableMapSet } from 'immer';
import { SiteSlice, createSiteSlice } from './slices/siteSlice';
import { ContentSlice, createContentSlice } from './slices/contentSlice';
import { CollectionSlice, createCollectionSlice } from './slices/collectionSlice';

// Enable Immer for Map and Set support
enableMapSet();

// The full store type is an intersection of all slice types
type AppStore = SiteSlice & ContentSlice & CollectionSlice & {
  isInitialized: boolean;
  initialize: () => void;
};

export const useAppStore = create<AppStore>()((...a) => ({
  isInitialized: false,
  initialize: () => {
    const set = a[0]; // Zustand's `set` function
    if (a[1]().isInitialized) return;
    console.log('[AppStore] Initializing application state...');
    set({ isInitialized: true });
  },
  ...createSiteSlice(...a),
  ...createContentSlice(...a),
  ...createCollectionSlice(...a),
}));

================================================================================

File: core/state/slices/contentSlice.ts
// src/core/state/slices/contentSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { ParsedMarkdownFile, StructureNode } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { getParentPath, findNodeByPath, findAndRemoveNode, updatePathsRecursively } from '@/core/services/fileTree.service';
import { toast } from 'sonner';
import { SiteSlice } from '@/core/state/slices/siteSlice';
import { stringifyToMarkdown } from '@/lib/markdownParser';

export interface ContentSlice {
  /**
   * Creates a new content file or updates an existing one, and updates the manifest structure.
   * This function recursively finds the correct parent node to ensure items are nested correctly.
   * @param siteId - The ID of the site.
   * @param filePath - The full path of the file to save (e.g., 'content/about.md').
   * @param rawMarkdownContent - The full string content of the file, including frontmatter.
   * @param layoutId - The ID of the layout to assign to this page.
   * @returns {Promise<boolean>} True if the operation was successful.
   */
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string, layoutId: string) => Promise<boolean>;

  /**
   * Deletes a content file from storage and removes its corresponding node from the manifest structure.
   * @param {string} siteId - The ID of the site.
   * @param {string} filePath - The full path of the file to delete.
   * @returns {Promise<void>}
   */
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;
  
  /**
   * Moves a page node (and all its children) to a new parent in the site structure.
   * This is a complex transactional operation that updates file paths, manifest structure,
   * and the file system in IndexedDB.
   * @param {string} siteId - The ID of the site.
   * @param {string} draggedNodePath - The path of the page being moved.
   * @param {string | null} targetNodePath - The path of the target page to nest under, or null to un-nest to the root.
   * @returns {Promise<void>}
   */
  moveNode: (siteId: string, draggedNodePath: string, targetNodePath: string | null) => Promise<void>;

  /**
   * Updates only the content of a file in storage and state.
   * Does not modify the manifest. Used for fast autosaving.
   * @param siteId - The ID of the site.
   * @param savedFile - The parsed markdown file object to save.
   * @returns {Promise<void>}
   */
  updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile) => Promise<void>;
}

export const createContentSlice: StateCreator<SiteSlice & ContentSlice, [], [], ContentSlice> = (set, get) => ({

    updateContentFileOnly: async (siteId, savedFile) => {
    // This action ONLY updates the file content in storage and in the store.
    // It does NOT touch the manifest, making it fast for autosave.
    await localSiteFs.saveContentFile(siteId, savedFile.path, stringifyToMarkdown(savedFile.frontmatter, savedFile.content));
    
    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate?.contentFiles) {
            const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
            if (fileIndex !== -1) {
                siteToUpdate.contentFiles[fileIndex] = savedFile;
            } else {
                siteToUpdate.contentFiles.push(savedFile);
            }
        }
    }));
  },

  addOrUpdateContentFile: async (siteId, filePath, rawMarkdownContent, layoutId) => {
    const savedFile = await localSiteFs.saveContentFile(siteId, filePath, rawMarkdownContent);
    const site = get().getSiteById(siteId);
    if (!site || !site.contentFiles) return false;

    const isNewFile = !site.contentFiles.some(f => f.path === filePath);

    const newManifest = produce(site.manifest, draft => {
        let parentFound = false;
        const parentPath = getParentPath(filePath);

        // --- START OF FIX: RECURSIVE PARENT FINDER ---
        /**
         * Recursively traverses the structure to find the correct parent node
         * and adds the new file as a child.
         * @param nodes - The current array of nodes to search through.
         * @returns A new array of nodes with the update applied.
         */
        const findAndUpdateParent = (nodes: StructureNode[]): StructureNode[] => {
            return nodes.map(node => {
                // Check if this node is the parent we're looking for.
                // It can be a page or a collection.
                if (isNewFile && node.path === parentPath) {
                    parentFound = true;
                    // Add the new file as a child to this node.
                    return { 
                        ...node, 
                        children: [
                            ...(node.children || []), 
                            { 
                                type: 'page', 
                                title: savedFile.frontmatter.title, 
                                path: filePath, 
                                slug: savedFile.slug, 
                                layout: layoutId 
                            }
                        ] 
                    };
                }

                // If not the parent, check if it's the file being updated (for a title change).
                if (!isNewFile && node.path === filePath && node.title !== savedFile.frontmatter.title) {
                    return { ...node, title: savedFile.frontmatter.title };
                }

                // If this node has children, recurse into them.
                if (node.children) {
                    return { ...node, children: findAndUpdateParent(node.children) };
                }

                // Otherwise, return the node as is.
                return node;
            });
        };

        draft.structure = findAndUpdateParent(draft.structure);
        // --- END OF FIX ---

        // Handle creating a new top-level page (if parent is root 'content' folder)
        if (isNewFile && !parentFound && parentPath === 'content') {
          draft.structure.push({ type: 'page', title: savedFile.frontmatter.title, path: filePath, slug: savedFile.slug, layout: layoutId, navOrder: draft.structure.length });
        }
    });
    
    // First, commit the manifest change to storage.
    await localSiteFs.saveManifest(siteId, newManifest);

    // Then, update the in-memory state to match.
    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
            siteToUpdate.manifest = newManifest;
            if (!siteToUpdate.contentFiles) siteToUpdate.contentFiles = [];
            const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === filePath);
            if (fileIndex !== -1) {
                siteToUpdate.contentFiles[fileIndex] = savedFile;
            } else {
                siteToUpdate.contentFiles.push(savedFile);
            }
        }
    }));
    return true;
  },

  deleteContentFileAndState: async (siteId, filePath) => {
    const site = get().getSiteById(siteId);
    if (!site) return;

    // Use a recursive filter to remove the node from anywhere in the tree.
    const newManifest = produce(site.manifest, draft => {
        const filterStructure = (nodes: StructureNode[]): StructureNode[] => {
            return nodes
                .filter(node => node.path !== filePath)
                .map(node => {
                    if (node.children) {
                        node.children = filterStructure(node.children);
                    }
                    return node;
                });
        };
        draft.structure = filterStructure(draft.structure);
    });
    
    await Promise.all([
      localSiteFs.deleteContentFile(siteId, filePath),
      get().updateManifest(siteId, newManifest)
    ]);
    
    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate?.contentFiles) {
            siteToUpdate.contentFiles = siteToUpdate.contentFiles.filter(f => f.path !== filePath);
        }
    }));
  },

 moveNode: async (siteId, draggedNodePath, targetNodePath) => {
    const site = get().getSiteById(siteId);
    if (!site) {
      toast.error("Site data not found.");
      return;
    }

    const draggedNodeInfo = findNodeByPath(site.manifest.structure, draggedNodePath);
    if (!draggedNodeInfo || draggedNodeInfo.type !== 'page') {
      toast.error("Only pages can be moved.");
      return;
    }

    const targetNodeInfo = targetNodePath ? findNodeByPath(site.manifest.structure, targetNodePath) : null;
    if (targetNodePath && (!targetNodeInfo || (targetNodeInfo.type !== 'page' && targetNodeInfo.type !== 'collection'))) {
      toast.error("Pages can only be nested under other pages or collections.");
      return;
    }

    // 1. Remove the dragged node from the tree.
    const { found: draggedNode, tree: treeWithoutDraggedNode } = findAndRemoveNode([...site.manifest.structure], draggedNodePath);
    if (!draggedNode) {
      toast.error("An error occurred while moving the page.");
      return;
    }

    // 2. Recursively update paths for the dragged node and its children.
    const newParentPath = targetNodePath ? targetNodePath : 'content';
    const updatedNode = updatePathsRecursively(draggedNode, newParentPath);

    // 3. Collect all old and new paths for the file system move.
    const pathsToMove: { oldPath: string, newPath: string }[] = [];
    const collectPaths = (newNode: StructureNode, oldNode: StructureNode) => {
        pathsToMove.push({ oldPath: oldNode.path, newPath: newNode.path });
        if (newNode.children && oldNode.children) {
            newNode.children.forEach((child, i) => collectPaths(child, oldNode.children![i]));
        }
    };
    collectPaths(updatedNode, draggedNode);
    
    // 4. Perform the file move operations in IndexedDB.
    await localSiteFs.moveContentFiles(siteId, pathsToMove);
    
    // 5. Insert the updated node into its new position in the manifest structure.
    let finalTree: StructureNode[];
    if (targetNodePath) { // Nesting
        const insertIntoTree = (nodes: StructureNode[]): StructureNode[] => nodes.map(node => {
            if (node.path === targetNodePath) return { ...node, children: [...(node.children || []), updatedNode] };
            if (node.children) return { ...node, children: insertIntoTree(node.children) };
            return node;
        });
        finalTree = insertIntoTree(treeWithoutDraggedNode);
    } else { // Un-nesting to root
        finalTree = [...treeWithoutDraggedNode, updatedNode];
    }

    // 6. Commit the new manifest.
    const newManifest = { ...site.manifest, structure: finalTree };
    await get().updateManifest(siteId, newManifest);

    // 7. Trigger a full reload of the site's data to ensure UI consistency.
    await get().loadSite(siteId);
    toast.success(`Moved "${updatedNode.title}" successfully.`);
  },
});

================================================================================

File: core/state/slices/siteSlice.ts
// src/core/state/slices/siteSlice.ts
import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { LocalSiteData, Manifest } from '@/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { toast } from 'sonner';

export interface SiteSlice {
  sites: LocalSiteData[];
  loadingSites: Set<string>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
  loadSite: (siteId: string) => Promise<void>;
  addSite: (siteData: LocalSiteData) => Promise<void>;
  updateManifest: (siteId: string, manifest: Manifest) => Promise<void>;
  deleteSiteAndState: (siteId: string) => Promise<void>;
}

export const createSiteSlice: StateCreator<SiteSlice, [], [], SiteSlice> = (set, get) => ({
  sites: [],
  loadingSites: new Set(),
  getSiteById: (siteId) => get().sites.find(s => s.siteId === siteId),

  loadSite: async (siteId) => {
    if (get().loadingSites.has(siteId)) return;
    const existingSite = get().getSiteById(siteId);
    if (existingSite && existingSite.contentFiles) return;
    
    set(produce(draft => { draft.loadingSites.add(siteId); }));

    try {
      const manifest = await localSiteFs.getManifestById(siteId);
      if (!manifest) throw new Error(`Failed to load manifest for siteId: ${siteId}`);
      
      const [contentFiles, layoutFiles, themeFiles] = await Promise.all([
        localSiteFs.getSiteContentFiles(siteId),
        localSiteFs.getSiteLayoutFiles(siteId),
        localSiteFs.getSiteThemeFiles(siteId)
      ]);

      const loadedSiteData: LocalSiteData = { siteId, manifest, contentFiles, layoutFiles, themeFiles };

      set(produce((draft: SiteSlice) => {
        const siteIndex = draft.sites.findIndex(s => s.siteId === siteId);
        if (siteIndex > -1) {
          draft.sites[siteIndex] = loadedSiteData;
        } else {
          draft.sites.push(loadedSiteData);
        }
      }));
    } catch (error) {
      toast.error(`Could not load site data for ID: ${siteId}`);
      console.error(`[AppStore.loadSite] Error during load for ${siteId}:`, error);
    } finally {
      set(produce(draft => { draft.loadingSites.delete(siteId); }));
    }
  },

  addSite: async (newSiteData) => {
    await localSiteFs.saveSite(newSiteData);
    set(produce((draft: SiteSlice) => {
      if (!draft.sites.some(s => s.siteId === newSiteData.siteId)) {
        draft.sites.push(newSiteData);
      }
    }));
  },

  updateManifest: async (siteId, newManifest) => {
    await localSiteFs.saveManifest(siteId, newManifest);
    set(produce((draft: SiteSlice) => {
      const site = draft.sites.find(s => s.siteId === siteId);
      if (site) site.manifest = newManifest;
    }));
  },

  deleteSiteAndState: async (siteId) => {
    await localSiteFs.deleteSite(siteId);
    set(produce((draft: SiteSlice) => {
      draft.sites = draft.sites.filter(s => s.siteId !== siteId);
    }));
  },
});

================================================================================

File: core/state/slices/collectionSlice.ts
// src/core/state/slices/collectionSlice.ts

import { StateCreator } from 'zustand';
import { produce } from 'immer';
import { StructureNode } from '@/types';
import { SiteSlice } from './siteSlice';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';
import { toast } from 'sonner';

export interface CollectionSlice {
    addNewCollection: (siteId: string, name: string, slug: string) => Promise<void>;
}

export const createCollectionSlice: StateCreator<SiteSlice & CollectionSlice, [], [], CollectionSlice> = (set, get) => ({
    addNewCollection: async (siteId, name, slug) => {
        const site = get().getSiteById(siteId);
        if (!site) return;

        const newCollectionNode: StructureNode = {
            type: 'collection',
            title: name.trim(),
            path: `content/${slug}`,
            slug: slug,
            children: [],
            layout: 'none', // Collections no longer have a primary layout
            itemLayout: DEFAULT_PAGE_LAYOUT_PATH,
        };
        
        const newManifest = produce(site.manifest, draft => {
            draft.structure.push(newCollectionNode);
        });
        
        await get().updateManifest(siteId, newManifest);
        toast.success(`Collection "${name.trim()}" created.`);
    },
});

================================================================================

File: core/components/Navbar.tsx
// src/components/core/Navbar.tsx
'use client';

import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation'; // Import useRouter
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input'; // Import Input
import React, { useState } from 'react';

// ... (NavLink component remains the same) ...
const NavLink: React.FC<{ href: string; label: string; icon?: React.ReactNode; }> = ({ href, label, icon }) => {
  const pathname = usePathname();
  const isActive = pathname === href || (href !== '/' && pathname.startsWith(href));
  return (
    <Button  className={`justify-start ${isActive ? 'bg-accent text-accent-foreground' : ''}`}>
      <Link href={href} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};


export default function Navbar() {
  const router = useRouter();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim()); // Basic URL validation
        // We need a way to signify this is a remote URL to our browsing pages.
        // Option 1: Special prefix for siteId, e.g., "remote::http://localhost:8080"
        // Option 2: A different route, e.g., /browse/remote?url=...
        // Option 3: Pass state via router.push (can be complex with SSR/layouts)

        // Let's use Option 1: Prefix the siteId with "remote@" or similar marker
        // and encode the URL. The browsing page will then decode it.
        const encodedUrl = encodeURIComponent(url.origin); // Use origin (scheme + hostname + port)
        router.push(`/remote@${encodedUrl}`); // Navigate to /remote@http%3A%2F%2Flocalhost%3A8080
        setRemoteUrl(''); // Clear input
      } catch (error) {
        alert("Invalid URL entered.");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        <Link href="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
        </Link>
        
        {/* Remote Site URL Input */}
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Signum site URL (e.g., http://localhost:8080)"
              className="pl-9" // Padding for the icon
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          <NavLink href="/" label="Dashboard" icon={<Home className="h-4 w-4" />} />
          {/* ... other links ... */}
        </nav>

        <div className="md:hidden">
          <Button  >
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: core/components/Footer.tsx
// src/components/core/Footer.tsx
import Link from 'next/link';
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p>Â© {currentYear} Signum Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: core/components/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: core/components/ErrorBoundary.tsx
// src/components/core/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    // Update state so the next render will show the fallback UI.
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // You can also log the error to an error reporting service
    console.error("Uncaught error:", error, errorInfo);
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: undefined });
    // Optionally, you could try to trigger a reload or navigate home
    // window.location.assign('/'); 
  }

  public render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center bg-destructive/10 border border-destructive rounded-lg">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h1 className="text-2xl font-bold text-destructive-foreground">Something went wrong.</h1>
          <p className="text-muted-foreground mt-2 mb-4">
            An unexpected error occurred. Please try refreshing the page.
          </p>
          {this.state.error && (
            <details className="w-full max-w-lg text-left bg-background p-2 rounded border mb-4">
                <summary className="cursor-pointer text-sm font-medium">Error Details</summary>
                <pre className="mt-2 text-xs text-muted-foreground whitespace-pre-wrap break-all">
                    {this.state.error.message}
                </pre>
            </details>
          )}
          <Button onClick={() => window.location.reload()} variant="destructive">
            Refresh Page
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

================================================================================

File: core/components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/components/ui/link.tsx
import * as Headless from '@headlessui/react'
import NextLink, { type LinkProps } from 'next/link'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: LinkProps & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <NextLink {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})

================================================================================

File: core/components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: core/components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: core/components/ui/accordion.tsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex border-b">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 text-xs font-semibold uppercase tracking-wider text-muted-foreground transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 py-2 px-2",
          className
        )}
        {...props}
      >
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0 transition-transform duration-200 mr-1" />
        {children}
        
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm py-4 px-3"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================

File: core/components/ui/switch.tsx
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


================================================================================

File: core/components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: core/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: core/components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: core/components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: core/components/ui/input.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: core/hooks/useAutosave.ts
// src/hooks/useAutosave.ts
'use client';

import { useEffect, useRef } from 'react';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';

interface AutosaveParams<TData> {
  /** The generic data to be saved. */
  dataToSave: TData;
  /** A flag indicating if there are pending changes. */
  hasUnsavedChanges: boolean;
  /** A flag to prevent saving if the content isn't in a saveable state. */
  isSaveable: boolean;
  /** The function that performs the save operation with the generic data. */
  onSave: (data: TData) => Promise<void>;
}

/**
 * A generic custom hook to handle autosaving content after a specified delay.
 * It encapsulates the timer logic and effect management for saving drafts.
 */
export function useAutosave<TData>({ dataToSave, hasUnsavedChanges, isSaveable, onSave }: AutosaveParams<TData>) {
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (autosaveTimeoutRef.current) {
      clearTimeout(autosaveTimeoutRef.current);
    }

    if (hasUnsavedChanges && isSaveable) {
      autosaveTimeoutRef.current = setTimeout(() => {
        onSave(dataToSave);
      }, AUTOSAVE_DELAY);
    }

    return () => {
      if (autosaveTimeoutRef.current) {
        clearTimeout(autosaveTimeoutRef.current);
      }
    };
  }, [dataToSave, hasUnsavedChanges, isSaveable, onSave]);
}

================================================================================

File: core/hooks/useInitialiseUIStore.ts
'use client';

import { useUIStore } from '@/core/state/uiStore';
import { useEffect } from 'react';

export function useInitialiseUIStore() {
  const initialize = useUIStore((state) => state.screen.initializeScreenSize);
  const isInitialized = useUIStore((state) => state.screen.isInitialized);

  useEffect(() => {
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);
}   

================================================================================

File: core/services/configHelpers.service.ts
// src/core/services/configHelpers.service.ts

import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { CORE_LAYOUTS, CORE_THEMES, BASE_SCHEMA, CORE_VIEWS } from '@/config/editorConfig';
import {
    LocalSiteData,
    Manifest,
    LayoutInfo,
    ThemeInfo,
    ViewInfo,
    RawFile,
} from '@/types';

// --- Type Definitions ---

export type StrictUiSchema = UiSchema & { 'ui:groups'?: { title: string; fields: string[] }[] };

export type AssetFileType = 
  | 'manifest' 
  | 'base'              // A theme's main HTML shell
  | 'template'          // A generic template (used by Views)
  | 'partial' 
  | 'stylesheet' 
  | 'script' 
  | 'asset';

export interface AssetFile {
  path: string;
  type: AssetFileType;
  name?: string; // User-friendly name for UI selectors
}

/** The base properties shared by all asset manifests. */
export interface BaseAssetManifest {
  name: string;
  version: string;
  description?: string;
  icon?: string;
  files: AssetFile[];
}

/** The structure of a theme.json file. */
export interface ThemeManifest extends BaseAssetManifest {
  appearanceSchema?: RJSFSchema;
}

/** The structure of a layout.json file. */
export interface LayoutManifest extends BaseAssetManifest {
  layoutType: 'page' | 'view' | 'item';
  schema?: RJSFSchema; // Optional schema for a layout's own settings.
  uiSchema?: StrictUiSchema;
}

/** The structure of a view.json file. */
export interface ViewManifest extends BaseAssetManifest {
  // The schema for the form that configures this View in the editor UI.
  schema: RJSFSchema;
}


export type SiteDataForAssets = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;

// --- Helper Functions ---

const fileContentCache = new Map<string, Promise<string | null>>();

const isCoreTheme = (path: string) => CORE_THEMES.some((t: ThemeInfo) => t.path === path);
const isCoreLayout = (path: string) => CORE_LAYOUTS.some((l: LayoutInfo) => l.path === path);
const isCoreView = (path: string) => CORE_VIEWS.some((v: ViewInfo) => v.path === path);

/**
 * Provides a base schema for all content, ensuring common fields like
 * date and status are available without being redefined in every layout.
 * @returns An object containing the base RJSFSchema and UiSchema.
 */
function getBaseSchema(): { schema: RJSFSchema, uiSchema: UiSchema } {
    return BASE_SCHEMA;
}

/**
 * Fetches the raw string content of a theme or layout asset.
 * It intelligently fetches from either the `/public` directory (for core assets)
 * or the `LocalSiteData` object (for user-provided custom assets), with caching.
 * @param {SiteDataForAssets} siteData - A lean version of the site data.
 * @param {'theme' | 'layout' | 'view'} assetType - The type of asset to fetch.
 * @param {string} path - The path/ID of the theme or layout (e.g., 'default').
 * @param {string} fileName - The name of the file to fetch (e.g., 'base.hbs').
 * @returns {Promise<string | null>} The raw file content or null if not found.
 */
export async function getAssetContent(siteData: SiteDataForAssets, assetType: 'theme' | 'layout' | 'view', path: string, fileName: string): Promise<string | null> {
 let isCore = false;
    if (assetType === 'theme') {
        isCore = isCoreTheme(path);
    } else if (assetType === 'layout') {
        isCore = isCoreLayout(path);
    } else if (assetType === 'view') {
        isCore = isCoreView(path);
    }    
    
    const sourcePath = `/${assetType}s/${path}/${fileName}`;

    if (isCore) {
      // This part is correct. It fetches from /public/...
      if (fileContentCache.has(sourcePath)) {
        return fileContentCache.get(sourcePath)!;
      }
      const promise = fetch(sourcePath)
        .then(res => res.ok ? res.text() : null)
        .catch(() => null);
      fileContentCache.set(sourcePath, promise);
      return promise;
    } else {
      // This is for custom assets stored in siteData.
      // We need to check for a new `viewFiles` array here in the future.
      const fileStore: RawFile[] | undefined = 
          assetType === 'theme' ? siteData.themeFiles 
          : assetType === 'layout' ? siteData.layoutFiles
          : undefined; // <-- Future: siteData.viewFiles
      
      const fullPath = `${assetType}s/${path}/${fileName}`;
      return fileStore?.find(f => f.path === fullPath)?.content ?? null;
    }
}

/**
 * A generic function to fetch and parse any JSON asset manifest (theme, layout, view).
 * @param {SiteDataForAssets} siteData - Lean site data.
 * @param {'theme' | 'layout' | 'view'} assetType - The type of asset manifest to fetch.
 * @param {string} path - The path/ID of the asset.
 * @param {string} fileName - The name of the JSON manifest file.
 * @returns {Promise<T | null>} The parsed JSON object, or null if not found or invalid.
 */
export async function getJsonAsset<T>(siteData: SiteDataForAssets, assetType: 'theme' | 'layout' | 'view', path: string, fileName: string): Promise<T | null> {
    const content = await getAssetContent(siteData, assetType, path, fileName);
    if (!content) return null;
    try {
      return JSON.parse(content) as T;
    } catch (e) {
      console.error(`Failed to parse JSON from ${assetType}/${path}/${fileName}:`, e);
      return null;
    }
}

/**
 * Merges a layout's specific schema with the universal base schema.
 * @param {RJSFSchema} base - The base schema with common fields.
 * @param {RJSFSchema | undefined} specific - The layout's own schema.
 * @returns {RJSFSchema} The combined schema.
 */
function mergeSchemas(base: RJSFSchema, specific?: RJSFSchema): RJSFSchema {
    if (!specific) return { ...base };
    return {
        ...base,
        ...specific,
        properties: { ...(base.properties || {}), ...(specific.properties || {}) },
        required: [...new Set([...(base.required || []), ...(specific.required || [])])]
    };
}

// --- Public API ---

/**
 * Gets a list of all available themes (core and custom).
 * @param {Manifest | undefined} manifest - The site's manifest.
 * @returns {ThemeInfo[]} A list of themes for use in UI selectors.
 */
export function getAvailableThemes(manifest?: Manifest): ThemeInfo[] {
  const available = [...CORE_THEMES];
  if (manifest?.themes) {
    const customThemes = manifest.themes.filter(ct => !available.some(coreT => coreT.path === ct.path));
    available.push(...customThemes);
  }
  return available;
}

/**
 * Fetches and processes the manifest for a specific layout, merging its
 * schema with the base content schema.
 * @param {SiteDataForAssets} siteData - Lean site data.
 * @param {string} layoutPath - The path/ID of the layout to fetch.
 * @returns {Promise<LayoutManifest | null>} The processed layout manifest.
 */
export async function getLayoutManifest(siteData: SiteDataForAssets, layoutPath: string): Promise<LayoutManifest | null> {
    const layoutManifest = await getJsonAsset<LayoutManifest>(siteData, 'layout', layoutPath, 'layout.json');
    const baseSchemaData = getBaseSchema();

    if (!layoutManifest) {
      // Fallback for a missing layout.json. Create a default in-memory manifest.
      // --- FIX: This object now correctly includes all required and optional properties of LayoutManifest ---
      return {
          name: layoutPath,
          version: '1.0.0',
          layoutType: 'page',
          files: [],
          schema: baseSchemaData.schema,
          uiSchema: baseSchemaData.uiSchema, // Assign to the correct property
      }
    }

    // Merge the layout's schema and uiSchema with the base schemas.
    layoutManifest.schema = mergeSchemas(baseSchemaData.schema, layoutManifest.schema);
    // The specific layout's uiSchema overrides the base uiSchema.
    layoutManifest.uiSchema = { ...baseSchemaData.uiSchema, ...(layoutManifest.uiSchema || {}) };
    
    // Clean up properties that are handled by dedicated UI fields, not the generic form.
    if (layoutManifest.schema?.properties) {
      delete layoutManifest.schema.properties.title;
      delete layoutManifest.schema.properties.description;
      delete layoutManifest.schema.properties.slug;
    }

    return layoutManifest;
}

/**
 * Gets a list of all available views (core and eventually custom).
 * For now, it returns a hardcoded list of core views from /public/views/.
 * @returns {ViewInfo[]} A list of views for use in UI selectors.
 */
// FIX: The unused '_manifest' parameter has been completely removed from the function signature.
export function getAvailableViews(): ViewInfo[] {
  // In the future, this could be expanded to scan for custom views in a manifest.
  // The manifest would be passed back in as a parameter at that time.
  const coreViews: ViewInfo[] = [
    { id: 'list', name: 'Simple List View', path: 'list' },
  ];
  return coreViews;
}
/**
 * Gets a list of the full manifest objects for all available layouts,
 * optionally filtered by a specific layout type.
 * @param {SiteDataForAssets} siteData - Lean site data needed to fetch custom layouts.
 * @param {LayoutManifest['layoutType']} [type] - Optional type to filter by.
 * @returns {Promise<LayoutManifest[]>} A promise that resolves to a list of full layout manifests.
 */
export async function getAvailableLayouts(
  siteData: SiteDataForAssets, 
  type?: LayoutManifest['layoutType']
): Promise<LayoutManifest[]> {
  const coreLayoutIds = CORE_LAYOUTS.map(l => l.id);
  const customLayoutIds = siteData.manifest.layouts?.map(l => l.id) || [];
  const allLayoutIds = [...new Set([...coreLayoutIds, ...customLayoutIds])];

  const manifestPromises = allLayoutIds.map(layoutId => 
    getLayoutManifest(siteData, layoutId)
  );

  const allManifests = (await Promise.all(manifestPromises))
    .filter((m): m is LayoutManifest => m !== null);

  // If a type filter was provided, apply it now.
  if (type) {
    return allManifests.filter(m => m.layoutType === type);
  }

  return allManifests;
}

================================================================================

File: core/services/siteExporter.service.ts
// src/lib/siteExporter.ts
import JSZip from 'jszip';
import { LocalSiteData, ParsedMarkdownFile, StructureNode } from '@/types';
import { stringifyToMarkdown } from '@/lib/markdownParser';
import { flattenStructureToRenderableNodes } from './fileTree.service';
import { resolvePageContent } from './pageResolver.service';
import { PageType } from '@/types';
import { render } from './theme-engine/themeEngine.service';
import { getUrlForNode } from './urlUtils.service';
import { getAssetContent, getJsonAsset, ThemeManifest, LayoutManifest } from './configHelpers.service'; 

/**
 * Escapes special XML characters in a string to make it safe for RSS/Sitemap feeds.
 * @param {unknown} str - The input string to escape.
 * @returns {string} The escaped string.
 */
function escapeForXml(str: unknown): string {
    if (str === undefined || str === null) return '';
    return String(str)
        .replace(/&/g, '&')
        .replace(/</g, '<')
        .replace(/>/g, '>')
        .replace(/"/g, '"')
        .replace(/'/g, "'");
}

/**
 * A helper function to find all files for a given asset (theme or layout)
 * by reading its manifest's `files` array, and then add them to the ZIP archive.
 * This ensures that core and custom assets are bundled with the site.
 *
 * @param {JSZip} zip - The JSZip instance to add files to.
 * @param {LocalSiteData} siteData - The complete site data, including any custom asset files.
 * @param {'theme' | 'layout'} assetType - The type of asset to bundle.
 * @param {string} assetPath - The path/ID of the asset (e.g., 'default' or 'my-custom-theme').
 */
async function bundleAsset(zip: JSZip, siteData: LocalSiteData, assetType: 'theme' | 'layout', assetPath: string) {
    const assetFolder = zip.folder('_signum')?.folder(`${assetType}s`)?.folder(assetPath);
    if (!assetFolder) return;

    // 1. Fetch the manifest for the asset (e.g., theme.json or layout.json).
    const manifest = await getJsonAsset<ThemeManifest | LayoutManifest>(siteData, assetType, assetPath, `${assetType}.json`);
    
    // 2. If the manifest has a 'files' array, iterate through it. This is our source of truth.
    if (!manifest || !manifest.files) {
        console.warn(`Asset manifest for ${assetType}/${assetPath} is missing or has no 'files' array. Skipping bundle.`);
        return;
    }

    // 3. For each file listed in the manifest, fetch its content and add it to the ZIP.
    for (const file of manifest.files) {
        const content = await getAssetContent(siteData, assetType, assetPath, file.path);
        if (content) {
            assetFolder.file(file.path, content);
        } else {
            console.warn(`Could not find content for declared file: ${assetType}s/${assetPath}/${file.path}`);
        }
    }
}


/**
 * Compiles a full Signum site into a downloadable ZIP archive, ready for deployment.
 * This function orchestrates HTML generation, source file packaging, asset bundling, and feed creation.
 * It is now "pagination-aware" and will generate multiple HTML files for paginated views.
 *
 * @param {LocalSiteData} siteData - The complete, in-memory representation of the site.
 * @returns {Promise<Blob>} A promise that resolves to a Blob containing the ZIP archive.
 */
export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
    const zip = new JSZip();
    const { manifest } = siteData;
    const allRenderableNodes = flattenStructureToRenderableNodes(manifest.structure);

    // --- 1. Generate All HTML Pages ---
    for (const node of allRenderableNodes) {
        if (node.type !== 'page') continue; // Only pages can be rendered.

        // Resolve page content once to check for pagination
        const initialResolution = resolvePageContent(siteData, node.slug.split('/'));

        if (initialResolution.type === PageType.NotFound) continue;

        const isPaginated = !!(initialResolution.pagination && initialResolution.pagination.totalPages > 1);

        if (isPaginated) {
            // --- Handle paginated views ---
            const totalPages = initialResolution.pagination!.totalPages;
            for (let i = 1; i <= totalPages; i++) {
                const pageNumber = i;
                const resolutionForPage = resolvePageContent(siteData, node.slug.split('/'), pageNumber);
                
                if (resolutionForPage.type === PageType.NotFound) continue;

                // Generate the correct file path for this specific page number
                const outputPath = getUrlForNode(node, true, pageNumber);
                const depth = (outputPath.match(/\//g) || []).length;
                const relativePrefix = '../'.repeat(depth > 0 ? depth -1 : 0);

                const finalHtml = await render(siteData, resolutionForPage, {
                    siteRootPath: '/',
                    isExport: true,
                    relativeAssetPath: relativePrefix
                });
                zip.file(outputPath, finalHtml);
            }
        } else {
            // --- Standard logic for non-paginated pages ---
            const outputPath = getUrlForNode(node, true);
            const depth = (outputPath.match(/\//g) || []).length;
            const relativePrefix = '../'.repeat(depth > 0 ? depth - 1 : 0);

            const finalHtml = await render(siteData, initialResolution, {
                siteRootPath: '/',
                isExport: true,
                relativeAssetPath: relativePrefix
            });
            zip.file(outputPath, finalHtml);
        }
    }

    // --- 2. Add _signum Source Content and Asset Files ---
    const signumFolder = zip.folder('_signum');
    if (signumFolder) {
        signumFolder.file('manifest.json', JSON.stringify(manifest, null, 2));
        (siteData.contentFiles ?? []).forEach(file => {
            signumFolder.file(file.path, stringifyToMarkdown(file.frontmatter, file.content));
        });
    }

    const activeThemePath = manifest.theme.name;
    const uniqueLayoutPaths = [...new Set(allRenderableNodes.map(n => n.layout).filter(Boolean))];

    await bundleAsset(zip, siteData, 'theme', activeThemePath);
    for (const layoutPath of uniqueLayoutPaths) {
        if (layoutPath !== 'none') {
             await bundleAsset(zip, siteData, 'layout', layoutPath);
        }
    }
    
    // --- 3. Generate RSS Feed and Sitemap (these should only link to the first page of a list) ---
    const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
    const contentFiles = siteData.contentFiles ?? [];
    const allPageNodes = allRenderableNodes.filter((n: StructureNode): n is StructureNode & { type: 'page' } => n.type === 'page');
    type RssItemData = { node: StructureNode, file: ParsedMarkdownFile };

    const rssItems = allPageNodes
        .map((pNode): RssItemData | null => {
            const file = contentFiles.find(f => f.path === pNode.path);
            return file ? { node: pNode, file } : null;
        })
        .filter((item): item is RssItemData => item !== null && !!item.file.frontmatter.date && !item.file.frontmatter.view) // Exclude view pages from RSS items
        .sort((a, b) => new Date(b.file.frontmatter.date as string).getTime() - new Date(a.file.frontmatter.date as string).getTime())
        .slice(0, 20)
        .map((item) => {
            const relativeUrl = getUrlForNode(item.node, true);
            const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
            const description = escapeForXml(item.file.frontmatter.summary);
            const pubDate = new Date(item.file.frontmatter.date as string).toUTCString();
            return `<item><title>${escapeForXml(item.node.title)}</title><link>${escapeForXml(absoluteUrl)}</link><guid isPermaLink="true">${escapeForXml(absoluteUrl)}</guid><pubDate>${pubDate}</pubDate><description>${description}</description></item>`;
        }).join('');

    const rssFeed = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(manifest.title)}</title><link>${siteBaseUrl}</link><description>${escapeForXml(manifest.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrl).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;
    zip.file('rss.xml', rssFeed);
    
    const sitemapUrls = allPageNodes.map((node) => {
        const file = contentFiles.find(f => f.path === node.path);
        const relativeUrl = getUrlForNode(node, true);
        const absoluteUrl = new URL(relativeUrl, siteBaseUrl).href;
        const lastMod = (file?.frontmatter.date as string || new Date().toISOString()).split('T')[0];
        return `<url><loc>${escapeForXml(absoluteUrl)}</loc><lastmod>${lastMod}</lastmod></url>`;
    }).join('');

    const sitemapXml = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
    zip.file('sitemap.xml', sitemapXml);

    // --- 4. Generate the Final ZIP file ---
    return zip.generateAsync({ type: 'blob' });
}

================================================================================

File: core/services/urlUtils.service.ts
// src/core/services/urlUtils.service.ts

/**
 * Generates a URL for a given site node, correctly handling index cases,
 * static export paths, and pagination routes.
 * 
 * @param node - An object representing a node in the site structure.
 * @param isExport - A boolean indicating if the URL is for a static export.
 * @param pageNumber - Optional page number for generating paginated links.
 * @returns A string representing the URL segment or full filename.
 */
export function getUrlForNode(
  node: { slug: string, path:string, type: 'page' | 'collection' },
  isExport: boolean,
  pageNumber?: number
): string {
    const isRootIndex = node.slug === 'index' && node.type === 'page' && !node.path.includes('/');

    if (isExport) {
        // --- EXPORT PATHS ---
        const baseName = node.path.replace(/^content\//, '').replace(/\.md$/, '');

        if (pageNumber && pageNumber > 1) {
            // For paginated routes, e.g., /blog/page/2.html
            return `${baseName}/page/${pageNumber}/index.html`;
        }
        if (isRootIndex) return 'index.html';
        if (node.type === 'collection') return `${node.slug}/index.html`;
        
        // For a view page that is the first page of a paginated list
        if (node.path.endsWith('.md')) {
            return `${baseName}/index.html`;
        }
        return `${baseName}.html`;
    }

    // --- LIVE PREVIEW PATH SEGMENTS ---
    if (pageNumber && pageNumber > 1) {
        return `${node.slug}/page/${pageNumber}`;
    }
    if (isRootIndex) return '';
    return node.path.replace(/^content\//, '').replace(/\.md$/, '').replace(/\/index$/, '');
}

================================================================================

File: core/services/relativePaths.service.ts
// src/lib/pathUtils.ts

/**
 * Calculates the relative path from one file to another.
 * This is essential for creating portable HTML that works on any server
 * or directly from the local file system.
 *
 * @example
 * // from 'index.html' to 'about.html' -> './about.html'
 * getRelativePath('index.html', 'about.html');
 *
 * @example
 * // from 'posts/post1.html' to 'index.html' -> '../index.html'
 * getRelativePath('posts/post1.html', 'index.html');
 *
 * @example
 * // from 'posts/post1.html' to 'tags/tech.html' -> '../tags/tech.html'
 * getRelativePath('posts/post1.html', 'tags/tech.html');
 *
 * @param {string} fromPath - The path of the file containing the link.
 * @param {string} toPath - The path of the file being linked to.
 * @returns {string} The calculated relative path.
 */
export function getRelativePath(fromPath: string, toPath: string): string {
  if (fromPath === toPath) {
    return toPath.split('/').pop() || '';
  }

  const fromParts = fromPath.split('/').slice(0, -1); // Path without filename
  const toParts = toPath.split('/');

  // Find the common path segment
  let commonLength = 0;
  while (
    commonLength < fromParts.length &&
    commonLength < toParts.length &&
    fromParts[commonLength] === toParts[commonLength]
  ) {
    commonLength++;
  }

  const upLevels = fromParts.length - commonLength;
  const upPath = '../'.repeat(upLevels) || './';

  const downPath = toParts.slice(commonLength).join('/');

  return upPath + downPath;
}

================================================================================

File: core/services/localFileSystem.service.ts
// src/lib/localSiteFs.ts
import { LocalSiteData, Manifest, ParsedMarkdownFile, RawFile } from '@/types'; // Ensure RawFile is imported
import localforage from 'localforage';
import { parseMarkdownString, stringifyToMarkdown } from '@/lib/markdownParser';

const DB_NAME = 'SignumDB';

const siteManifestsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteManifests',
});

const siteContentFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteContentFiles',
});

const siteLayoutFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteLayoutFiles',
});

const siteThemeFilesStore = localforage.createInstance({
    name: DB_NAME,
    storeName: 'siteThemeFiles',
});

// --- Function to load only manifests for a fast initial load ---
export async function loadAllSiteManifests(): Promise<Manifest[]> {
  const manifests: Manifest[] = [];
  await siteManifestsStore.iterate((value: Manifest) => {
    manifests.push(value);
  });
  return manifests;
}

/**
 * Fetches the manifest for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<Manifest | null>} A Promise that resolves to the Manifest object, or null if not found.
 */
export async function getManifestById(siteId: string): Promise<Manifest | null> {
  const manifest = await siteManifestsStore.getItem<Manifest>(siteId);
  return manifest ?? null;
}

/**
 * Fetches the content files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<ParsedMarkdownFile[]>} A Promise that resolves to an array of parsed markdown files.
 */
export async function getSiteContentFiles(siteId: string): Promise<ParsedMarkdownFile[]> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId);
    return contentFiles ?? [];
}

/**
 * Fetches the custom layout files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw layout files.
 */
export async function getSiteLayoutFiles(siteId: string): Promise<RawFile[]> {
    const layoutFiles = await siteLayoutFilesStore.getItem<RawFile[]>(siteId);
    return layoutFiles ?? [];
}

/**
 * Fetches the custom theme files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw theme files.
 */
export async function getSiteThemeFiles(siteId: string): Promise<RawFile[]> {
    const themeFiles = await siteThemeFilesStore.getItem<RawFile[]>(siteId);
    return themeFiles ?? [];
}

export async function saveSite(siteData: LocalSiteData): Promise<void> {
  await Promise.all([
    siteManifestsStore.setItem(siteData.siteId, siteData.manifest),
    siteContentFilesStore.setItem(siteData.siteId, siteData.contentFiles ?? []),
    siteLayoutFilesStore.setItem(siteData.siteId, siteData.layoutFiles ?? []),
    siteThemeFilesStore.setItem(siteData.siteId, siteData.themeFiles ?? []),
  ]);
}

export async function deleteSite(siteId: string): Promise<void> {
  await Promise.all([
    siteManifestsStore.removeItem(siteId),
    siteContentFilesStore.removeItem(siteId),
    siteLayoutFilesStore.removeItem(siteId),
    siteThemeFilesStore.removeItem(siteId),
  ]);
}

export async function saveManifest(siteId: string, manifest: Manifest): Promise<void> {
    await siteManifestsStore.setItem(siteId, manifest);
}

export async function saveContentFile(siteId: string, filePath: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    
    const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
    const fileSlug = filePath.substring(filePath.lastIndexOf('/') + 1).replace('.md', '');
    const savedFile: ParsedMarkdownFile = { slug: fileSlug, path: filePath, frontmatter, content };

    const fileIndex = contentFiles.findIndex(f => f.path === filePath);
    if (fileIndex > -1) {
      contentFiles[fileIndex] = savedFile;
    } else {
      contentFiles.push(savedFile);
    }
    
    await siteContentFilesStore.setItem(siteId, contentFiles);
    return savedFile;
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const updatedContentFiles = contentFiles.filter(f => f.path !== filePath);
    await siteContentFilesStore.setItem(siteId, updatedContentFiles);
}

export async function getContentFileRaw(siteId: string, filePath: string): Promise<string | null> {
    const allFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const fileData = allFiles.find(f => f.path === filePath);
    if (!fileData) return null;
    
    return stringifyToMarkdown(fileData.frontmatter, fileData.content);
}

/**
 * Moves a set of content files from old paths to new paths in a single transaction.
 * @param {string} siteId - The ID of the site.
 * @param {{oldPath: string, newPath: string}[]} pathsToMove - An array of path mapping objects.
 * @returns {Promise<void>}
 */
export async function moveContentFiles(siteId: string, pathsToMove: { oldPath: string, newPath: string }[]): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    
    const updatedFiles = contentFiles.map(file => {
        const moveInstruction = pathsToMove.find(p => p.oldPath === file.path);
        if (moveInstruction) {
            const newSlug = moveInstruction.newPath.split('/').pop()?.replace('.md', '') || '';
            return { ...file, path: moveInstruction.newPath, slug: newSlug };
        }
        return file;
    });
    
    await siteContentFilesStore.setItem(siteId, updatedFiles);
}

================================================================================

File: core/services/navigationStructure.service.ts
// src/lib/navigationUtils.ts
import { LocalSiteData, NavLinkItem, StructureNode } from '@/types';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { getRelativePath } from '@/core/services/relativePaths.service';
import { RenderOptions } from '@/core/services/theme-engine/themeEngine.service'; 

/**
 * Recursively builds a navigation link structure with context-aware paths.
 * @param nodes - The site structure nodes to build links from.
 * @param currentPagePath - The path of the page being currently rendered.
 * @param options - The render options, containing isExport and siteRootPath.
 * @returns An array of navigation link objects.
 */
function buildNavLinks(nodes: StructureNode[], currentPagePath: string, options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>): NavLinkItem[] {
  return nodes
    .filter(node => node.navOrder !== undefined)
    .sort((a, b) => (a.navOrder || 0) - (b.navOrder || 0))
    .map(node => {
      let href: string;
      const urlSegment = getUrlForNode(node, options.isExport);

      if (options.isExport) {
        // EXPORT MODE: Calculate a portable, document-relative path.
        href = getRelativePath(currentPagePath, urlSegment);
      } else {
        // PREVIEW MODE: Construct a full, absolute-style path for the SPA viewer.
        // e.g., /sites/signum-e1bry/view + / + about -> /sites/signum-e1bry/view/about
        href = `${options.siteRootPath}${urlSegment ? `/${urlSegment}` : ''}`;
      }
      
      return {
        href: href,
        label: node.title,
        children: node.children ? buildNavLinks(node.children, currentPagePath, options) : [],
      };
    });
}

/**
 * Generates the complete navigation structure for a given page.
 * @param siteData - The complete site data.
 * @param currentPagePath - The path of the HTML page being rendered (for relative calculations).
 * @param options - The full render options object.
 * @returns The final array of navigation links.
 */
export function generateNavLinks(
  siteData: LocalSiteData,
  currentPagePath: string,
  options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  const { structure } = siteData.manifest;
  return buildNavLinks(structure, currentPagePath, options);
}

================================================================================

File: core/services/pageResolver.service.ts
// src/core/services/pageResolver.service.ts

// FIX: Removed 'StructureNode' import, added 'PageResolutionResult' and 'PageType'.
import { LocalSiteData, ParsedMarkdownFile, ViewConfig, PaginationData, PageResolutionResult, PageType } from '@/types';
import { findNodeByPath } from './fileTree.service';
import { getUrlForNode } from './urlUtils.service';

/**
 * Executes a declarative query from a view's configuration.
 * This pure function takes the config and site data, finds the source collection,
 * and returns a fully sorted array of ALL matching content items.
 * Pagination/limiting is handled by the main resolver.
 * 
 * @param {ViewConfig} viewConfig - The configuration object from the page's frontmatter.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @returns {ParsedMarkdownFile[]} A sorted array of all content files that match the query.
 */
function executeQuery(viewConfig: ViewConfig, siteData: LocalSiteData): ParsedMarkdownFile[] {
  if (!viewConfig.source_collection || !siteData.contentFiles) {
    return [];
  }

  const collectionNode = siteData.manifest.structure.find(
    node => node.type === 'collection' && node.slug === viewConfig.source_collection
  );

  if (!collectionNode || !collectionNode.children) {
    console.warn(`[Query Executor] Collection with slug "${viewConfig.source_collection}" not found or is empty.`);
    return [];
  }

  const childPaths = new Set(collectionNode.children.map(child => child.path));
  
  // FIX: 'items' is never reassigned, so it can be 'const'.
  const items = siteData.contentFiles.filter(file => childPaths.has(file.path));

  // --- Sorting Logic ---
  const sortBy = viewConfig.sort_by || 'date';
  const sortOrder = viewConfig.sort_order || 'desc';
  const orderModifier = sortOrder === 'desc' ? -1 : 1;

  // Note: We use sort() which mutates the array in place. To be safer with const, we can create a copy.
  return [...items].sort((a, b) => {
    const valA = a.frontmatter[sortBy];
    const valB = b.frontmatter[sortBy];

    if (sortBy === 'date') {
        const dateA = valA ? new Date(valA as string).getTime() : 0;
        const dateB = valB ? new Date(valB as string).getTime() : 0;
        if (isNaN(dateA) || isNaN(dateB)) return 0;
        return (dateA - dateB) * orderModifier;
    }

    if (typeof valA === 'string' && typeof valB === 'string') {
        return valA.localeCompare(valB) * orderModifier;
    }

    if (typeof valA === 'number' && typeof valB === 'number') {
        return (valA - valB) * orderModifier;
    }
    return 0;
  });
}


/**
 * Finds the correct page to render based on a URL slug path.
 * If the page is a View Page, this function executes the query, handles pagination,
 * and attaches the results to the final resolution object.
 *
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {string[]} slugArray - The URL segments used for path matching.
 * @param {number} [pageNumber=1] - The current page number for pagination, typically from a URL query param.
 * @returns {PageResolutionResult} An object containing all data needed to render the page or a not-found error.
 */
export function resolvePageContent(
    siteData: LocalSiteData, 
    slugArray: string[],
    pageNumber: number = 1
): PageResolutionResult {
    const pathSuffix = slugArray.length > 0 ? slugArray.join('/') : 'index';
    const potentialPagePath = `content/${pathSuffix}.md`;

    const targetNode = findNodeByPath(siteData.manifest.structure, potentialPagePath);

    if (!targetNode || targetNode.type !== 'page') {
        return { 
            type: PageType.NotFound, 
            errorMessage: `No page found at the path /${slugArray.join('/')}. Collections themselves are not directly viewable.` 
        };
    }
    
    const contentFile = siteData.contentFiles?.find(f => f.path === targetNode.path);
    if (!contentFile) {
        return { 
            type: PageType.NotFound, 
            errorMessage: `Manifest references "${targetNode.path}" but its content file is missing.` 
        };
    }

    let viewItems: ParsedMarkdownFile[] | undefined = undefined;
    let pagination: PaginationData | undefined = undefined;

    if (contentFile.frontmatter.view) {
        const viewConfig = contentFile.frontmatter.view;
        const allItems = executeQuery(viewConfig, siteData);

        if (viewConfig.show_pager && viewConfig.items_per_page && viewConfig.items_per_page > 0) {
            const totalItems = allItems.length;
            const itemsPerPage = viewConfig.items_per_page;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const currentPage = Math.max(1, Math.min(pageNumber, totalPages));

            const startIndex = (currentPage - 1) * itemsPerPage;
            viewItems = allItems.slice(startIndex, startIndex + itemsPerPage);

            const pageUrlSegment = getUrlForNode({ ...targetNode, type: 'page' }, false);
            const baseUrl = `/${pageUrlSegment}`;

            pagination = {
                currentPage,
                totalPages,
                totalItems,
                hasPrevPage: currentPage > 1,
                hasNextPage: currentPage < totalPages,
                prevPageUrl: currentPage > 1 ? `${baseUrl}?page=${currentPage - 1}` : undefined,
                nextPageUrl: currentPage < totalPages ? `${baseUrl}?page=${currentPage + 1}` : undefined,
            };
        } else {
            viewItems = allItems;
        }
    }
  
    return {
      type: PageType.SinglePage,
      pageTitle: contentFile.frontmatter.title,
      contentFile: contentFile,
      layoutPath: contentFile.frontmatter.layout,
      viewItems: viewItems,
      pagination: pagination,
    };
}

================================================================================

File: core/services/fileTree.service.ts
// src/core/services/fileTree.service.ts

import { StructureNode } from '@/types';

/**
 * Finds a node in a structure tree by its exact `path`.
 * @param nodes The array of nodes to search within.
 * @param path The path of the node to find (e.g., "content/blog/first-post.md").
 * @returns The found StructureNode or undefined.
 */
export function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) {
      return node;
    }
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) {
        return found;
      }
    }
  }
  return undefined;
}

/**
 * Recursively traverses the structure tree and collects all nodes that are pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all page-type StructureNodes.
 */
export function flattenStructureToPages(nodes: StructureNode[]): StructureNode[] {
  let pages: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page') {
      pages.push(node);
    }
    if (node.children) {
      pages = pages.concat(flattenStructureToPages(node.children));
    }
  }
  return pages;
}

/**
 * Recursively traverses the structure tree and collects all nodes that can be rendered as a page.
 * This includes single pages AND collection listing pages.
 * @param nodes The array of nodes to traverse.
 * @returns A flat array of all renderable StructureNodes.
 */
export function flattenStructureToRenderableNodes(nodes: StructureNode[]): StructureNode[] {
  let renderableNodes: StructureNode[] = [];
  for (const node of nodes) {
    if (node.type === 'page' || node.type === 'collection') {
      renderableNodes.push(node);
    }
    if (node.children) {
      renderableNodes = renderableNodes.concat(flattenStructureToRenderableNodes(node.children));
    }
  }
  return renderableNodes;
}

/**
 * Gets the parent directory path for a given file path.
 * e.g., "content/blog/post.md" -> "content/blog"
 * @param path The full path of a file or folder.
 * @returns The path of the parent directory.
 */
export function getParentPath(path: string): string {
  if (!path.includes('/')) return 'content';
  return path.substring(0, path.lastIndexOf('/'));
}

/**
 * Finds a node by its path and removes it from a tree structure, returning both the found node and the modified tree.
 * This is a pure function; it does not mutate the original array.
 * @param {StructureNode[]} nodes - The array of nodes to search.
 * @param {string} path - The path of the node to remove.
 * @returns An object containing the found node and the updated tree.
 */
export function findAndRemoveNode(nodes: StructureNode[], path: string): { found: StructureNode | null, tree: StructureNode[] } {
  let found: StructureNode | null = null;
  
  const filterRecursively = (currentNodes: StructureNode[]): StructureNode[] => {
    const result: StructureNode[] = [];
    for (const node of currentNodes) {
      if (node.path === path) {
        found = node;
        continue; // Skip adding it to the result, effectively removing it
      }
      if (node.children) {
        const newChildren = filterRecursively(node.children);
        result.push({ ...node, children: newChildren });
      } else {
        result.push(node);
      }
    }
    return result;
  };

  const newTree = filterRecursively(nodes);
  return { found, tree: newTree };
}


/**
 * Recursively updates the path of a node and all of its descendants based on a new parent path.
 * @param {StructureNode} node - The node to start from.
 * @param {string} newParentPath - The new parent path segment (e.g., 'content/about').
 * @returns {StructureNode} The node with all paths and slugs updated.
 */
export function updatePathsRecursively(node: StructureNode, newParentPath: string): StructureNode {
  const oldSlug = node.slug;
  const newPath = `${newParentPath}/${oldSlug}.md`;
  
  const updatedNode: StructureNode = { ...node, path: newPath };

  if (updatedNode.children) {
    // The new parent path for the children is the updated node's path, without the '.md' extension.
    const newChildsParentPath = newPath.replace(/\.md$/, '');
    updatedNode.children = updatedNode.children.map(child => 
      updatePathsRecursively(child, newChildsParentPath)
    );
  }

  return updatedNode;
}

================================================================================

File: core/services/theme-engine/themeEngine.service.ts
// src/core/services/theme-engine/themeEngine.service.ts
import Handlebars from 'handlebars';
import { 
    LocalSiteData, 
    PageResolutionResult, 
    PageType 
} from '@/types';
import {
    getJsonAsset,
    getAvailableLayouts,
    getAvailableViews,
    ThemeManifest, 
    ViewManifest,
    getAssetContent,
    AssetFile,
} from '@/core/services/configHelpers.service';
import { coreHelpers } from './helpers';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { generateNavLinks } from '@/core/services/navigationStructure.service';

// --- Type Definitions ---
export interface RenderOptions {
  siteRootPath: string;
  isExport: boolean;
  relativeAssetPath?: string;
}

// --- Helper Registration ---
function registerCoreHelpers(siteData: LocalSiteData) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((Handlebars as any)._helpersRegistered) return;

    for (const helperFactory of coreHelpers) {
        const helperMap = helperFactory(siteData);
        for (const helperName in helperMap) {
            Handlebars.registerHelper(helperName, helperMap[helperName]);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Handlebars as any)._helpersRegistered = true;
}

/**
 * Pre-compiles and caches all available layout and view templates by registering them as Handlebars partials.
 * This is crucial for performance and allows helpers to synchronously access templates during rendering.
 * @param {LocalSiteData} siteData - The complete site data.
 */
async function cacheAllTemplates(siteData: LocalSiteData) {
    for (const partial in Handlebars.partials) {
        if (Object.prototype.hasOwnProperty.call(Handlebars.partials, partial)) {
            Handlebars.unregisterPartial(partial);
        }
    }

    const { manifest } = siteData;
    const allLayouts = await getAvailableLayouts(siteData); 
    const allViews = getAvailableViews();

    const assetPromises: Promise<void>[] = [];

    // Pre-cache all layout templates
    for (const layoutManifest of allLayouts) {
        const promise = (async () => {
            if (layoutManifest?.files) {
                for (const file of layoutManifest.files) {
                    // FIX: The type for a layout's main .hbs file is 'template'.
                    // This was the source of the "not found" error.
                    if (file.type === 'template') {
                        const templateSource = await getAssetContent(siteData, 'layout', layoutManifest.name, file.path);
                        if (templateSource) {
                           Handlebars.registerPartial(layoutManifest.name, templateSource);
                        }
                    }
                }
            }
        })();
        assetPromises.push(promise);
    }
    
    // Pre-cache all view templates
    for (const viewInfo of allViews) {
         const promise = (async () => {
            const viewManifest = await getJsonAsset<ViewManifest>(siteData, 'view', viewInfo.id, 'view.json');
            if (viewManifest?.files) {
                const templateFile = viewManifest.files.find((f: AssetFile) => f.type === 'template');
                if (templateFile) {
                    const templateSource = await getAssetContent(siteData, 'view', viewInfo.id, templateFile.path);
                    if (templateSource) {
                        Handlebars.registerPartial(viewInfo.id, templateSource);
                    }
                }
            }
        })();
        assetPromises.push(promise);
    }

    // Pre-cache all partials from the main theme
    const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', manifest.theme.name, 'theme.json');
    if (themeManifest?.files) {
        const themePartials = themeManifest.files.filter((file: AssetFile) => file.type === 'partial');
        for (const partial of themePartials) {
            if (partial.name) {
                const templateSource = await getAssetContent(siteData, 'theme', manifest.theme.name, partial.path);
                if (templateSource) Handlebars.registerPartial(partial.name, templateSource);
            }
        }
    }
    
    await Promise.all(assetPromises);
}


/**
 * Renders a resolved page into a full HTML string based on the active theme and assets.
 */
export async function render(siteData: LocalSiteData, resolution: PageResolutionResult, options: RenderOptions): Promise<string> {
  // 1. Setup, Helper Registration, and Template Caching
  registerCoreHelpers(siteData);
  await cacheAllTemplates(siteData);

  if (!siteData.contentFiles) {
    return 'Error: Site content has not been loaded. Cannot render page.';
  }
  if (resolution.type === PageType.NotFound) {
      return `<h1>404 - Not Found</h1><p>${resolution.errorMessage}</p>`;
  }

  const { manifest } = siteData;
  const themePath = manifest.theme.name;
  const layoutPath = resolution.layoutPath;

  // 2. Prepare Data for Rendering
  const currentPageExportPath = getUrlForNode({ ...resolution.contentFile, type: 'page' }, true);
  const navLinks = generateNavLinks(siteData, currentPageExportPath, options);
  const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';
  const canonicalUrl = new URL(currentPageExportPath, siteBaseUrl).href;
  const baseUrl = options.isExport ? (options.relativeAssetPath ?? '') : (typeof window !== 'undefined' ? window.location.origin : '');

  let styleOverrides = '';
  if (manifest.theme.config && Object.keys(manifest.theme.config).length > 0) {
      const cssVars = Object.entries(manifest.theme.config).map(([k, v]) => `--${k.replace(/_/g, '-')}: ${v};`).join(' ');
      if (cssVars) {
          styleOverrides = `<style id="signum-theme-overrides">:root { ${cssVars} }</style>`;
      }
  }

  // 3. Render Main Content Body
  const layoutTemplate = Handlebars.partials[layoutPath];
  const bodyHtml = layoutTemplate ? layoutTemplate(resolution) : `Error: Layout template '${layoutPath}' not found.`;
  
  // 4. Render Final Document
  const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', themePath, 'theme.json');
  const baseTemplatePath = themeManifest?.files.find((f: AssetFile) => f.type === 'base')?.path;
  if (!baseTemplatePath) return 'Error: Active theme is missing a template with type "base".';
  
  const baseTemplateSource = await getAssetContent(siteData, 'theme', themePath, baseTemplatePath);
  if (!baseTemplateSource) return `Error: Could not load base template source at '${baseTemplatePath}'.`;
  const baseTemplate = Handlebars.compile(baseTemplateSource);

  const headContext = {
      pageTitle: resolution.pageTitle,
      manifest: manifest,
      canonicalUrl: canonicalUrl,
      baseUrl: baseUrl,
      styleOverrides: new Handlebars.SafeString(styleOverrides)
  };

  return baseTemplate({
      manifest,
      navLinks,
      year: new Date().getFullYear(),
      headContext: headContext,
      body: new Handlebars.SafeString(bodyHtml),
      ...resolution
  });
}

================================================================================

File: core/services/theme-engine/helpers/strUtil.helper.ts
// src/lib/theme-helpers/strUtil.helper.ts
import { SignumHelper } from './types';
import { HelperOptions } from 'handlebars';

export const strUtilHelper: SignumHelper = () => ({
  /**
   * A generic string utility helper for common text manipulations.
   * @example {{str-util some.text op="truncate" len=100}}
   * @example {{str-util some.text op="uppercase"}}
   */
  'str-util': function(input: string, options: HelperOptions): string {
    if (!input || typeof input !== 'string') return '';
  
    const op = options.hash.op;
  
    switch (op) {
      case 'truncate':
        const len = options.hash.len || 140;
        if (input.length <= len) return input;
        return input.substring(0, len) + 'â¦';
      case 'uppercase':
        return input.toUpperCase();
      case 'lowercase':
        return input.toLowerCase();
      default:
        return input;
    }
  }
});

================================================================================

File: core/services/theme-engine/helpers/query.helper.ts
// src/lib/theme-helpers/query.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { ParsedMarkdownFile } from '@/types';

export const queryHelper: SignumHelper = (siteData) => ({
  /**
   * Fetches, filters, and sorts a list of content items from a collection.
   * The resulting array is made available to the inner block of the helper.
   * @param {HelperOptions} options - The Handlebars options object.
   * @returns The rendered block content.
   *
   * @example
   * {{#query source_collection="blog" limit=5 as |posts|}}
   *   {{#each posts}} ... {{/each}}
   * {{/query}}
   */
  query: function(this: any, options: Handlebars.HelperOptions) {
    const config = options.hash;

    // 1. Validate that a source collection was provided.
    const sourceCollectionSlug = config.source_collection;
    if (!sourceCollectionSlug) {
      console.warn("Query helper called without a 'source_collection'.");
      return options.inverse(this); // Render the {{else}} block if it exists.
    }

    // 2. Find the source collection node in the site's structure.
    const collectionNode = siteData.manifest.structure.find(
        n => n.type === 'collection' && n.slug === sourceCollectionSlug
    );
    if (!collectionNode || !collectionNode.children) {
      console.warn(`Query could not find collection with slug: "${sourceCollectionSlug}"`);
      return options.inverse(this);
    }
    
    // 3. Get all content files associated with that collection.
    const childPaths = new Set(collectionNode.children.map(c => c.path));
    let items = (siteData.contentFiles ?? []).filter(f => childPaths.has(f.path));

    // 4. (Future) Apply any filters here.
    // e.g., if (config.filter_by_tag) { ... }

    // 5. Sort the resulting items.
    const sortBy = config.sort_by || 'date';
    const sortOrder = config.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    items.sort((a, b) => {
      const valA = a.frontmatter[sortBy];
      const valB = b.frontmatter[sortBy];

      if (sortBy === 'date') {
        const dateA = valA ? new Date(valA as string).getTime() : 0;
        const dateB = valB ? new Date(valB as string).getTime() : 0;
        if (isNaN(dateA) || isNaN(dateB)) return 0;
        return (dateA - dateB) * orderModifier;
      }
      if (typeof valA === 'string' && typeof valB === 'string') {
        return valA.localeCompare(valB) * orderModifier;
      }
      if (typeof valA === 'number' && typeof valB === 'number') {
        return (valA - valB) * orderModifier;
      }
      return 0;
    });

    // 6. Limit the number of results.
    if (config.limit) {
      const limit = parseInt(config.limit, 10);
      if (!isNaN(limit)) {
        items = items.slice(0, limit);
      }
    }

    // 7. Render the inner block, passing the queried items as a block parameter.
    // This makes the `as |posts|` syntax work.
    if (options.data && options.fn) {
        const data = Handlebars.createFrame(options.data);
        const blockParamName = options.data.blockParams?.[0];
        if (blockParamName) {
            data[blockParamName] = items;
        }
        return options.fn(items, { data });
    }
    
    // Fallback if no block parameter is used.
    return options.fn(items);
  }
});

================================================================================

File: core/services/theme-engine/helpers/markdown.helper.ts
// src/lib/theme-helpers/markdown.helper.ts
import { SignumHelper } from './types';
import Handlebars from 'handlebars';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

export const markdownHelper: SignumHelper = () => ({
  /**
   * Safely renders a string of Markdown into HTML.
   * @example {{{markdown some.body_content}}}
   */
  markdown: function(markdownString: string): Handlebars.SafeString {
    if (!markdownString) return new Handlebars.SafeString('');

    // Use marked to parse, then DOMPurify to sanitize against XSS attacks.
    const unsafeHtml = marked.parse(markdownString, { async: false }) as string;
    const safeHtml = DOMPurify.sanitize(unsafeHtml);

    return new Handlebars.SafeString(safeHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/comparison.helper.ts
// src/lib/theme-helpers/comparison.helper.ts
import { SignumHelper } from './types';

// This code is now valid because SignumHelperFunction accepts a boolean return.
export const comparisonHelpers: SignumHelper = () => ({
  eq: (a, b) => a === b,
  gt: (a, b) => a > b,
  lt: (a, b) => a < b,
});

================================================================================

File: core/services/theme-engine/helpers/types.ts
// src/lib/theme-helpers/types.ts
import { LocalSiteData } from '@/types'; // Use the correct path alias to the main types
import Handlebars from 'handlebars'; 

/**
 * Defines the function signature for a Handlebars helper function within Signum.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
export type SignumHelperFunction = (this: any, ...args: any[]) => string | Handlebars.SafeString | boolean;
/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 * This allows helpers to be data-aware if needed.
 */
export type SignumHelper = (siteData: LocalSiteData) => Record<string, SignumHelperFunction>;

================================================================================

File: core/services/theme-engine/helpers/pager.helper.ts
// src/core/services/theme-engine/helpers/pager.helper.ts

import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { PaginationData } from '@/types';

/**
 * Renders a complete pagination control component.
 * It generates 'Previous' and 'Next' links and a 'Page X of Y' indicator.
 * The links are disabled when not applicable (e.g., on the first or last page).
 * 
 * @param {PaginationData} pagination - The pagination data object from the page resolver.
 * @returns {Handlebars.SafeString} The full HTML for the pager component.
 *
 * @example
 * {{{pager pagination}}}
 */
export const pagerHelper: SignumHelper = () => ({
  pager: function(pagination: PaginationData | undefined): Handlebars.SafeString {
    if (!pagination || pagination.totalPages <= 1) {
      return new Handlebars.SafeString('');
    }

    const prevLink = pagination.hasPrevPage
      ? `<a href="${pagination.prevPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">â¹ Previous</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50">â¹ Previous</span>`;

    const nextLink = pagination.hasNextPage
      ? `<a href="${pagination.nextPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">Next âº</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50">Next âº</span>`;
    
    const pageIndicator = `<div class="f6 mid-gray">Page ${pagination.currentPage} of ${pagination.totalPages}</div>`;

    const pagerHtml = `
      <div class="flex items-center justify-between mt4 pt3 bt b--black-10">
        <div>${prevLink}</div>
        <div>${pageIndicator}</div>
        <div>${nextLink}</div>
      </div>
    `;

    return new Handlebars.SafeString(pagerHtml);
  }
});

================================================================================

File: core/services/theme-engine/helpers/renderView.helper.ts
// src/core/services/theme-engine/helpers/renderView.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types';
import { ViewConfig, ParsedMarkdownFile } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

export const renderViewHelper: SignumHelper = (siteData) => ({
  /**
   * Renders a view template with a given set of items.
   * This is called from a page layout to render the view section.
   * The pagination is handled by the parent layout, not this helper.
   */
  render_view: function(viewConfig: ViewConfig, viewItems: ParsedMarkdownFile[]) {
    if (!viewConfig || !viewConfig.template || !viewItems) {
      return new Handlebars.SafeString('');
    }
    
    // Find the view template (e.g., 'list.hbs') which is pre-cached as a partial.
    const viewTemplate = Handlebars.partials[viewConfig.template];

    if (viewTemplate) {
      const collectionSlug = viewConfig.source_collection;
      const collectionNode = collectionSlug 
        ? siteData.manifest.structure.find(n => n.type === 'collection' && n.slug === collectionSlug) 
        : undefined;

      // Get the authoritative layout for each item from the collection's settings.
      const itemLayoutId = collectionNode?.itemLayout || DEFAULT_PAGE_LAYOUT_PATH;

      // The context passed to the view template is now simpler.
      const context = {
        items: viewItems,
        config: viewConfig,
        itemLayoutId: itemLayoutId,
      };
      return new Handlebars.SafeString(viewTemplate(context));
    }
    
    console.warn(`[render_view] View template "${viewConfig.template}" not found.`);
    return new Handlebars.SafeString(`<!-- View template "${viewConfig.template}" not found -->`);
  }
});

================================================================================

File: core/services/theme-engine/helpers/index.ts
// src/lib/theme-helpers/index.ts
// ... (other helper imports)
import { renderViewHelper } from './renderView.helper';
import { queryHelper } from './query.helper';
import { comparisonHelpers } from './comparison.helper';
import { renderLayoutForItemHelper } from './renderLayoutForItem.helper';
import { markdownHelper } from './markdown.helper';
import { strUtilHelper } from './strUtil.helper';
import { formatDateHelper } from './formatDate.helper';
import { SignumHelper } from './types';
 
export const coreHelpers: SignumHelper[] = [
  queryHelper,
  strUtilHelper,
  formatDateHelper,
  comparisonHelpers,
  markdownHelper,
  renderViewHelper, 
  renderLayoutForItemHelper, 
];

================================================================================

File: core/services/theme-engine/helpers/formatDate.helper.ts
// src/lib/theme-helpers/formatDate.helper.ts
import { SignumHelper } from './types';

export const formatDateHelper: SignumHelper = () => ({
  /**
   * Formats a date string into a more readable format.
   * @example {{formatDate some.date_string}}
   */
  formatDate: function(dateString: string | Date): string {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    if (isNaN(date.getTime())) {
      return ''; // Return empty for invalid dates
    }

    return date.toLocaleDateString('en-GB', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  }
});

================================================================================

File: core/services/theme-engine/helpers/renderLayoutForItem.helper.ts
// src/lib/theme-helpers/renderLayoutForItem.helper.ts
import Handlebars from 'handlebars';
import { SignumHelper } from './types'; 
import { ParsedMarkdownFile } from '@/types'; 
import { HelperOptions } from 'handlebars';

export const renderLayoutForItemHelper: SignumHelper = (siteData) => ({
  /**
   * Renders a specific layout for a single content item.
   * This is used inside a view template's `each` loop.
   * @example {{{render_layout_for_item this layout=config.item_layout}}}
   */
  render_layout_for_item: function(
    this: any, 
    item: ParsedMarkdownFile, 
    options: HelperOptions 
  ) {
    const layoutId = options.hash.layout;
    if (!item || !layoutId) {
        return '';
    }

    // The themeEngine has pre-cached the required layout as a partial
    // under its ID (e.g., 'post-card').
    const layoutTemplate = Handlebars.partials[layoutId];
    
    if (layoutTemplate) {
        // The context for the layout partial is the item itself.
        return new Handlebars.SafeString(layoutTemplate(item));
    }

    console.warn(`[render_layout_for_item] Item layout template "${layoutId}" not found.`);
    return `<!-- Item layout "${layoutId}" not found -->`;
  }
});

================================================================================

File: app/layout.tsx
// src/app/layout.tsx
'use client'; 

import { useEffect, useState, Suspense } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import './globals.css'; 
import { Toaster } from "@/core/components/ui/sonner"; 
import { ThemeProvider } from "@/core/components/ThemeProvider";
import { useInitialiseUIStore } from '@/core/hooks/useInitialiseUIStore';

function AppLoadingIndicator() {
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading Signum...</p>
      </div>
    </div>
  ); 
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  useInitialiseUIStore();
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true); 
    // Initialize the app state from storage only once
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]); 

  // Show the loading indicator only on the client and before initialization is complete
  const showLoading = clientMounted && !isInitialized;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Signum - Decentralized Publishing</title>
      </head>
      <body className="h-full">
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
          {showLoading ? (
            <AppLoadingIndicator />
          ) : (
         
                <Suspense fallback={<AppLoadingIndicator />}>
                  {children}
                </Suspense>
              
          )}
          <Toaster richColors position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================================================================================

File: app/page.tsx
// src/app/page.tsx
'use client';

import { Button } from '@/core/components/ui/button';
import { Link } from '@/core/components/ui/link';
import { ShieldCheck, Feather, Zap, Archive, Leaf } from 'lucide-react';

export default function MarketingHomePage() {
  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto px-4 py-16 sm:py-24 text-center">
      <header className="mb-12">
        <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold tracking-tight text-foreground">
          Signum: Own Your Content.
        </h1>
        <p className="mt-4 max-w-2xl mx-auto text-lg sm:text-xl text-muted-foreground">
          A simple, private, and portable publishing platform that puts you back in control.
        </p>
      </header>

      <div className="mb-16">
        <Button asChild size="lg">
          <Link href="/sites">
            Open Dashboard & Get Started
          </Link>
        </Button>
      </div>

      <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 max-w-5xl mx-auto">
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <ShieldCheck className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Private & Secure</h3>
          <p className="text-muted-foreground text-sm">
            No tracking or surveillance by default. Your data is yours.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Feather className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Simple & Focused</h3>
          <p className="text-muted-foreground text-sm">
            A minimal, content-first editor lets you focus on writing.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Zap className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Blazingly Fast</h3>
          <p className="text-muted-foreground text-sm">
            Static sites are fast, reliable, and efficient to host.
          </p>
        </div>
        <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
          <Archive className="size-10 text-primary mb-4" />
          <h3 className="text-xl font-semibold mb-2">Truly Portable</h3>
          <p className="text-muted-foreground text-sm">
            Export your entire site anytime. No vendor lock-in, ever.
          </p>
        </div>
      </section>
    </div>
    </>
  );
}

================================================================================

File: app/globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: app/sites/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';

export default function SiteLoaderLayout({ children }: { children: React.ReactNode }) {
  const params = useParams();
  const siteId = params.siteId as string;

  // --- USE THE NEW ACTION ---
  const loadSiteAction = useAppStore(state => state.loadSite);
  
  useEffect(() => {
    if (siteId) {
      // This will now reliably load the manifest and content files.
      loadSiteAction(siteId);
    }
  }, [siteId, loadSiteAction]);

  return <>{children}</>;
}

================================================================================

File: app/sites/page.tsx
// src/app/page.tsx
'use client';

import Link from 'next/link';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { PlusCircle, Edit3, Eye, Trash2, FilePlus2, Leaf } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { toast } from "sonner";

export default function HomePageDashboard() {
  const sites = useAppStore((state) => state.sites);
  const deleteSiteAndState = useAppStore((state) => state.deleteSiteAndState);

  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

  const validSites = sites.filter(site => site && site.manifest);

  return (
    <>
    <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
                <div className="container mx-auto flex h-16 items-center justify-between px-4">
                  <Link href="/" className="flex items-center gap-2">
                    <Leaf className="h-7 w-7 text-primary" />
                    <span className="text-2xl font-bold text-foreground hidden sm:inline">Signum</span>
                  </Link>
                  <Button asChild variant="ghost">
                    <Link href="/sites">Dashboard</Link>
                  </Button>
                </div>
              </header>
    <div className="container mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-8 gap-4">
        <h1 className="text-3xl font-bold text-foreground">My Signum Sites</h1>
        <Button asChild size="lg">
          <Link href="/create-site">
            <FilePlus2 className="mr-2 h-5 w-5" /> Create New Site
          </Link>
        </Button>
      </div>

      {validSites.length === 0 ? (
        <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
          <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
          <p className="text-muted-foreground mb-4">Click &quot;Create New Site&quot; to get started.</p>
          <Button asChild>
            <Link href="/create-site">
                <PlusCircle className="mr-2 h-4 w-4" /> Start Creating
            </Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {validSites.map((site) => (
            <div key={site.siteId} className="bg-card border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between">
              <div>
                <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.manifest.title}>
                  {site.manifest.title || "Untitled Site"}
                </h2>
                <p className="text-sm text-muted-foreground mb-4 line-clamp-2" title={site.manifest.description}>
                  {site.manifest.description || 'No description provided.'}
                </p>
              </div>
              <div className="mt-4 flex flex-wrap justify-start gap-2">
                <Button variant="outline" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/`} target="_blank" rel="noopener noreferrer">
                    <Eye className="mr-2 h-4 w-4" /> View
                  </Link>
                </Button>
                <Button variant="default" size="sm" asChild>
                  <Link href={`/sites/${site.siteId}/edit`}>
                     <Edit3 className="mr-2 h-4 w-4" /> Edit
                  </Link>
                </Button>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" size="sm">
                      <Trash2 className="mr-2 h-4 w-4" /> Delete
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This will permanently delete &quot;{site.manifest.title || 'this site'}&quot; from local storage.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={() => handleDeleteSite(site.siteId, site.manifest.title || 'Untitled Site')}>
                        Yes, delete site
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
    </>
  );
}

================================================================================

File: app/sites/[siteId]/layout.tsx
// src/app/sites/[siteId]/layout.tsx
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbEdit, TbSettings } from "react-icons/tb";
import { cn } from '@/lib/utils';
import Image from 'next/image';
import { ReactNode } from 'react';

/**
 * The root layout for a single site's backend.
 * This component provides the persistent vertical toolbar for navigating
 * between main sections like 'Edit' and 'Settings'.
 */
export default function SingleSiteLayout({ children }: { children: ReactNode }) {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const isEditorActive = pathname.startsWith(`/sites/${siteId}/edit`);
  const isSettingsActive = pathname.startsWith(`/sites/${siteId}/settings`);

  const navItems = [
    { href: `/sites/${siteId}/edit`, title: 'Edit', icon: TbEdit, isActive: isEditorActive },
    { href: `/sites/${siteId}/settings`, title: 'Settings', icon: TbSettings, isActive: isSettingsActive },
  ];

  return (
    <div className="flex h-screen flex-col lg:flex-row">
      <aside className="fixed inset-x-0 bottom-0 z-30 flex h-16 w-full shrink-0 border-t bg-background lg:static lg:inset-y-0 lg:left-0 lg:h-full lg:w-[60px] lg:border-r lg:border-t-0">
        <nav className="flex w-full items-center justify-center gap-4 px-2 lg:flex-col lg:justify-start lg:pb-5">
          <Link
            href="/sites"
            title="Dashboard"
            className='lg:flex hidden flex-col items-center w-[60px] h-[60px] border-b'
          >
            <Image src="/signum.svg" width={34} height={34} alt="Signum Logo" className='m-auto'/>
          </Link>
          
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              title={item.title}
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-lg transition-colors',
                item.isActive
                  ? 'bg-accent text-accent-foreground'
                  : 'text-muted-foreground hover:bg-accent/50 hover:text-foreground'
              )}
            >
              <item.icon className="size-6" />
            </Link>
          ))}
        </nav>
      </aside>

      {/* The rest of the page (which will be another layout like EditSiteLayout) renders here. */}
      <main className="flex-1 overflow-auto pb-16 lg:pb-0">
        {children}
      </main>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/page.tsx
// src/app/sites/[siteId]/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page now acts as a smart entry point for a site.
// Its only job is to redirect the user to the editor.
export default function SiteRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid polluting the browser's history.
      // This sends the user directly to the site editor.
      router.replace(`/sites/${siteId}/edit`);
    }
  }, [siteId, router]);

  // Display a loading message while the redirect is processed.
  return (
    <div className="flex justify-center items-center h-full">
      <p>Redirecting to editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/layout.tsx
// src/app/sites/[siteId]/settings/layout.tsx
'use client';

import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import SettingsNav from '@/features/site-settings/components/SettingsNav';
import { ReactNode, useEffect } from 'react';
import { useUIStore } from '@/core/state/uiStore';

/**
 * The root layout for the entire settings section.
 * It provides the consistent ThreeColumnLayout structure and manages the
 * global UI state to ensure the left sidebar (with the settings menu) is

 * always visible and the right sidebar is always hidden.
 */
export default function SettingsSectionLayout({ children }: { children: ReactNode }) {
  // --- START: Get state and setters from the UI store ---
  const { 
    leftSidebarContent, 
    rightSidebarContent, 
    setLeftAvailable, 
    setRightAvailable, 
    setRightOpen,
    setLeftSidebarContent,
    setRightSidebarContent 
  } = useUIStore(state => state.sidebar);
  // --- END ---

  // This effect runs once to configure the sidebars for the entire settings section.
  useEffect(() => {
    // 1. Configure availability and state
    setLeftAvailable(true);
    setRightAvailable(false); // No right sidebar in settings
    setRightOpen(false);      // Ensure it's closed

    // 2. Set the static content for the left sidebar
    setLeftSidebarContent(<SettingsNav />);
    // 3. Ensure the right sidebar content is null
    setRightSidebarContent(null);

    // Cleanup when navigating away from the settings section
    return () => {
      setLeftAvailable(false);
      setLeftSidebarContent(null);
    };
  }, [setLeftAvailable, setRightAvailable, setRightOpen, setLeftSidebarContent, setRightSidebarContent]);

  // The final render now uses the ThreeColumnLayout, reading the sidebar
  // content from the store and passing it as props.
  return (
    <ThreeColumnLayout
      leftSidebar={leftSidebarContent}
      rightSidebar={rightSidebarContent} // This will be null, so nothing renders
    >
      {children}
    </ThreeColumnLayout>
  );
}

================================================================================

File: app/sites/[siteId]/settings/page.tsx
// src/app/sites/[siteId]/settings/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import SiteSettingsForm from '@/features/site-settings/components/SiteSettingsForm';
import { Button } from '@/core/components/ui/button';
import { Manifest } from '@/types';
import { useEffect, useState, useCallback } from 'react';
import { toast } from "sonner";
import Link from 'next/link';

export default function SiteSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);
  const isStoreInitialized = useAppStore(state => state.isInitialized);

  // Add baseUrl to the form state
  const [formData, setFormData] = useState({ title: '', description: '', author: '', baseUrl: '' });
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  useEffect(() => {
    if (site?.manifest) {
      setFormData({
        title: site.manifest.title,
        description: site.manifest.description,
        author: site.manifest.author || '',
        baseUrl: site.manifest.baseUrl || '',
      });
      setHasChanges(false);
    }
  }, [site]);
  
  const handleFormChange = useCallback((newData: typeof formData) => {
    setFormData(newData);
    setHasChanges(true);
  }, []);

  const handleSave = async () => {
    if (!site || !site.manifest) return;
    if (!formData.title.trim()) {
      toast.error("Site title cannot be empty.");
      return;
    }
    
    const trimmedBaseUrl = formData.baseUrl.trim();
    if (trimmedBaseUrl) {
      try {
        new URL(trimmedBaseUrl);
      } catch (error) {
        toast.error("The Base URL you entered is not a valid URL. Please include https://");
        return;
      }
    }
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      title: formData.title.trim(),
      description: formData.description.trim(),
      author: formData.author.trim(),
      baseUrl: trimmedBaseUrl,
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Site settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving site settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!isStoreInitialized || (site && !formData.title && !site.manifest.title)) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  if (!site) {
    return (
      <div className="p-6 text-center">
        <h2 className="text-xl font-semibold">Site Not Found</h2>
        <Button asChild variant="outline" className="mt-4">
          <Link href="/">Go to Dashboard</Link>
        </Button>
      </div>
    );
  }

  // The component now only returns its content, not the layout.
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Site Settings</h1>
        <p className="text-muted-foreground">Manage the core details of your website.</p>
      </div>
      <div className="border-t pt-6">
        <SiteSettingsForm 
          formData={formData}
          onFormChange={handleFormChange} 
        />
      </div>
      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Settings'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/settings/appearance/page.tsx
// src/app/sites/[siteId]/settings/appearance/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import AppearanceSettingsForm from '@/features/site-settings/components/AppearanceSettingsForm';
import { Button } from '@/core/components/ui/button';
import { Manifest, ThemeConfig, ThemeInfo } from '@/types';
import { useEffect, useState, useCallback, useMemo } from 'react';
import { toast } from "sonner";
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { getAvailableThemes } from '@/core/services/configHelpers.service';

export default function AppearanceSettingsPage() {
  const params = useParams();
  const siteId = params.siteId as string;

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);

  const [selectedThemePath, setSelectedThemePath] = useState<string>('');
  const [themeConfig, setThemeConfig] = useState<ThemeConfig['config']>({});
  const [isLoading, setIsLoading] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  const availableThemes = useMemo(() => {
    return getAvailableThemes(site?.manifest);
  }, [site?.manifest]);

  useEffect(() => {
    if (site?.manifest.theme) {
      setSelectedThemePath(site.manifest.theme.name);
      setThemeConfig(site.manifest.theme.config);
      setHasChanges(false);
    }
  }, [site]);
  
  const handleConfigChange = useCallback((newConfig: ThemeConfig['config']) => {
    setThemeConfig(newConfig);
    setHasChanges(true);
  }, []);

  const handleThemeChange = (newThemePath: string) => {
    setSelectedThemePath(newThemePath);
    setThemeConfig({});
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!site || !site.manifest || !selectedThemePath) return;
    
    setIsLoading(true);
    const newManifest: Manifest = {
      ...site.manifest,
      theme: {
        name: selectedThemePath,
        config: themeConfig,
      },
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Appearance settings saved successfully!');
      setHasChanges(false);
    } catch {
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!site) {
    return <div className="p-6">Loading settings...</div>;
  }
  
  // The component now only returns its content, not the layout.
  return (
    <div className="space-y-6 max-w-2xl p-6">
      <div>
        <h1 className="text-2xl font-bold">Appearance</h1>
        <p className="text-muted-foreground">Customize the visual style of your site.</p>
      </div>

      <div className="border-t pt-6 space-y-6">
        <div>
            <Label htmlFor="theme-select">Active Theme</Label>
            <Select value={selectedThemePath} onValueChange={handleThemeChange}>
                <SelectTrigger id="theme-select" className="mt-1">
                    <SelectValue placeholder="Select a theme..." />
                </SelectTrigger>
                <SelectContent>
                    {availableThemes.map((theme: ThemeInfo) => (
                        <SelectItem key={theme.path} value={theme.path}>
                            {theme.name}
                        </SelectItem>
                    ))}
                </SelectContent>
            </Select>
        </div>
        
        {selectedThemePath && (
            <AppearanceSettingsForm 
                site={site}
                themePath={selectedThemePath}
                themeConfig={themeConfig}
                onConfigChange={handleConfigChange}
            />
        )}
      </div>

      <div className="flex justify-end pt-4">
        <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
          {isLoading ? 'Saving...' : 'Save Appearance'}
        </Button>
      </div>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/layout.tsx
// src/app/sites/[siteId]/edit/layout.tsx
'use client';

import { ReactNode } from 'react';

/**
 * The root layout for the /edit section.
 * In this refactored architecture, this layout has a minimal role.
 * It primarily serves as a container for the editor pages.
 * The context providers and specific layouts are now handled by the
 * page components themselves for better encapsulation.
 */
export default function EditSiteLayout({ children }: { children: ReactNode }) {
  // This layout simply renders the page that Next.js passes to it.
  return <>{children}</>;
}

================================================================================

File: app/sites/[siteId]/edit/page.tsx
// src/app/sites/[siteId]/edit/page.tsx
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

// This page acts as a default entry point for the editor.
// It immediately redirects to the editor for the site's homepage (index.md).
export default function SiteEditorRootPage() {
  const router = useRouter();
  const params = useParams();
  const siteId = params.siteId as string;

  useEffect(() => {
    if (siteId) {
      // Use `replace` to avoid adding this redirect page to the browser history.
      // This will navigate to the content editor for the file at `content/index.md`.
      router.replace(`/sites/${siteId}/edit/content/`);
    }
  }, [siteId, router]);

  // Return a loading state while the redirect is happening.
  return (
    <div className="p-6 flex justify-center items-center h-full">
      <p>Loading editor...</p>
    </div>
  );
}

================================================================================

File: app/sites/[siteId]/edit/collection/[collectionName]/page.tsx
// src/app/sites/[siteId]/edit/collection/[collectionName]/page.tsx
'use client';

import { useParams, useRouter } from 'next/navigation';
import React, { useMemo, useState, useEffect, useCallback } from 'react';
import { EditorProvider, useEditor } from '@/features/editor/contexts/EditorContext';
import { useAutosave } from '@/core/hooks/useAutosave';
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';
import Link from 'next/link';
import { Button } from '@/core/components/ui/button';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import LeftSidebar from '@/components/publishing/LeftSidebar';
import PrimaryContentFields from '@/features/editor/components/PrimaryContentFields';
import { toast } from 'sonner';
import { FileText, PlusCircle } from 'lucide-react';
import type { StructureNode, MarkdownFrontmatter } from '@/types';
import { getAvailableLayouts, LayoutManifest } from '@/core/services/configHelpers.service';
import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';

/**
 * A memoized sub-component that renders the right sidebar UI for editing collection settings.
 * This prevents it from re-rendering unnecessarily when the main page content changes.
 */
const CollectionSettingsSidebar = React.memo(function CollectionSettingsSidebar({
    collectionNodeData,
    availableLayouts,
    onLayoutChange,
    onPrimaryFieldsChange,
}: {
    collectionNodeData: StructureNode,
    availableLayouts: LayoutManifest[],
    onLayoutChange: (newLayoutPath: string) => void,
    onPrimaryFieldsChange: (data: Partial<MarkdownFrontmatter>) => void,
}) {
    // Extract only the fields this component cares about for its own state
    const primaryFields = {
        title: typeof collectionNodeData.title === 'string' ? collectionNodeData.title : '',
        description: typeof collectionNodeData.description === 'string' ? collectionNodeData.description : '',
    };

    return (
        <div className="flex h-full flex-col p-4">
            <div className="flex-grow space-y-6">
                <h2 className="text-lg font-semibold border-b pb-3">Collection Settings</h2>
                <div className="space-y-4">
                    <PrimaryContentFields
                        frontmatter={primaryFields}
                        onFrontmatterChange={onPrimaryFieldsChange}
                        showDescription={true}
                    />
                </div>
                <div className="border-t pt-4 space-y-4">
                    <div>
                        <Label htmlFor="item-layout-select">Default Item Layout</Label>
                        <Select value={collectionNodeData.itemLayout} onValueChange={onLayoutChange}>
                            <SelectTrigger id="item-layout-select" className="mt-1">
                                <SelectValue placeholder="Select a layout..." />
                            </SelectTrigger>
                            <SelectContent>
                                {availableLayouts.map(layout => (
                                    <SelectItem key={layout.name} value={layout.name}>{layout.name}</SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                        <p className="text-sm text-muted-foreground pt-2">
                          This layout will be the default for new items created in this collection.
                        </p>
                    </div>
                    <p className="text-sm text-muted-foreground pt-4">This collection is an organizational folder. Its appearance on the site is determined by the &quot;View Pages&quot; that display its content.</p>
                </div>
            </div>
        </div>
    );
});
CollectionSettingsSidebar.displayName = 'CollectionSettingsSidebar';


/**
 * The internal implementation of the collection editor page.
 * It assumes it is rendered within an EditorProvider.
 */
function EditCollectionPageInternal() {
    const params = useParams();
    const router = useRouter();
    const siteId = params.siteId as string;
    const collectionName = params.collectionName as string;
    
    // --- Context and Store Hooks ---
    const { hasUnsavedChanges, setHasUnsavedChanges, registerSaveAction } = useEditor();
    const { 
        setLeftSidebarContent, 
        setRightSidebarContent,
        leftSidebarContent,
        rightSidebarContent
    } = useUIStore((state) => state.sidebar);
    
    const site = useAppStore(state => state.getSiteById(siteId));
    const updateManifest = useAppStore(state => state.updateManifest);

    // --- Component State ---
    const [isDataReady, setIsDataReady] = useState(false);
    const [collectionNodeData, setCollectionNodeData] = useState<StructureNode | null>(null);
    const [availableLayouts, setAvailableLayouts] = useState<LayoutManifest[]>([]);

    const collectionPath = `content/${collectionName}`;
    const originalCollectionNode = useMemo(() => 
        site?.manifest.structure.find((node: StructureNode) => node.path === collectionPath && node.type === 'collection'), 
        [site?.manifest, collectionPath]
    );
    
    useEffect(() => {
        if (site && originalCollectionNode) {
            setCollectionNodeData(originalCollectionNode);
            setHasUnsavedChanges(false);
            setIsDataReady(true);
        } else if (site && !isDataReady && !originalCollectionNode) {
            toast.error(`Collection "${collectionName}" not found.`);
            router.push(`/sites/${siteId}/edit`);
        }
    }, [site, originalCollectionNode, collectionName, siteId, router, setHasUnsavedChanges, isDataReady]);


    // --- Handlers (Memoized for performance) ---
    const handlePrimaryFieldsChange = useCallback((data: Partial<MarkdownFrontmatter>) => {
        setCollectionNodeData(prev => prev ? { ...prev, ...data } : null);
        setHasUnsavedChanges(true);
    }, [setHasUnsavedChanges]);

    const handleLayoutChange = useCallback((newLayoutPath: string) => {
        setCollectionNodeData(prev => prev ? { ...prev, itemLayout: newLayoutPath } : null);
        setHasUnsavedChanges(true);
    }, [setHasUnsavedChanges]);

    const handleSaveChanges = useCallback(async () => {
        if (!site?.manifest || !collectionNodeData) {
            throw new Error("Cannot save, essential data not found.");
        }
        const newStructure = site.manifest.structure.map((node: StructureNode) =>
            node.path === collectionPath ? collectionNodeData : node
        );
        const newManifest = { ...site.manifest, structure: newStructure };
        
        await updateManifest(siteId, newManifest);
    }, [site?.manifest, collectionNodeData, collectionPath, siteId, updateManifest]);

    // --- Effect for registering save action and autosave ---
    useEffect(() => {
        registerSaveAction(handleSaveChanges);
    }, [handleSaveChanges, registerSaveAction]);
    
    useAutosave<StructureNode | null>({
        dataToSave: collectionNodeData,
        hasUnsavedChanges,
        isSaveable: !!collectionNodeData,
        onSave: handleSaveChanges,
    });
    
    // --- Effects for loading schemas and setting up sidebars ---
    useEffect(() => {
        if(site) {
            getAvailableLayouts(site, 'item').then(layouts => {
                setAvailableLayouts(layouts);
            });
        }
    }, [site]);

    useEffect(() => {
        setLeftSidebarContent(<LeftSidebar />);
        if (collectionNodeData) {
            setRightSidebarContent(
                <CollectionSettingsSidebar
                    collectionNodeData={collectionNodeData}
                    availableLayouts={availableLayouts}
                    onLayoutChange={handleLayoutChange}
                    onPrimaryFieldsChange={handlePrimaryFieldsChange}
                />
            );
        } else {
            setRightSidebarContent(null);
        }
        return () => {
            setLeftSidebarContent(null);
            setRightSidebarContent(null);
        };
    }, [collectionNodeData, availableLayouts, handleLayoutChange, handlePrimaryFieldsChange, setLeftSidebarContent, setRightSidebarContent]);
    
    
    if (!isDataReady || !collectionNodeData) {
        return <div className="p-6 flex justify-center items-center h-full"><p>Loading Collection...</p></div>;
    }

    return (
        <ThreeColumnLayout
            leftSidebar={leftSidebarContent}
            rightSidebar={rightSidebarContent}
        >
            <div className="h-full flex flex-col p-6">
                <div className="flex shrink-0 items-center justify-between mb-4">
                    <h1 className="text-3xl font-bold truncate pr-4">Managing: {originalCollectionNode?.title}</h1>
                    <Button asChild>
                        <Link href={`/sites/${siteId}/edit/content/${collectionName}/_new`}>
                            <PlusCircle className="mr-2 h-4 w-4" /> New Item
                        </Link>
                    </Button>
                </div>
                <div className="flex-grow rounded-lg bg-background p-4 border overflow-y-auto">
                    <h2 className="text-lg font-semibold mb-3">Items in this Collection</h2>
                    {collectionNodeData.children && collectionNodeData.children.length > 0 ? (
                        <ul className="space-y-2">
                            {collectionNodeData.children.map((item: StructureNode) => {
                                const relativePath = item.path.replace(/^content\//, '').replace(/\.md$/, '');
                                return (
                                    <li key={item.path}>
                                        <Link href={`/sites/${siteId}/edit/content/${relativePath}`} className="flex items-center rounded-md p-2 transition-colors hover:bg-muted">
                                            <FileText className="mr-3 h-4 w-4 text-muted-foreground" />
                                            <span className="font-medium">{item.title || item.slug}</span>
                                        </Link>
                                    </li>
                                );
                            })}
                        </ul>
                    ) : (
                        <p className="text-center text-muted-foreground py-8">No items have been added to this collection yet.</p>
                    )}
                </div>
            </div>
        </ThreeColumnLayout>
    );
}

/**
 * Final exported page component that wraps the internal implementation
 * with the necessary EditorProvider context.
 */
export default function EditCollectionPage() {
    return (
        <EditorProvider>
            <EditCollectionPageInternal />
        </EditorProvider>
    );
}

================================================================================

File: app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
// src/app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useMemo, useEffect, useRef } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { useContentEditorState } from '@/features/editor/hooks/useContentEditorState';
import { EditorProvider } from '@/features/editor/contexts/EditorContext';

// --- Component Imports ---
import ThreeColumnLayout from '@/components/layout/ThreeColumnLayout';
import MarkdownEditor, { type MarkdownEditorRef } from '@/components/publishing/MarkdownEditor';
import ViewEditor from '@/features/editor/components/ViewEditor';
import FrontmatterSidebar from '@/features/editor/components/FrontmatterSidebar';
import PrimaryContentFields from '@/features/editor/components/PrimaryContentFields';
import LeftSidebar from '@/components/publishing/LeftSidebar';
import type { LocalSiteData } from '@/types';
import { slugify } from '@/lib/utils';


function EditContentPageInternal() {
  const params = useParams();
  const siteId = params.siteId as string;
  const slugSegments = useMemo(() => (params.slug as string[]) || [], [params.slug]);

  const { 
    status, 
    site,
    isNewFileMode, 
    frontmatter, 
    bodyContent, 
    slug, 
    currentFilePath,
    editorRef,
    actions 
  } = useContentEditorState(siteId, slugSegments);

  // --- START OF FIX: Select each piece of state individually ---
  const leftSidebarContent = useUIStore(state => state.sidebar.leftSidebarContent);
  const rightSidebarContent = useUIStore(state => state.sidebar.rightSidebarContent);
  const setLeftAvailable = useUIStore(state => state.sidebar.setLeftAvailable);
  const setRightAvailable = useUIStore(state => state.sidebar.setRightAvailable);
  const setLeftSidebarContent = useUIStore(state => state.sidebar.setLeftSidebarContent);
  const setRightSidebarContent = useUIStore(state => state.sidebar.setRightSidebarContent);
  // --- END OF FIX ---

  // Effect 1: Manages the static layout of the left sidebar.
  useEffect(() => {
    setLeftAvailable(true);
    setLeftSidebarContent(<LeftSidebar />);
    
    // Cleanup function
    return () => {
        setLeftAvailable(false);
        setLeftSidebarContent(null);
    }
  }, [setLeftAvailable, setLeftSidebarContent]); // This effect now has stable dependencies.


  // Effect 2: Manages the dynamic content of the right sidebar.
  useEffect(() => {
    if (status === 'ready' && frontmatter && site) {
      setRightAvailable(true);
      setRightSidebarContent(
        <FrontmatterSidebar
          site={site as LocalSiteData}
          frontmatter={frontmatter}
          onFrontmatterChange={actions.handleFrontmatterChange}
          isNewFileMode={isNewFileMode}
          slug={slug}
          onSlugChange={(newSlug) => actions.setSlug(slugify(newSlug))}
          onDelete={actions.handleDelete}
        />
      );
    } else {
      setRightAvailable(false);
      setRightSidebarContent(null);
    }

    return () => {
        setRightAvailable(false);
    }
  }, [
    status, site, frontmatter, isNewFileMode, slug, actions,
    setRightAvailable, setRightSidebarContent
  ]);

  const isViewMode = useMemo(() => !!frontmatter?.view, [frontmatter]);

  const pageContent = useMemo(() => {
    if (status !== 'ready' || !frontmatter) {
      return <div className="p-6 flex justify-center items-center h-full"><p>Loading Editor...</p></div>;
    }
    
    return (
      <div className='flex h-full w-full flex-col p-6'>
        <div className='container mx-auto flex h-full max-w-[900px] flex-col'>
            <div className="shrink-0">
                <PrimaryContentFields
                    frontmatter={frontmatter}
                    onFrontmatterChange={actions.handleFrontmatterChange}
                />
            </div>
            <div className="mt-6 flex-grow">
              {isViewMode ? (
                <ViewEditor 
                  siteId={siteId}
                  frontmatter={frontmatter}
                  onFrontmatterChange={actions.handleFrontmatterChange}
                />
              ) : (
                <MarkdownEditor
                  ref={editorRef}
                  key={currentFilePath}
                  initialValue={bodyContent}
                  onContentChange={actions.onContentModified}
                />
              )}
            </div>
        </div>
      </div>
    );
  }, [status, frontmatter, bodyContent, currentFilePath, editorRef, actions, isViewMode, siteId]);
  
  return (
    <ThreeColumnLayout
        leftSidebar={leftSidebarContent}
        rightSidebar={rightSidebarContent}
    >
        {pageContent}
    </ThreeColumnLayout>
  );
}


export default function EditContentPage() {
    return (
        <EditorProvider>
            <EditContentPageInternal />
        </EditorProvider>
    );
}

================================================================================

File: app/sites/[siteId]/view/[[...slug]]/page.tsx
// src/app/sites/[siteId]/view/[[...slug]]/page.tsx
'use client';

import SitePreview from '@/features/viewer/components/SiteViewer';

export default function ViewSitePage() {
  // This page's only job is to render the master preview component.
  // The component itself will read the URL from the browser.
  return <SitePreview />;
}

================================================================================

File: app/create-site/page.tsx
// src/app/(publishing)/create-site/page.tsx
'use client';

import { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { LocalSiteData, ParsedMarkdownFile, MarkdownFrontmatter, StructureNode, ThemeInfo } from '@/types';
import { Button } from '@/core/components/ui/button';
import { generateSiteId } from '@/lib/utils';
import { toast } from "sonner";
import { getLayoutManifest } from '@/core/services/configHelpers.service';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { GENERATOR_VERSION, CORE_THEMES, DEFAULT_PAGE_LAYOUT_PATH, DEFAULT_HOMEPAGE_CONFIG } from '@/config/editorConfig';
export default function CreateSitePage() {
  const router = useRouter();
  const addSite = useAppStore((state) => state.addSite);

  const [siteTitle, setSiteTitle] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  const availableThemes = useMemo(() => CORE_THEMES, []);
  const [selectedTheme, setSelectedTheme] = useState<ThemeInfo | null>(availableThemes[0] || null);

  const handleSubmit = async () => {
    if (!siteTitle.trim() || !selectedTheme) {
      toast.error('Site title and a theme are required.');
      return;
    }
    setIsLoading(true);

    const newSiteId = generateSiteId(siteTitle);
    const homepageLayoutPath = DEFAULT_PAGE_LAYOUT_PATH;

    const defaultFrontmatter: MarkdownFrontmatter = {
        title: DEFAULT_HOMEPAGE_CONFIG.TITLE,
        layout: homepageLayoutPath,
        date: new Date().toISOString().split('T')[0],
    };

    const mockSiteData: LocalSiteData = { 
        siteId: 'mock-id', 
        contentFiles: [], 
        layoutFiles: [], 
        themeFiles: [], 
        manifest: { 
            siteId: 'mock-id',
            title: 'mock',
            description: 'mock',
            generatorVersion: GENERATOR_VERSION,
            structure: [],
            theme: { 
                name: selectedTheme.path, 
                config: {} 
            } 
        } 
    };
    
    const layoutManifest = await getLayoutManifest(mockSiteData, homepageLayoutPath);
    
    if (layoutManifest?.schema?.properties) {
    for (const [key, prop] of Object.entries(layoutManifest.schema.properties)) {
        // Check if the property in the schema has a 'default' value
        if (typeof prop === 'object' && prop !== null && 'default' in prop) {
            // And if we haven't already set this value in our frontmatter
            if (defaultFrontmatter[key] === undefined) {
                // Then apply the default value from the schema.
                defaultFrontmatter[key] = prop.default as unknown;
            }
        }
    }
}

    const defaultIndexFile: ParsedMarkdownFile = {
        slug: 'index',
        path: 'content/index.md',
        frontmatter: defaultFrontmatter,
        content: `# Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`,
    };
    
    const indexStructureNode: StructureNode = {
        type: 'page',
        title: 'Home',
        path: 'content/index.md',
        slug: 'index',
        navOrder: 0,
        layout: homepageLayoutPath,
    };

    const newSiteData: LocalSiteData = {
      siteId: newSiteId,
      manifest: {
        siteId: newSiteId,
        generatorVersion: GENERATOR_VERSION,
        title: siteTitle.trim(),
        description: siteDescription.trim(),
        theme: {
          name: selectedTheme.path,
          config: {},
        },
        structure: [indexStructureNode],
      },
      contentFiles: [defaultIndexFile],
      themeFiles: [],
      layoutFiles: [],
    };

    try {
      await addSite(newSiteData);
      toast.success(`Site "${siteTitle}" created successfully!`);
      router.push(`/sites/${newSiteId}/edit/content/index`);
    } catch (error) {
      toast.error(`Failed to create site: ${(error as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-2xl">
      <div className="space-y-6">
        <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Create a New Site</h1>
            <Button onClick={() => router.push('/')} variant="outline">Cancel</Button>
        </div>

        <div className="space-y-4 p-6 border rounded-lg">
            <h2 className="text-lg font-semibold">Site Details</h2>
            <div>
                <Label htmlFor="site-title">Site Title</Label>
                <Input
                    id="site-title"
                    value={siteTitle}
                    onChange={(e) => setSiteTitle(e.target.value)}
                    placeholder="My Awesome Project"
                    required
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="site-description">Site Description (Optional)</Label>
                <Textarea
                    id="site-description"
                    value={siteDescription}
                    onChange={(e) => setSiteDescription(e.target.value)}
                    placeholder="A short and catchy description of your new site."
                    rows={3}
                    className="mt-1"
                />
            </div>
            <div>
                <Label htmlFor="theme-select">Theme</Label>
                <Select 
                    value={selectedTheme?.path || ''} 
                    onValueChange={(themePath) => {
                        const theme = availableThemes.find(t => t.path === themePath);
                        if (theme) setSelectedTheme(theme);
                    }} 
                >
                    <SelectTrigger id="theme-select" className="mt-1">
                        <SelectValue placeholder="Select a theme..." />
                    </SelectTrigger>
                    <SelectContent>
                        {availableThemes.map(theme => (
                            <SelectItem key={theme.path} value={theme.path}>
                                {theme.name}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                 <p className="text-xs text-muted-foreground mt-1">
                    Choose the overall design for your site. You can change this later.
                </p>
            </div>
        </div>

        <div className="flex justify-end">
            <Button onClick={handleSubmit} disabled={isLoading || !siteTitle.trim() || !selectedTheme} size="lg">
                {isLoading ? 'Creating...' : 'Create Site'}
            </Button>
        </div>
      </div>
    </div>
  );
}

================================================================================

File: config/editorConfig.ts
// src/config/editorConfig.ts
import type { ThemeInfo, LayoutInfo, ViewInfo } from '@/types';
import { RJSFSchema, UiSchema } from '@rjsf/utils'; 

/**
 * The official version of the Signum generator client.
 * This is written to the manifest.json on site creation and can be used
 * by the theme engine or other tools to check for compatibility.
 */
export const GENERATOR_VERSION = 'SignumClient/1.3.0';

/**
 * The URL segment used to identify a new, unsaved content file.
 * This allows the editor to distinguish between editing an existing file
 * and creating a new one.
 * e.g., /edit/site-id/content/blog/_new
 */
export const NEW_FILE_SLUG_MARKER = '_new';

/**
 * The delay in milliseconds for the autosave functionality in the content editor.
 * A longer delay reduces server/storage load but increases risk of data loss on close.
 * A shorter delay saves more often but can be more "chatty".
 */
export const AUTOSAVE_DELAY = 2500;

/**
 * The default layout path used for any new single page.
 * The system will fall back to this if a more specific layout isn't defined.
 * The path is relative to '/public/layouts/'.
 * e.g., 'page'
 */
export const DEFAULT_PAGE_LAYOUT_PATH = 'page';

/**
 * The default layout path used for any new collection.
 * This ensures that when a user creates a new collection, it has a sensible
 * default appearance without requiring an immediate decision.
 * The path is relative to '/public/layouts/'.
 * e.g., 'listing'
 */
export const DEFAULT_VIEW_LAYOUT_PATH = 'listing';

export const CORE_LAYOUTS: LayoutInfo[] = [
  { id: 'page', name: 'Page', type: 'page', path: 'page' },
  { id: 'listing', name: 'Listing', type: 'view', path: 'listing' },
];

export const CORE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', path: 'default' },
];

/**
 * A list of the core, built-in views that ship with Signum.
 * The `id` and `path` must match the directory name in `/public/views/`.
 */
export const CORE_VIEWS: ViewInfo[] = [
    { id: 'list', name: 'Simple List View', path: 'list' },
    // Add other core views like 'grid' here as they are created.
];

/**
 * Default configuration for a new site's homepage (index.md).
 * Centralizes the initial title and content.
 */
export const DEFAULT_HOMEPAGE_CONFIG = {
  TITLE: 'Welcome to your new site!',
  /**
   * Generates the default markdown content for the homepage.
   * @param {string} siteTitle - The title of the site to include in the welcome message.
   * @returns {string} The formatted markdown string.
   */
  getContent: (siteTitle: string): string => 
    `## Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`
};

/**
 * The universal base schema for all content frontmatter.
 * This object is imported directly, eliminating network requests.
 * Fields like 'title' and 'description' are not included here because they
 * are handled by dedicated UI components, not the generic form generator.
 */
export const BASE_SCHEMA: { schema: RJSFSchema; uiSchema: UiSchema } = {
  schema: {
    title: 'Base content fields',
    type: 'object',
    properties: {
      slug: {
        type: 'string',
        title: 'Slug (URL Path)',
        description: 'The URL-friendly version of the title. Auto-generated, but can be edited.',
      },
      image: {
        type: 'string',
        title: 'Image',
        description: 'URL or path to a featured image for this content.',
      },
      date: {
        type: 'string',
        title: 'Publication date',
        format: 'date',
      },
      status: {
        type: 'string',
        title: 'Status',
        enum: ['published', 'draft'],
        default: 'draft',
      },
      author: {
        type: 'string',
        title: 'Author',
      },
      tags: {
        type: 'array',
        title: 'Tags',
        items: {
          type: 'string',
        },
      },
    },
  },
  uiSchema: {
    slug: {
      'ui:widget': 'hidden',
    },
    tags: {
      'ui:options': {
        addable: true,
        removable: true,
      },
    },
  },
};

================================================================================

File: features/viewer/components/SiteViewer.tsx
// src/components/view/SiteViewer.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useEffect, useState, useCallback } from 'react';
import { useAppStore } from '@/core/state/useAppStore';
import { resolvePageContent } from '@/core/services/pageResolver.service';
import { PageType } from '@/types';import { render as renderWithTheme } from '@/core/services/theme-engine/themeEngine.service';
import { AlertTriangle, Edit } from 'lucide-react';
import { Button } from '@/core/components/ui/button';
import Link from 'next/link';

/**
 * Renders a live, interactive preview of a Signum site within an iframe.
 * This component acts as a mini-SPA, controlling the browser's URL history
 * to allow for deep linking and back/forward button navigation within the preview.
 */
export default function SiteViewer() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;
  const viewRootPath = `/sites/${siteId}/view`;

  const [currentRelativePath, setCurrentRelativePath] = useState(
    pathname.replace(viewRootPath, '') || '/'
  );
  const [htmlContent, setHtmlContent] = useState<string>('<p>Loading Preview...</p>');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const site = useAppStore((state) => state.getSiteById(siteId));

  const sandboxAttributes = 
    process.env.NODE_ENV === 'development'
      ? 'allow-scripts allow-forms allow-same-origin'
      : 'allow-scripts allow-forms';


  const updateIframeContent = useCallback(async () => {
    if (!site) return;

    // This ensures we don't try to render before the site's content is loaded.
    if (!site.contentFiles) {
        console.log("SiteViewer is waiting for content files to load...");
        return;
    }

    const slugArray = currentRelativePath.split('/').filter(Boolean);
    const resolution = resolvePageContent(site, slugArray);
    
    if (resolution.type === PageType.NotFound) {
      setErrorMessage(resolution.errorMessage);
      return;
    }

    try {
      const pureHtml = await renderWithTheme(site, resolution, {
        siteRootPath: viewRootPath,
        isExport: false,
      });

      // --- START: NEW ROBUST COMMUNICATION SCRIPT ---
      const parentOrigin = typeof window !== 'undefined' ? window.location.origin : '';

      const communicationScript = `
        <script>
          // The parent component injects its own origin here. This is the key.
          const PARENT_ORIGIN = '${parentOrigin}'; 

          document.addEventListener('click', function(e) {
            const link = e.target.closest('a');

            // 1. If it's not a link, do nothing.
            if (!link || !link.href) return;
            
            // 2. If it's an in-page anchor link, let the browser handle it.
            if (link.hash && link.pathname === window.location.pathname) return;

            // 3. This is the crucial check: Does the link point to the same origin
            //    as the parent application? This works in ANY sandbox mode.
            if (link.origin === PARENT_ORIGIN) {
              e.preventDefault();
              const newPath = new URL(link.href).pathname;
              // Post the message back to the parent, specifying its own origin for security.
              window.parent.postMessage({ type: 'SIGNUM_NAVIGATE', path: newPath }, PARENT_ORIGIN);
            }
            // 4. If it's an external link (e.g., to google.com), the condition fails
            //    and the browser handles it normally (opening in a new tab if target="_blank").
          });
        <\/script>
      `;
      // --- END: NEW ROBUST COMMUNICATION SCRIPT ---

      const finalHtml = pureHtml.replace('</body>', `${communicationScript}</body>`);
      setHtmlContent(finalHtml);
      setErrorMessage(null);
    } catch (e) {
      const error = e as Error;
      console.error("Error during site rendering:", error);
      setErrorMessage(`Theme Error: ${error.message}`);
    }
  }, [site, viewRootPath, currentRelativePath]);

  // Re-render the iframe whenever the path or the site data itself changes.
  useEffect(() => {
    updateIframeContent();
  }, [updateIframeContent]);

  // This effect manages the browser history and remains unchanged.
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // Security: Only accept messages from our own origin.
      if (event.origin !== window.location.origin) return;
      
      const { type, path } = event.data;
      if (type === 'SIGNUM_NAVIGATE' && path !== window.location.pathname) {
        history.pushState({ path }, '', path);
        setCurrentRelativePath(path.replace(viewRootPath, '') || '/');
      }
    };

    const handlePopState = (event: PopStateEvent) => {
        const newPath = event.state?.path || pathname;
        setCurrentRelativePath(newPath.replace(viewRootPath, '') || '/');
    };

    window.addEventListener('message', handleMessage);
    window.addEventListener('popstate', handlePopState);

    return () => {
      window.removeEventListener('message', handleMessage);
      window.removeEventListener('popstate', handlePopState);
    };
  }, [viewRootPath, pathname]);

  if (errorMessage) {
    return (
      <div className="p-8 text-center">
        <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
        <h1 className="text-2xl font-bold mb-2">Could Not Render Preview</h1>
        <p className="text-muted-foreground">{errorMessage}</p>
        <Button asChild variant="default" className="mt-6">
          <Link href={`/sites/${siteId}/edit`}>
            <Edit className="mr-2 h-4 w-4" /> Go to Editor
          </Link>
        </Button>
      </div>
    );
  }

  return (
    <iframe
      srcDoc={htmlContent}
      title={site?.manifest.title || 'Site Preview'}
      className="w-full h-full border-0"
      sandbox={sandboxAttributes}
    />
  );
}

================================================================================

File: features/viewer/components/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; // It uses `dangerouslySetInnerHTML`, making it client-side for this pattern.
              // Alternatively, HTML parsing can be done on the server and HTML passed as prop.

import { marked } from 'marked';
import { useEffect, useMemo } from 'react'; // useMemo for parsing, useEffect if parsing were async
// Optional: Add DOMPurify for sanitization if markdown source is not 100% trusted
// import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {
        // If running in an SSR context where marked might be called without DOMPurify (if used),
        // or if you want to ensure it's only parsed once.
        // However, for this component marked as 'use client', this check is less critical
        // as it primarily renders client-side.
    }
    const rawHtml = marked.parse(markdown) as string;
    // Example of sanitization if you were to use DOMPurify:
    // if (typeof window !== 'undefined') { // DOMPurify only runs in browser
    //   return DOMPurify.sanitize(rawHtml);
    // }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Signum, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: features/site-settings/components/AppearanceSettingsForm.tsx
// src/components/publishing/AppearanceSettingsForm.tsx
'use client';

import { useEffect, useState } from 'react';
import { RJSFSchema } from '@rjsf/utils';
import { getJsonAsset, type ThemeManifest } from '@/core/services/configHelpers.service';
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';
import { ThemeConfig, LocalSiteData } from '@/types';

interface AppearanceSettingsFormProps {
  site: LocalSiteData;
  themePath: string;
  themeConfig: ThemeConfig['config'];
  onConfigChange: (newConfig: ThemeConfig['config']) => void;
}

export default function AppearanceSettingsForm({ site, themePath, themeConfig, onConfigChange }: AppearanceSettingsFormProps) {
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function loadSchema() {
      if (!themePath) {
        setIsLoading(false);
        setSchema(null);
        return;
      }
      
      setIsLoading(true);

      // --- START OF CORRECTED LOGIC ---

      // 1. Fetch the entire theme.json file for the active theme.
      const themeManifest = await getJsonAsset<ThemeManifest>(
        site,
        'theme',
        themePath,
        'theme.json' // <-- Correct filename
      );

      // 2. Check if the manifest was found and if it contains the appearance schema.
      if (themeManifest && themeManifest.appearanceSchema) {
        setSchema(themeManifest.appearanceSchema);
      } else {
        // If not found, there are no settings, so set the schema to null.
        setSchema(null);
      }
      
      // --- END OF CORRECTED LOGIC ---

      setIsLoading(false);
    }

    loadSchema();
  }, [site, themePath]);
  
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onConfigChange(event.formData as ThemeConfig['config'] || {});
  };

  if (isLoading) {
    return (
        <div className="flex items-center justify-center p-4 text-muted-foreground">
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span>Loading appearance options...</span>
        </div>
    );
  }

  if (!schema) {
    return (
      <div className="text-center border-2 border-dashed p-6 rounded-lg">
        <p className="font-semibold">No Appearance Options</p>
        <p className="text-sm text-muted-foreground">The current theme &quot;{themePath}&quot; does not provide any customizable appearance settings.</p>
      </div>
    );
  }

  return (
    <SchemaDrivenForm
      schema={schema}
      formData={themeConfig}
      onFormChange={handleChange}
    />
  );
}

================================================================================

File: features/site-settings/components/SiteSettingsForm.tsx
// src/components/publishing/SiteSettingsForm.tsx
'use client';

import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';

interface SiteSettingsFormProps {
  formData: {
    title: string;
    description: string;
    author: string;
    baseUrl: string; // <-- ADD THIS LINE
  };
  onFormChange: (newData: SiteSettingsFormProps['formData']) => void;
}

export default function SiteSettingsForm({ formData, onFormChange }: SiteSettingsFormProps) {
  const handleChange = (field: keyof typeof formData, value: string) => {
    onFormChange({ ...formData, [field]: value });
  };

  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Label htmlFor="title">Site Title</Label>
        <Input
          id="title"
          value={formData.title}
          onChange={(e) => handleChange('title', e.target.value)}
          placeholder="My Awesome Site"
        />
        <p className="text-sm text-muted-foreground">The main title for your website.</p>
      </div>
      <div className="space-y-2">
        <Label htmlFor="description">Site Description</Label>
        <Textarea
          id="description"
          value={formData.description}
          onChange={(e) => handleChange('description', e.target.value)}
          placeholder="A short, catchy description."
          rows={3}
        />
         <p className="text-sm text-muted-foreground">Used for search engines and social media previews.</p>
      </div>
       <div className="space-y-2">
        <Label htmlFor="author">Author (Optional)</Label>
        <Input
          id="author"
          value={formData.author}
          onChange={(e) => handleChange('author', e.target.value)}
          placeholder="Your Name or Organization"
        />
         <p className="text-sm text-muted-foreground">The default author for content on this site.</p>
      </div>
       {/* --- NEW BASE URL FIELD --- */}
       <div className="space-y-2 border-t pt-6">
        <Label htmlFor="baseUrl">Base URL</Label>
        <Input
          id="baseUrl"
          type="url"
          value={formData.baseUrl}
          onChange={(e) => handleChange('baseUrl', e.target.value)}
          placeholder="https://www.my-awesome-site.com"
        />
         <p className="text-sm text-muted-foreground">
            The full public URL of your site. Required for generating correct RSS feeds and sitemaps.
         </p>
      </div>
    </div>
  );
}

================================================================================

File: features/site-settings/components/SettingsNav.tsx
'use-client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { TbUserCircle, TbPalette } from 'react-icons/tb';
import { cn } from '@/lib/utils';

// This is the navigation component for the settings area.
export default function SettingsNav() {
  const pathname = usePathname();
  const siteId = pathname.split('/')[2];

  const navItems = [
    { href: `/sites/${siteId}/settings`, title: 'Site Details', icon: TbUserCircle },
    { href: `/sites/${siteId}/settings/appearance`, title: 'Appearance', icon: TbPalette },
    // Add more settings links here as needed
  ];

  return (
    <div className="flex h-full flex-col p-4">
      <h2 className="px-2 text-lg font-semibold tracking-tight">Settings</h2>
      <nav className="mt-4 flex flex-col gap-1">
        {navItems.map((item) => (
          <Link
            key={item.href}
            href={item.href}
            className={cn(
              'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
              pathname === item.href
                ? 'bg-primary text-primary-foreground'
                : 'text-muted-foreground hover:bg-muted/50 hover:text-foreground'
            )}
          >
            <item.icon className="h-5 w-5" />
            {item.title}
          </Link>
        ))}
      </nav>
    </div>
  );
}

================================================================================

File: features/editor/contexts/EditorContext.tsx
// src/contexts/EditorContext.tsx
'use client';
import { toast } from 'sonner';

import { createContext, useContext, useState, ReactNode, useMemo, useRef, useCallback } from 'react';

export type SaveState = 'idle' | 'saving' | 'saved' | 'no_changes';

interface EditorContextType {
  setLeftSidebar: (content: ReactNode) => void;
  setRightSidebar: (content: ReactNode) => void;
  saveState: SaveState;
  setSaveState: (state: SaveState) => void;
  hasUnsavedChanges: boolean;
  setHasUnsavedChanges: (hasChanges: boolean) => void;
  triggerSave: () => Promise<void>;
  registerSaveAction: (saveFn: () => Promise<void>) => void;
}

export const EditorContext = createContext<EditorContextType | undefined>(undefined);

interface EditorProviderProps {
  children: ReactNode; 
}

export function EditorProvider({ children }: EditorProviderProps) {
  const [leftSidebarContent, setLeftSidebarContent] = useState<ReactNode>(null);
  const [rightSidebarContent, setRightSidebarContent] = useState<ReactNode>(null);
  const [saveState, setSaveState] = useState<SaveState>('no_changes');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const saveActionRef = useRef<(() => Promise<void>) | null>(null);

  const registerSaveAction = useCallback((saveFn: () => Promise<void>) => {
    saveActionRef.current = saveFn;
  }, []);
  
  const triggerSave = useCallback(async () => {
    if (saveActionRef.current) { // Allow manual save even if no changes (for "new file" mode)
      setSaveState('saving');
      try {
        await saveActionRef.current();
        setSaveState('saved');
        setHasUnsavedChanges(false);
        setTimeout(() => setSaveState('no_changes'), 2000);
      } catch (error) {
        console.error("Save failed:", error);
        toast.error((error as Error).message || "Failed to save.");
        setSaveState('idle'); 
      }
    }
  }, []);

  const contextValue = useMemo(() => ({
    setLeftSidebar: setLeftSidebarContent,
    setRightSidebar: setRightSidebarContent,
    // Determine saveState based on hasUnsavedChanges
    saveState: hasUnsavedChanges ? 'idle' : saveState,
    // --- EXPOSE THE SETTER FUNCTION ---
    setSaveState,
    hasUnsavedChanges,
    setHasUnsavedChanges,
    triggerSave,
    registerSaveAction,
  }), [saveState, hasUnsavedChanges, registerSaveAction, triggerSave]);

  return (
    <EditorContext.Provider value={contextValue}>
      {children}
    </EditorContext.Provider>
  );
}

export function useEditor() {
  const context = useContext(EditorContext);
  if (context === undefined) {
    throw new Error('useEditor must be used within an EditorProvider');
  }
  return context;
}

================================================================================

File: features/editor/components/ViewEditor.tsx
// src/features/editor/components/ViewEditor.tsx
'use client';

import { useEffect, useState, useCallback } from 'react';
import { MarkdownFrontmatter, ViewConfig, StructureNode } from '@/types';
import { getAvailableLayouts, LayoutManifest, getJsonAsset, ViewManifest } from '@/core/services/configHelpers.service';
import { useAppStore } from '@/core/state/useAppStore';
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';
import { RJSFSchema } from '@rjsf/utils';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";

interface ViewEditorProps {
  siteId: string;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;
}

export default function ViewEditor({ siteId, frontmatter, onFrontmatterChange }: ViewEditorProps) {
  const site = useAppStore(state => state.getSiteById(siteId));

  // --- State for UI & Data ---
  const [collections, setCollections] = useState<StructureNode[]>([]);
  const [itemLayouts, setItemLayouts] = useState<LayoutManifest[]>([]);
  const [pageLayouts, setPageLayouts] = useState<LayoutManifest[]>([]);
  const [customViewSchema, setCustomViewSchema] = useState<RJSFSchema | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // --- Data Fetching Effect ---
  useEffect(() => {
    async function fetchData() {
      if (!site) return;
      setIsLoading(true);

      const viewTemplateId = frontmatter.view?.template;
      
      // Fetch data for the hard-coded dropdowns
      const allCollections = site.manifest.structure.filter(n => n.type === 'collection');
      setCollections(allCollections);

      const allLayouts = await getAvailableLayouts(site);
      setItemLayouts(allLayouts.filter(l => l.layoutType === 'item'));
      setPageLayouts(allLayouts.filter(l => l.layoutType === 'page'));

      // Fetch the schema for the view-specific custom fields
      if (viewTemplateId) {
          const viewManifest = await getJsonAsset<ViewManifest>(site, 'view', viewTemplateId, 'view.json');
          setCustomViewSchema(viewManifest?.schema || null);
      } else {
          setCustomViewSchema(null);
      }
      
      setIsLoading(false);
    }
    fetchData();
  }, [site, frontmatter.view?.template]);

  // --- Event Handlers ---

  /**
   * Generic handler for the dedicated dropdowns.
   */
  const handleDedicatedFieldChange = useCallback((key: keyof ViewConfig, value: string) => {
    onFrontmatterChange({
      view: { ...(frontmatter.view!), [key]: value }
    });
  }, [frontmatter.view, onFrontmatterChange]);

  /**
   * Handler for the SchemaDrivenForm, merging its data with the existing view config.
   */
  const handleCustomFormChange = useCallback((formData: object) => {
    onFrontmatterChange({
      view: { ...(frontmatter.view!), ...formData }
    });
  }, [frontmatter.view, onFrontmatterChange]);

  const viewConfig = frontmatter.view;

  // --- Render Logic ---

  if (isLoading) {
    return <div className="p-6">Loading view options...</div>;
  }
  
  if (!viewConfig) {
      return (
          <div className="p-6 text-center text-destructive-foreground bg-destructive/20 border border-destructive rounded-lg">
              <h3 className="font-semibold">Error</h3>
              <p className="text-sm">This page is not configured as a View Page.</p>
          </div>
      );
  }

  return (
    <div className="p-6 border rounded-lg bg-muted/20 space-y-6">
      
      {/* --- Hard-coded, Universal View Fields --- */}
      <div className="space-y-4">
        <div className="space-y-2">
            <Label htmlFor="source-collection">Content Source</Label>
            <p className="text-xs text-muted-foreground">Choose the collection to display items from.</p>
            <Select 
            value={viewConfig.source_collection} 
            onValueChange={(value) => handleDedicatedFieldChange('source_collection', value)}
            >
            <SelectTrigger id="source-collection">
                <SelectValue placeholder="Select a collection..." />
            </SelectTrigger>
            <SelectContent>
                {collections.map(c => <SelectItem key={c.slug} value={c.slug}>{c.title}</SelectItem>)}
            </SelectContent>
            </Select>
        </div>

        <div className="space-y-2">
            <Label htmlFor="item-layout">Item Display Layout (in lists)</Label>
            <p className="text-xs text-muted-foreground">Controls how each item looks in the list on this page.</p>
            <Select 
                value={viewConfig.item_layout}
                onValueChange={(value) => handleDedicatedFieldChange('item_layout', value)}
            >
                <SelectTrigger id="item-layout"><SelectValue placeholder="Select an item layout..." /></SelectTrigger>
                <SelectContent>
                    {itemLayouts.map(l => <SelectItem key={l.name} value={l.name}>{l.name}</SelectItem>)}
                </SelectContent>
            </Select>
        </div>
        
        <div className="space-y-2">
            <Label htmlFor="item-page-layout">Item Full Page Layout</Label>
            <p className="text-xs text-muted-foreground">Controls the layout when a user clicks through to view a single item.</p>
            <Select 
                value={viewConfig.item_page_layout}
                onValueChange={(value) => handleDedicatedFieldChange('item_page_layout', value)}
            >
                <SelectTrigger id="item-page-layout"><SelectValue placeholder="Select a page layout..." /></SelectTrigger>
                <SelectContent>
                    {pageLayouts.map(l => <SelectItem key={l.name} value={l.name}>{l.name}</SelectItem>)}
                </SelectContent>
            </Select>
        </div>
      </div>

      {/* --- Schema-Driven Custom Fields --- */}
      {customViewSchema && (
        <Accordion type='single' collapsible className="w-full" defaultValue='custom-options'>
          <AccordionItem value="custom-options">
              <AccordionTrigger>View-Specific Options</AccordionTrigger>
              <AccordionContent className="pt-4">
                <SchemaDrivenForm
                    schema={customViewSchema}
                    formData={viewConfig}
                    onFormChange={handleCustomFormChange}
                />
              </AccordionContent>
          </AccordionItem>
        </Accordion>
      )}
    </div>
  );
}

================================================================================

File: features/editor/components/EditorHeader.tsx
'use client';

import { useState, useContext } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';
import { Button } from '@/core/components/ui/button';
import { toast } from 'sonner';
import { exportSiteToZip } from '@/core/services/siteExporter.service';
import { EditorContext, useEditor } from '@/features/editor/contexts/EditorContext'; 
import { slugify } from '@/lib/utils';
import { Eye, PanelLeft, UploadCloud, PanelRight, Save, Check, Loader2 } from 'lucide-react';
import Image from 'next/image';

const SaveButton = () => {
  // --- START OF FIX ---
  // Directly get the context. If it's undefined, we are not in an EditorProvider.
  const editorContext = useContext(EditorContext);

  // If there's no context, this button has no purpose, so render nothing.
  if (!editorContext) {
    return null;
  }
  // --- END OF FIX ---

  // Now that we know the context exists, we can safely call the hook.
  const { saveState, triggerSave } = useEditor();

  const buttonContent = {
    idle: { icon: <Save className="h-4 w-4" />, text: 'Save ' },
    saving: { icon: <Loader2 className="h-4 w-4 animate-spin" />, text: 'Saving' },
    saved: { icon: <Check className="h-4 w-4" />, text: 'Saved' },
    no_changes: { icon: <Check className="h-4 w-4" />, text: 'Saved' },
  };

  const current = buttonContent[saveState];
  const isDisabled = saveState === 'saving' || saveState === 'saved' || saveState === 'no_changes';

  return (
    <Button variant='ghost' onClick={triggerSave} disabled={isDisabled}>
      {current.icon}
      <span className='hidden md:block'>{current.text}</span>
    </Button>
  );
};


export default function EditorHeader() {
  const params = useParams();
  const siteId = params.siteId as string;
  const [isPublishing, setIsPublishing] = useState(false);
  const site = useAppStore((state) => state.getSiteById(siteId));
  
  const toggleLeftSidebar = useUIStore((state) => state.sidebar.toggleLeftSidebar);
  const toggleRightSidebar = useUIStore((state) => state.sidebar.toggleRightSidebar);
  const isLeftAvailable = useUIStore((state) => state.sidebar.isLeftAvailable);
  const isRightAvailable = useUIStore((state) => state.sidebar.isRightAvailable);


  const handlePublishSite = async () => {
    if (!site) {
      toast.error("Site data not found. Cannot publish.");
      return;
    }
    setIsPublishing(true);
    toast.info("Generating site bundle for download...");
    try {
      const blob = await exportSiteToZip(site);
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${slugify(site.manifest.title || 'signum-site')}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      toast.success("Site bundle downloaded!");
    } catch (error) {
      console.error("Error publishing site to Zip:", error);
      toast.error(`Failed to generate Zip: ${(error as Error).message}`);
    } finally {
        setIsPublishing(false);
    }
  };
  
  if (!site) {
    return (
        <header className="sticky top-0 z-20 flex h-[60px] items-center gap-4 border-b bg-background px-4 lg:h-[60px]"></header>
    );
  }

  return (
    <header className="sticky top-0 z-20 flex shrink-0 items-center gap-4 border-b bg-background lg:pl-4 pr-4 h-[60px]">
      <div className="flex items-center gap-2">
        {/* Render button only if the left sidebar is available for the current page */}
        <Link
            href="/sites"
            title="Dashboard"
            className=' flex lg:hidden flex-col w-[60px] h-[60px] items-center border-r mr-2'
          >
            <Image src="/signum.svg" width={34} height={34} alt="" className='m-auto'/>
          </Link>
        {isLeftAvailable && (
            <Button 
                variant="outline" 
                size="icon" 
                className="shrink-0" 
                onClick={toggleLeftSidebar}
            >
                <PanelLeft className="h-5 w-5" />
                <span className="sr-only">Toggle file tree</span>
            </Button>
        )}
      </div>

      <div className="flex-1 text-lg text-muted-foreground">
       <span className="font-bold text-foreground">{site.manifest.title}</span>
      </div>
      
      <div className="flex items-center justify-end gap-2">
        <SaveButton />
        <Button variant="outline" asChild>
            <Link href={`/sites/${siteId}/view`} target="_blank">
                <Eye className="h-4 w-4" /> <span className='hidden md:block '>View</span>
            </Link>
        </Button>
        <Button variant="default" onClick={handlePublishSite} disabled={isPublishing}>
            <UploadCloud className="h-4 w-4" /> 
            <span className='hidden md:block '>{isPublishing ? 'Publishing...' : 'Publish'}</span>
        </Button>

        {/* Render button only if the right sidebar is available for the current page */}
        {isRightAvailable && (
            <Button variant="outline" size="icon" className="shrink-0" onClick={toggleRightSidebar}>
                <PanelRight className="h-5 w-5" />
                <span className="sr-only">Toggle settings sidebar</span>
            </Button>
        )}
      </div>
    </header>
  );
}

================================================================================

File: features/editor/components/PrimaryContentFields.tsx
// src/components/publishing/PrimaryContentFields.tsx
'use client';

import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { Label } from '@/core/components/ui/label';
import { MarkdownFrontmatter } from '@/types';

// FIXED: The interface is now much stricter and safer.
// It only defines the properties this component actually cares about.
interface PrimaryFieldsProps {
  frontmatter: {
    title?: string;
    description?: string;
  };
  // The callback expects a partial update to the main frontmatter state.
  onFrontmatterChange: (newData: Partial<MarkdownFrontmatter>) => void;
  showDescription?: boolean;
}

export default function PrimaryContentFields({
  frontmatter,
  onFrontmatterChange,
}: PrimaryFieldsProps) {

  // FIXED: The handler now only passes back the single field that changed.
  // This makes the component more reusable and decoupled from the parent's state shape.
  const handleChange = (field: 'title' | 'description', value: string) => {
    onFrontmatterChange({
      [field]: value,
    });
  };

  return (
    <div className="space-y-4 shrink-0">
      <div className="space-y-2 mb-6 border-b pb-3">
        <Label htmlFor="content-title" className="text-[10px] font-medium uppercase text-gray-400">
          Title
        </Label>
        <Input
          id="content-title"
          placeholder="Enter a title..."
          value={frontmatter.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          // These classes create the large, "invisible" input style
          className="text-2xl lg:text-3xl font-bold h-auto p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent"
        />
      </div>

        <div className="space-y-2 mb-6 border-b pb-3">
          <Label htmlFor="content-description" className="text-[10px] font-medium uppercase text-gray-400">
            Description
          </Label>
          <Textarea
            
            placeholder="Add a short description..."
            value={frontmatter.description || ''}
            onChange={(e) => handleChange('description', e.target.value)}
            // Style for a clean, borderless textarea
            className="p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent resize-none text-2xl text-black"
            rows={1}
          />
        </div>
    </div>
  );
}

================================================================================

File: features/editor/components/NewCollectionDialog.tsx
// src/components/publishing/NewCollectionDialog.tsx
'use client';

import { useState, useEffect, type ReactNode } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';

interface NewCollectionDialogProps {
  children: ReactNode;
  existingSlugs: string[];
  onSubmit: (name: string, slug: string) => Promise<void>;
}

export default function NewCollectionDialog({ children, existingSlugs, onSubmit }: NewCollectionDialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');

  useEffect(() => {
    if (name) {
      setSlug(slugify(name));
    } else {
      setSlug('');
    }
  }, [name]);
  

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !slug.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }

    if (existingSlugs.includes(slug)) {
      toast.error(`A collection or page with the folder name "${slug}" already exists.`);
      return;
    }

    await onSubmit(name, slug);
    
    // Reset state after submission
    setIsOpen(false);
    setName('');
    setSlug('');

  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection</DialogTitle>
            <DialogDescription>
              Create a new folder to organize your content. All items in this collection will share a common layout.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
            
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name.trim()}>Create collection</Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/NewPageDialog.tsx
// src/features/editor/components/NewPageDialog.tsx
'use client';

import { useState, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// --- UI & Type Imports ---
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter } from '@/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface NewPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function NewPageDialog({ siteId, children, onComplete }: NewPageDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [title, setTitle] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setTitle('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleCreatePage = async () => {
    if (!title.trim()) {
      toast.error("Page title cannot be empty.");
      return;
    }
    setIsSubmitting(true);
    const slug = slugify(title);
    const filePath = `content/${slug}.md`;

    const slugExists = site?.contentFiles?.some(f => f.slug === slug);
    if (slugExists) {
        toast.error(`A page with the slug "${slug}" already exists.`);
        setIsSubmitting(false);
        return;
    }
    
    const frontmatter: MarkdownFrontmatter = {
        title: title.trim(),
        layout: DEFAULT_PAGE_LAYOUT_PATH,
        date: new Date().toISOString().split('T')[0],
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\n# ${title.trim()}\n\nStart writing your content here.\n`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent, frontmatter.layout);
      if (success) {
        toast.success(`Page "${title}" created!`);
        handleOpenChange(false);
        onComplete?.();
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else { throw new Error("Failed to update manifest or save file."); }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New Content Page</DialogTitle>
          <DialogDescription>
            Give your new page a title. You can add content and change settings later.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="space-y-1">
            <Label htmlFor="title">Page Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., About Us" />
          </div>
        </div>
        <DialogFooter>
          <DialogClose asChild><Button variant="outline">Cancel</Button></DialogClose>
          <Button type="button" onClick={handleCreatePage} disabled={!title.trim() || isSubmitting}>
            {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Page</>}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/CollectionList.tsx
// src/components/publishing/CollectionList.tsx
'use client';

import { useMemo } from 'react';
import Link from 'next/link';
import { useAppStore } from '@/core/state/useAppStore';
import NewCollectionDialog from '@/features/editor/components/NewCollectionDialog';
import { Button } from '@/core/components/ui/button';
import { FolderPlus, LayoutGrid } from 'lucide-react';
import type { StructureNode } from '@/types';

interface CollectionListProps {
  siteId: string;
}

export default function CollectionList({ siteId }: CollectionListProps) {
  // Subscribe to the site data to get the list of collections
  const site = useAppStore((state) => state.getSiteById(siteId));
  const addNewCollection = useAppStore((state) => state.addNewCollection);

  // Memoize the list of collections for performance
  const collections = useMemo(() => {
    return site?.manifest.structure.filter((node: StructureNode) => node.type === 'collection') || [];
  }, [site?.manifest.structure]);
  
  const existingSlugs = useMemo(() => {
    return site?.manifest.structure.map((node: StructureNode) => node.slug) || [];
  }, [site?.manifest.structure]);

  // Handler for creating a new collection is now self-contained here.
  const handleCreateNewCollection = async (name: string, slug: string) => {
    // --- START OF FIX ---
    // Call the action with the correct number of arguments.
    // The layout argument is no longer needed.
    await addNewCollection(siteId, name, slug);
    // --- END OF FIX ---
  };

  if (!site) {
    return null; // Don't render if site data isn't loaded
  }

  return (
    <div className="flex flex-col h-full">
      <div className="flex px-1 py-1 shrink-0 items-center justify-between">
        <h4 className="text-xs font-semibold uppercase tracking-wider text-muted-foreground ml-2">Collections</h4>
        <NewCollectionDialog
          existingSlugs={existingSlugs}
          // The dialog itself needs to be updated to no longer ask for a layout
          onSubmit={handleCreateNewCollection}
        >
            <Button variant="ghost" className='size-6 p-2 rounded-sm' title="New Collection">
                <FolderPlus className="h-4 w-4" />
            </Button>
        </NewCollectionDialog>
      </div>

      <div className="flex-grow overflow-y-auto px-2 py-2">
        {collections.length > 0 ? (
          <div className="space-y-1">
            {collections.map((collection) => (
              <Link
                key={collection.path}
                // This link will eventually go to a settings page for the collection,
                // not a view page, as per our new architecture.
                href={`/sites/${siteId}/edit/collection/${collection.slug}`}
                className="flex items-center gap-2 rounded-md px-2 py-1.5 text-sm font-medium text-muted-foreground hover:bg-muted hover:text-foreground transition-colors"
                title={collection.title}
              >
                <LayoutGrid className="h-4 w-4" />
                <span className="truncate">{collection.title}</span>
              </Link>
            ))}
          </div>
        ) : (
          <p className="px-2 text-xs text-muted-foreground italic">No collections created yet.</p>
        )}
      </div>
    </div>
  );
}

================================================================================

File: features/editor/components/FileTree.tsx
// src/components/publishing/FileTree.tsx
'use client';

import React, { useState, useMemo } from 'react';
import Link from 'next/link';
import { useParams } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { type StructureNode } from '@/types';
import { findNodeByPath } from '@/core/services/fileTree.service';
import { toast } from 'sonner';

import { GripVertical, ChevronRight, File as FileIcon } from 'lucide-react';
import { cn } from '@/lib/utils';
import { 
    DndContext, 
    closestCenter, 
    DragEndEvent, 
    DragStartEvent, 
    useDroppable,
    DragOverlay
} from '@dnd-kit/core';
import { 
    SortableContext, 
    useSortable, 
    verticalListSortingStrategy, 
    arrayMove 
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

// --- Type Definitions ---
interface FileTreeProps {
  nodes: StructureNode[];
  baseEditPath: string;
  activePath?: string;
  onStructureChange: (nodes: StructureNode[]) => void;
  className?: string; 
}

interface FileTreeNodeProps extends Omit<FileTreeProps, 'nodes' | 'onStructureChange' | 'className'> {
  node: StructureNode;
  activeDragId: string | null;
  onStructureChange: (reorderedChildren: StructureNode[]) => void;
}


// --- Draggable & Droppable Node Component ---
const DndNode: React.FC<FileTreeNodeProps> = ({ node, baseEditPath, activePath, activeDragId, onStructureChange }) => {
    const { attributes, listeners, setNodeRef: setSortableNodeRef, transform, transition } = useSortable({
        id: node.path,
        disabled: node.type !== 'page', // Only pages can be sorted/dragged
    });
    
    const [isOpen, setIsOpen] = useState(true);

    const isPage = node.type === 'page';
    // An item is only a valid drop target if it's a page and something is being dragged.
    const isNestableTarget = isPage && !!activeDragId;

    const { isOver, setNodeRef: setDroppableNodeRef } = useDroppable({
        id: node.path,
        disabled: !isNestableTarget,
    });
    
    const setNodeRef = (el: HTMLElement | null) => {
        setSortableNodeRef(el);
        setDroppableNodeRef(el);
    };

    const style = { transform: CSS.Transform.toString(transform), transition };
    const dropIndicatorStyle = isOver && isNestableTarget ? 'bg-blue-100 dark:bg-blue-900/50 outline outline-1 outline-blue-500' : '';
    const hasChildren = node.children && node.children.length > 0;

    const href = `${baseEditPath}/content/${node.path.replace(/^content\//, '').replace(/\.md$/, '')}`;

    const handleChildrenStructureChange = (reorderedChildren: StructureNode[]) => {
        const newParentNode = { ...node, children: reorderedChildren };
        // This bubbles up the change to the parent FileTree instance
        onStructureChange([newParentNode]);
    };

    return (
        <div ref={setNodeRef} style={style} className="flex flex-col">
            <div className={cn("flex items-center group w-full my-0.5 rounded-md transition-colors", dropIndicatorStyle)}>
                <div 
                    {...attributes} 
                    {...listeners} 
                    className={cn(
                        "p-1 cursor-grab touch-none text-muted-foreground/50",
                        !isPage && "cursor-not-allowed opacity-50" // Visual cue for non-draggable items
                    )}
                >
                    <GripVertical className="h-4 w-4" />
                </div>
                <div className={cn("flex-grow flex items-center py-1 pl-1 pr-1 rounded-md hover:bg-muted", activePath === node.path && "bg-accent text-accent-foreground")}>
                    <ChevronRight 
                        className={cn("h-4 w-4 mr-1 shrink-0 transition-transform duration-200", hasChildren ? 'cursor-pointer' : 'invisible', isOpen && "rotate-90")} 
                        onClick={() => hasChildren && setIsOpen(!isOpen)}
                    />
                    <FileIcon className="h-4 w-4 shrink-0 text-muted-foreground" />
                    <Link href={href} className="truncate flex-grow mx-1.5 text-sm" title={node.title}>{node.title}</Link>
                </div>
            </div>
            {hasChildren && isOpen && (
                <div className="pl-6 border-l ml-4">
                    <FileTree
                        nodes={node.children!}
                        baseEditPath={baseEditPath}
                        activePath={activePath}
                        onStructureChange={handleChildrenStructureChange}
                        className="py-1"
                    />
                </div>
            )}
        </div>
    );
};


// --- Main FileTree Component ---
export default function FileTree({ nodes, baseEditPath, activePath, onStructureChange, className }: FileTreeProps) {
  const { moveNode } = useAppStore.getState();
  const siteId = useParams().siteId as string;
  const [activeDragId, setActiveDragId] = useState<string | null>(null);

  const nodeIds = useMemo(() => nodes.map(n => n.path), [nodes]);

  const handleDragStart = (event: DragStartEvent) => {
      setActiveDragId(event.active.id as string);
  };

  const handleDragEnd = (event: DragEndEvent) => {
    setActiveDragId(null);
    const { active, over } = event;

    if (!over || active.id === over.id) return;

    const draggedNode = findNodeByPath(nodes, active.id as string);
    if (!draggedNode || draggedNode.type !== 'page') {
        toast.info("Collections cannot be re-ordered in this view.");
        return;
    }
    
    const overNode = findNodeByPath(nodes, over.id as string);

    // If overNode exists and is a page, it's a nesting attempt.
    if (overNode && overNode.type === 'page') {
        moveNode(siteId, active.id as string, over.id as string);
    } else {
        // Otherwise, it's a reordering attempt within the current list.
        const oldIndex = nodeIds.indexOf(active.id as string);
        const newIndex = nodeIds.indexOf(over.id as string);
        if (oldIndex !== -1 && newIndex !== -1) {
            onStructureChange(arrayMove(nodes, oldIndex, newIndex));
        }
    }
  };

  return (
    <div className={cn("w-full", className)}>
        <DndContext 
            onDragStart={handleDragStart} 
            onDragEnd={handleDragEnd} 
            collisionDetection={closestCenter}
        >
            <SortableContext items={nodeIds} strategy={verticalListSortingStrategy}>
                <div className="space-y-0.5">
                    {nodes.map(node => (
                        <DndNode 
                            key={node.path} 
                            node={node} 
                            baseEditPath={baseEditPath} 
                            activePath={activePath} 
                            // This callback is complex. It ensures that when a child's structure changes,
                            // the change is propagated up to the main list.
                            onStructureChange={(updatedChildList) => {
                                const newNodes = nodes.map(n => 
                                    n.path === updatedChildList[0].path ? updatedChildList[0] : n
                                );
                                onStructureChange(newNodes);
                            }}
                            activeDragId={activeDragId}
                        />
                    ))}
                </div>
            </SortableContext>
            <DragOverlay>
                {activeDragId ? <div className="p-2 bg-blue-100 dark:bg-blue-900 rounded-md shadow-lg text-sm">Moving page...</div> : null}
            </DragOverlay>
        </DndContext>
    </div>
  );
}

================================================================================

File: features/editor/components/DataSourceSelectWidget.tsx
// src/features/editor/components/DataSourceSelectWidget.tsx
'use client';

import { useEffect, useState, useMemo } from 'react';
import { getAvailableLayouts } from '@/core/services/configHelpers.service';
import { WidgetProps } from '@rjsf/utils';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Label } from '@/core/components/ui/label';
// --- FIX: Import types from their correct source files ---
import type { LocalSiteData, StructureNode } from '@/types';
import type { LayoutManifest } from '@/core/services/configHelpers.service';

// Define a consistent shape for the dropdown options
interface SelectOption {
  label: string;
  value: string;
}

// The widget's props now correctly type the `formContext` which will contain the site data
interface DataSourceSelectWidgetProps extends WidgetProps {
    formContext?: { // The context is now optional
        site?: LocalSiteData; // The site within the context is also optional
    };
}

const DataSourceSelectWidget = ({ id, label, options, value, onChange, required, formContext }: DataSourceSelectWidgetProps) => {
  const { uiSchema } = options;
    const site = formContext?.site;

  const dataSource = uiSchema?.['ui:dataSource'] as string;
  const layoutTypeFilter = uiSchema?.['ui:layoutType'] as string | undefined;

  const [items, setItems] = useState<SelectOption[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // This effect fetches the dynamic options for the dropdown.
    const fetchItems = async () => {
      if (!site) {
        setItems([]);
        setIsLoading(false);
        return;
      }
      setIsLoading(true);

      let fetchedItems: SelectOption[] = [];

      try {
        switch (dataSource) {
          case 'collections':
            // --- FIX: Explicitly type 'n' as StructureNode ---
            fetchedItems = site.manifest.structure
              .filter((n: StructureNode) => n.type === 'collection')
              .map((c: StructureNode) => ({ label: c.title, value: c.slug }));
            break;
          
          case 'layouts':
            const allLayouts: LayoutManifest[] = await getAvailableLayouts(site);
            fetchedItems = allLayouts
              .filter(l => !layoutTypeFilter || l.layoutType === layoutTypeFilter)
              // --- FIX: Use `l.name` as the unique ID, not `l.id` ---
              .map(l => ({ label: l.name, value: l.name })); 
            break;
            
          default:
            fetchedItems = [];
        }
        setItems(fetchedItems);
      } catch (error) {
        console.error(`Failed to fetch data source "${dataSource}":`, error);
        setItems([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchItems();
  }, [site, dataSource, layoutTypeFilter]);

  const placeholder = useMemo(() => {
    if (isLoading) {
        return `Loading ${dataSource || 'options'}...`;
    }
    if (dataSource) {
        return `Select a ${dataSource.replace(/s$/, '')}...`;
    }
    return 'Select an option...'; // Generic fallback
  }, [isLoading, dataSource]);

  return (
    <div className="space-y-1">
      <Label htmlFor={id}>{label}{required ? '*' : ''}</Label>
      <Select value={value} onValueChange={onChange} disabled={isLoading}>
        <SelectTrigger id={id} className="mt-1">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {items.map(item => (
            <SelectItem key={item.value} value={item.value}>
              {item.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DataSourceSelectWidget;

================================================================================

File: features/editor/components/NewViewDialog.tsx
// src/features/editor/components/NewViewDialog.tsx
'use client';

import { useState, useMemo, type ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/lib/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// --- UI & Type Imports ---
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Plus } from 'lucide-react';
import type { MarkdownFrontmatter, StructureNode } from '@/types';
import { DEFAULT_VIEW_LAYOUT_PATH } from '@/config/editorConfig';

interface NewViewDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function NewViewDialog({ siteId, children, onComplete }: NewViewDialogProps) {
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);
  const [title, setTitle] = useState('');
  const [sourceCollection, setSourceCollection] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  const availableCollections = useMemo(() => {
    return site?.manifest.structure.filter((node: StructureNode) => node.type === 'collection') || [];
  }, [site?.manifest.structure]);

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setTitle('');
        setSourceCollection('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleCreateView = async () => {
    if (!title.trim() || !sourceCollection) {
      toast.error("Both a title and a source collection are required.");
      return;
    }
    setIsSubmitting(true);
    const slug = slugify(title);
    const filePath = `content/${slug}.md`;

    const slugExists = site?.contentFiles?.some(f => f.slug === slug);
    if (slugExists) {
        toast.error(`A page with the slug "${slug}" already exists.`);
        setIsSubmitting(false);
        return;
    }

    const frontmatter: MarkdownFrontmatter = {
        title: title.trim(),
        layout: DEFAULT_VIEW_LAYOUT_PATH,
        date: new Date().toISOString().split('T')[0],
        view: {
            template: 'list',
            source_collection: sourceCollection,
        }
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\n# ${title.trim()}\n\nThis page lists content from the "${sourceCollection}" collection. You can add introductory text here.`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent, frontmatter.layout);
      if (success) {
        toast.success(`View page "${title}" created!`);
        handleOpenChange(false);
        onComplete?.();
        router.push(`/sites/${siteId}/edit/content/${slug}`);
      } else { throw new Error("Failed to update manifest or save file."); }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New View Page</DialogTitle>
          <DialogDescription>
            This page will display a list of items from a collection.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="space-y-1">
            <Label htmlFor="view-title">Page Title</Label>
            <Input id="view-title" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Blog" />
          </div>
          <div className="space-y-1">
            <Label htmlFor="source-collection">Content Source</Label>
            <Select value={sourceCollection} onValueChange={setSourceCollection}>
              <SelectTrigger id="source-collection"><SelectValue placeholder="Select a collection..." /></SelectTrigger>
              <SelectContent>
                {availableCollections.map(c => <SelectItem key={c.slug} value={c.slug}>{c.title}</SelectItem>)}
              </SelectContent>
            </Select>
          </div>
        </div>
        <DialogFooter>
          <DialogClose asChild><Button variant="outline">Cancel</Button></DialogClose>
          <Button type="button" onClick={handleCreateView} disabled={!title.trim() || !sourceCollection || isSubmitting}>
            {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create View Page</>}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/RightSidebar.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';

interface RightSidebarProps {
  children: ReactNode;
}

export default function RightSidebar({ children }: RightSidebarProps) {
  const { isRightOpen } = useUIStore((state) => state.sidebar);

  return (
    <aside
      className={cn(
        // Base styles
        'h-full w-80 shrink-0 border-l bg-muted/20 transition-all duration-300 ease-in-out',
        
        // Hide/Show Logic
        isRightOpen ? 'ml-0' : '-mr-[320px] w-0 border-l-0 opacity-0'
      )}
    >
      <div className="h-full overflow-y-auto">
        {children}
      </div>
    </aside>
  );
}

================================================================================

File: features/editor/components/FrontmatterSidebar.tsx
// src/features/editor/components/FrontmatterSidebar.tsx
'use client';

import React, { useState, useEffect, useMemo } from 'react';
import type { LocalSiteData, MarkdownFrontmatter } from '@/types';
import { getAvailableLayouts, getLayoutManifest, LayoutManifest } from '@/core/services/configHelpers.service';
import { RJSFSchema } from '@rjsf/utils';
import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Button } from '@/core/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Trash2 } from 'lucide-react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";
import SchemaDrivenForm from '@/components/publishing/SchemaDrivenForm';

interface FrontmatterSidebarProps {
  site: Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles' | 'contentFiles'>;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: Partial<MarkdownFrontmatter>) => void;
  isNewFileMode: boolean;
  slug: string;
  onSlugChange: (newSlug: string) => void;
  onDelete: () => Promise<void>;
  // The onViewModeToggle prop is no longer needed
}

export default function FrontmatterSidebar({
  site, frontmatter, onFrontmatterChange,
  isNewFileMode, slug, onSlugChange, onDelete,
}: FrontmatterSidebarProps) {
  
  const [layoutSchema, setLayoutSchema] = useState<RJSFSchema | null>(null);
  const [availableLayouts, setAvailableLayouts] = useState<LayoutManifest[]>([]);

  // Determine if the current page is a View Page based on its frontmatter.
  // This is now the single source of truth for the page's type.
  const isViewPage = useMemo(() => !!frontmatter.view, [frontmatter]);

  // This effect fetches and filters available layouts based on the page's type.
  useEffect(() => {
    async function fetchAndFilterLayouts() {
      if (!site) return;
      
      const allLayouts = await getAvailableLayouts(site);
      
      // --- FIX: Determine the required layoutType based on whether it's a view page. ---
      const requiredLayoutType = isViewPage ? 'view' : 'page';
      
      // --- FIX: Filter using the updated layoutType enum. ---
      const filtered = allLayouts.filter(layout => layout.layoutType === requiredLayoutType);
      setAvailableLayouts(filtered);
    }
    fetchAndFilterLayouts();
  }, [site, isViewPage]); // The dependencies are correct.
  // This effect loads the schema for the selected layout.
  useEffect(() => {
    const loadSchema = async () => {
      if (!frontmatter.layout) return;
      const manifest = await getLayoutManifest(site, frontmatter.layout);
      setLayoutSchema(manifest?.schema || null);
    };
    loadSchema();
  }, [site, frontmatter.layout]);

  const handleLayoutChange = (layoutId: string) => {
    onFrontmatterChange({ layout: layoutId });
  };
  
  return (
    <div className="p-4 space-y-6 h-full flex flex-col">
      {/* --- Page Layout & Settings --- */}
      <Accordion type='single' collapsible className="w-full" defaultValue="item-1">
        <AccordionItem value="item-1">
          <AccordionTrigger>Page Settings</AccordionTrigger>
          <AccordionContent className="space-y-4 pt-4">
            <div>
                <Label htmlFor="page-layout-select">Page Layout</Label>
                <Select value={frontmatter.layout} onValueChange={handleLayoutChange}>
                    <SelectTrigger id="page-layout-select">
                        <SelectValue placeholder="Select a layout..." />
                    </SelectTrigger>
                    <SelectContent>
                        {availableLayouts.map(layout => (
                           <SelectItem key={layout.name} value={layout.name}>{layout.name}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                 <p className="text-xs text-muted-foreground mt-1">
                  Controls the layout for this page&apos;s own title and content.
                </p>
            </div>
            {layoutSchema && (
                <div className="border-t pt-4">
                    <SchemaDrivenForm
                        schema={layoutSchema}
                        formData={frontmatter}
                        onFormChange={(data) => onFrontmatterChange(data as Partial<MarkdownFrontmatter>)}
                    />
                </div>
            )}
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      {/* --- Advanced/Danger Zone (in its own accordion) --- */}
      <Accordion type='single' collapsible className="w-full">
        <AccordionItem value="item-1">
          <AccordionTrigger>Advanced</AccordionTrigger>
          <AccordionContent className="space-y-4 pt-4">
              <div className="space-y-2">
                <Label htmlFor="slug-input">URL Slug</Label>
                <Input 
                    id="slug-input"
                    value={slug}
                    onChange={(e) => onSlugChange(e.target.value)}
                    disabled={!isNewFileMode}
                    className={!isNewFileMode ? 'bg-muted/50' : ''}
                />
              </div>
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      {/* --- Delete Button (at the bottom) --- */}
      {!isNewFileMode && (
        <div className="mt-auto pt-6 border-t">
          <AlertDialog>
              <AlertDialogTrigger asChild>
                  <Button variant="outline" className="w-full text-destructive hover:bg-destructive/10 hover:text-destructive">
                      <Trash2 className="h-4 w-4 mr-2" /> Delete This Page
                  </Button>
              </AlertDialogTrigger>
              <AlertDialogContent> 
                  <AlertDialogHeader>
                      <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This action will permanently delete the file for &quot;{frontmatter?.title || 'this content'}&quot;. This cannot be undone.
                      </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                      <AlertDialogCancel>Cancel</AlertDialogCancel>
                      <AlertDialogAction onClick={onDelete} className="bg-destructive hover:bg-destructive/90 text-destructive-foreground">
                          Yes, Delete Forever
                      </AlertDialogAction>
                  </AlertDialogFooter>
              </AlertDialogContent>
          </AlertDialog>
        </div>
      )}
    </div>
  );
}

================================================================================

File: features/editor/hooks/useContentEditorState.ts
// src/features/editor/hooks/useContentEditorState.ts
'use client';

import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/EditorContext';
import type { MarkdownFrontmatter } from '@/types';
import { findNodeByPath } from '@/core/services/fileTree.service';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { parseMarkdownString, stringifyToMarkdown } from '@/lib/markdownParser';
import { slugify } from '@/lib/utils';
import { NEW_FILE_SLUG_MARKER, AUTOSAVE_DELAY, DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';
import { toast } from 'sonner';

export type EditorStatus = 'initializing' | 'loading' | 'ready' | 'not_found' | 'error';

export function useContentEditorState(siteId: string, slugSegments: string[]) {
  const router = useRouter();
  
  // --- Global State & Contexts ---
  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const { addOrUpdateContentFile, updateContentFileOnly, deleteContentFileAndState } = useAppStore.getState();
  const { setHasUnsavedChanges, registerSaveAction, setSaveState } = useEditor();
  
  // --- Local State ---
  const [status, setStatus] = useState<EditorStatus>('initializing');
  const [frontmatter, setFrontmatter] = useState<MarkdownFrontmatter | null>(null);
  const [bodyContent, setBodyContent] = useState<string>('');
  const [slug, setSlug] = useState('');

  // --- Refs for managing side effects ---
  const editorRef = useRef<{ getMarkdown: () => string } | null>(null);
  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // --- Memoized Derived State ---
  const isNewFileMode = useMemo(() => slugSegments.includes(NEW_FILE_SLUG_MARKER), [slugSegments]);
  const currentFilePath = useMemo(() => {
    if (isNewFileMode) {
      const parentSlug = slugSegments.slice(0, slugSegments.indexOf(NEW_FILE_SLUG_MARKER)).join('/');
      return parentSlug ? `content/${parentSlug}` : 'content';
    }
    return `content/${(slugSegments.length > 0 ? slugSegments.join('/') : 'index')}.md`;
  }, [slugSegments, isNewFileMode]);

  // --- Core Actions ---

  const onContentModified = useCallback(() => {
    setHasUnsavedChanges(true);
  }, [setHasUnsavedChanges]);

  const handleFrontmatterChange = useCallback((update: Partial<MarkdownFrontmatter>) => {
    setFrontmatter(prev => {
        if (!prev) return null;
        const newFm = { ...prev, ...update };
        if (isNewFileMode && update.title !== undefined) {
            setSlug(slugify(update.title));
        }
        return newFm;
    });
    onContentModified();
  }, [isNewFileMode, onContentModified]);

   const handleViewModeToggle = useCallback((isView: boolean) => {
        setFrontmatter(prev => {
            if (!prev) return null;
            if (isView) {
                // Return a new state with a default view object added
                return {
                    ...prev,
                    view: {
                        template: 'list',
                        item_layout: 'post-card',
                        sort_by: 'date',
                        sort_order: 'desc',
                    }
                };
            } else {
                // Return a new state with the view object removed
                const { view, ...rest } = prev;
                return rest;
            }
        });
        onContentModified();
    }, [onContentModified]); 

  const handleSave = useCallback(async () => {
    if (autoSaveTimeoutRef.current) clearTimeout(autoSaveTimeoutRef.current);
    
    const markdownBody = editorRef.current?.getMarkdown() ?? bodyContent;
    if (!frontmatter || !siteId) throw new Error("Editor not ready.");
    if (!frontmatter.title.trim()) throw new Error("A title is required.");

    const finalPath = isNewFileMode ? `${currentFilePath}/${slug.trim()}.md`.replace('//', '/') : currentFilePath;
    const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);
    
    await addOrUpdateContentFile(siteId, finalPath, rawMarkdown, frontmatter.layout);

    if (isNewFileMode) {
      const newEditPath = finalPath.replace(/^content\//, '').replace(/\.md$/, '');
      router.replace(`/sites/${siteId}/edit/content/${newEditPath}`);
    }
  }, [frontmatter, bodyContent, siteId, isNewFileMode, currentFilePath, slug, addOrUpdateContentFile, router]);

  

  const handleDelete = useCallback(async () => {
      if(isNewFileMode) return;
      try {
        await deleteContentFileAndState(siteId, currentFilePath);
        toast.success(`Page "${frontmatter?.title}" deleted.`);
        router.push(`/sites/${siteId}/edit`);
      } catch (error) { toast.error(`Failed to delete page: ${(error as Error).message}`); }
  }, [isNewFileMode, currentFilePath, siteId, frontmatter, deleteContentFileAndState, router]);

const actions = useMemo(() => ({
    onContentModified,
    handleFrontmatterChange,
    handleDelete,
    handleViewModeToggle,
    setSlug
  }), [
    onContentModified, 
    handleFrontmatterChange, 
    handleDelete, 
    handleViewModeToggle,
    setSlug
  ]);
  // --- Side Effects ---

  // Main data loading effect
  useEffect(() => {
    const loadData = async () => {
      if (!site?.contentFiles) {
        setStatus('loading');
        return;
      }

      if (isNewFileMode) {
        setFrontmatter({
          title: '',
          layout: DEFAULT_PAGE_LAYOUT_PATH,
          date: new Date().toISOString().split('T')[0],
          status: 'draft'
        });
        setBodyContent('# Start Writing...');
        setSlug('');
      } else {
        const rawContent = await localSiteFs.getContentFileRaw(siteId, currentFilePath);
        if (rawContent === null) {
          setStatus('not_found');
          toast.error(`Content not found for this URL.`);
          router.push(`/sites/${siteId}/edit`);
          return;
        }
        const { frontmatter: fm, content } = parseMarkdownString(rawContent);
        setFrontmatter(fm);
        setBodyContent(content);
        setSlug(currentFilePath.split('/').pop()?.replace('.md', '') || '');
      }
      setStatus('ready');
      setHasUnsavedChanges(false);
    };
    loadData();
  }, [site?.contentFiles, currentFilePath, isNewFileMode, siteId, router, setHasUnsavedChanges]);

  // Register the save action with the global editor context
  useEffect(() => {
    registerSaveAction(handleSave);
  }, [handleSave, registerSaveAction]);

  // Return the public API of the hook
  return {
    status,
    site,
    isNewFileMode,
    frontmatter,
    bodyContent,
    currentFilePath,
    slug,
    editorRef,
    actions,
    
  };
}

================================================================================

File: components/publishing/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { Label } from '@/core/components/ui/label';

interface MarkdownEditorProps {
  initialValue: string;
  // onContentChange is now used primarily by the parent to trigger its own state updates
  onContentChange: (markdown: string) => void;
}

// The ref now needs to expose a method to get the current content
export interface MarkdownEditorRef {
  getMarkdown: () => string;
}

const MarkdownEditor = forwardRef<MarkdownEditorRef, MarkdownEditorProps>(
  ({ initialValue, onContentChange }, ref) => {
    // We'll manage the textarea's value with local state
    const [content, setContent] = useState(initialValue);

    // If the initialValue prop changes from the parent (e.g., loading a new file),
    // we update the local state.
    useEffect(() => {
      setContent(initialValue);
    }, [initialValue]);

    // Expose a function for the parent component to get the current content
    useImperativeHandle(ref, () => ({
      getMarkdown: () => {
        return content;
      },
    }));

    // This handler updates both local state and informs the parent of a change
    const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
      const newContent = event.target.value;
      setContent(newContent);
      onContentChange(newContent); // Let the parent know things have changed
    };

    return (
      <div className="space-y-2 h-full">
      <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400">
            Content
          </Label>
      <textarea
        id="content-body"
        value={content}
        onChange={handleChange}
        placeholder="Start writing your Markdown here..."
        className="w-full h-full bg-background 
                   text-base font-mono leading-relaxed resize-none 
                   focus:ring-2 focus:ring-ring focus:outline-none"
      />
      </div>
    );
  }
);

MarkdownEditor.displayName = 'MarkdownEditor';
export default MarkdownEditor;

================================================================================

File: components/publishing/LeftSidebar.tsx
// src/components/publishing/LeftSidebar.tsx
'use client';

import { useParams, usePathname } from 'next/navigation';
import { useMemo, useCallback, useEffect, useState } from 'react';

import { useAppStore } from '@/core/state/useAppStore';
import { useUIStore } from '@/core/state/uiStore';
import { Button } from '@/core/components/ui/button';
import FileTree from '@/features/editor/components/FileTree';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
import CollectionList from '@/features/editor/components/CollectionList';
import NewViewDialog from '@/features/editor/components/NewViewDialog';

import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/core/components/ui/accordion";
import type { StructureNode } from '@/types';
import { cn } from '@/lib/utils';
import { Home, FilePlus, Newspaper } from 'lucide-react';
import { DndContext, DragEndEvent, useDroppable } from '@dnd-kit/core';
import { Link } from '@/core/components/ui/link';


export default function LeftSidebar() {
  const params = useParams();
  const pathname = usePathname();
  const siteId = params.siteId as string;

  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const toggleLeftSidebar = useUIStore((state) => state.sidebar.toggleLeftSidebar);
  const isDesktop = useUIStore((state) => state.screen.isDesktop);
  
  const site = useAppStore((state) => state.getSiteById(siteId));
  const { updateManifest, moveNode } = useAppStore.getState();
  
  const pageStructure = useMemo(() => {
    // Only show top-level pages in the main file tree. Nested pages are handled by the FileTree component itself.
    return site?.manifest.structure.filter((node: StructureNode) => node.type === 'page' && !node.path.includes('/', 'content/'.length)) || [];
  }, [site?.manifest.structure]);

  const [activePath, setActivePath] = useState<string | undefined>();
  useEffect(() => {
    if (!site?.contentFiles) return;

    let currentPath = '';

    if (pathname.includes('/edit/content/')) {
        const contentSlug = pathname.substring(pathname.indexOf('/edit/content/') + 14).replace(/\/$/, '') || 'index';
        currentPath = `content/${contentSlug}.md`;
    } else if (pathname.includes('/edit/collection/')) {
        const collectionSlug = pathname.substring(pathname.indexOf('/edit/collection/') + 17).replace(/\/$/, '');
        currentPath = `content/${collectionSlug}`;
    }
    setActivePath(currentPath);
  }, [pathname, site?.contentFiles]);

  const handleStructureChange = useCallback((reorderedPages: StructureNode[]) => {
      if (!site) return;
      const collections = site.manifest.structure.filter(n => n.type === 'collection');
      const newManifest = { ...site.manifest, structure: [...reorderedPages, ...collections] };
      updateManifest(siteId, newManifest);
  }, [site, siteId, updateManifest]);
  
  const handleDragEndInSidebar = (event: DragEndEvent) => {
    const { over, active } = event;
    if (over && over.id === '__sidebar_root_droppable__') {
      const draggedNodePath = active.id as string;
      moveNode(siteId, draggedNodePath, null);
    }
  };

  const onCreationComplete = () => {
    if (!isDesktop) toggleLeftSidebar();
  };

  const { setNodeRef: setRootDroppableRef, isOver } = useDroppable({
    id: '__sidebar_root_droppable__',
  });

  const unnestDropZoneStyle = isOver ? 'bg-blue-50 dark:bg-blue-900/30 ring-2 ring-blue-500 ring-inset' : '';

  if (!site) return null;

  return (
    <>
      {!isDesktop && (
        <div
          onClick={toggleLeftSidebar}
          className={cn('fixed inset-0 z-40 bg-black/60 transition-opacity', isLeftOpen ? 'opacity-100' : 'pointer-events-none opacity-0')}
        />
      )}
      
      <DndContext onDragEnd={handleDragEndInSidebar}>
        <div className="flex h-full flex-col">
          <Accordion type="multiple" defaultValue={['pages', 'collections']} className="w-full flex-grow flex flex-col">
            
            <AccordionItem value="pages" className="border-b-0">
              <div className="flex px-3 py-1 items-center justify-between">
                  <AccordionTrigger className="text-xs font-semibold uppercase tracking-wider text-muted-foreground border-b-0 p-0 hover:no-underline">
                    Pages
                  </AccordionTrigger>
                  <div className="flex items-center gap-1">
                      <NewViewDialog siteId={siteId} onComplete={onCreationComplete}>
                          <Button variant="ghost" className='size-6 p-1 rounded-sm' title="New View Page">
                              <Newspaper className="h-4 w-4" />
                          </Button>
                      </NewViewDialog>
                      <NewPageDialog siteId={siteId} onComplete={onCreationComplete}>
                          <Button variant="ghost" className='size-6 p-1 rounded-sm' title="New Content Page">
                              <FilePlus className="h-4 w-4" />
                          </Button>
                      </NewPageDialog>
                  </div>
              </div>
              <AccordionContent ref={setRootDroppableRef} className={cn("px-2 py-2 transition-colors", unnestDropZoneStyle)}>
                {pageStructure.length > 0 ? (
                  <FileTree 
                      nodes={pageStructure} 
                      baseEditPath={`/sites/${siteId}/edit`}
                      activePath={activePath}
                      onStructureChange={handleStructureChange}
                  />
                ) : (
                  <div className="px-2 py-4 text-xs text-center text-muted-foreground italic">
                    <p>No pages created yet.</p>
                    <p className="mt-2">Drag a nested page here to make it top-level.</p>
                  </div>
                )}
              </AccordionContent>
            </AccordionItem>
            
            <AccordionItem value="collections" className="border-t flex-grow flex flex-col min-h-0">
              <AccordionContent className="flex-grow min-h-0 py-0">
                  <CollectionList siteId={siteId} />
              </AccordionContent>
            </AccordionItem>
          </Accordion>

          <div className="mt-auto shrink-0 border-t p-2">
              <Button variant="ghost" asChild className="w-full justify-start gap-2">
                  <Link href="/sites">
                      <Home className="h-4 w-4" /> App Dashboard
                  </Link>
              </Button>
          </div>
        </div>
      </DndContext>
    </>
  );
}

================================================================================

File: components/publishing/SchemaDrivenForm.tsx
'use client';

import Form from '@rjsf/shadcn';
import validator from '@rjsf/validator-ajv8';
import { RJSFSchema, UiSchema, FieldTemplateProps, ObjectFieldTemplateProps, RegistryWidgetsType } from '@rjsf/utils';
import { Label } from '@/core/components/ui/label';


// --- Props Definition ---
interface SchemaDrivenFormProps {
  /** The JSON Schema object that defines the form fields, types, and validation. */
  schema: RJSFSchema;
  /** The UI Schema object for customizing widget types and field appearances. */
  uiSchema?: UiSchema;
  /** The current data/state of the form. */
  formData: object;
  /** Callback function that is triggered every time the form data changes. */
  onFormChange: (data: object) => void;
  /** Set to true to enable live validation as the user types. Defaults to false. */
  liveValidate?: boolean;
  // --- FIX: Use the specific RegistryWidgetsType for the widgets prop ---
  /** An object mapping widget names to custom React components. */
  widgets?: RegistryWidgetsType;
  /** An object that will be passed down to all custom widgets and templates. */
  formContext?: any;
}



// --- Custom Field Template (for better layout and labels) ---
function CustomFieldTemplate(props: FieldTemplateProps) {
  const { id, classNames, label, help, required, description, errors, children, schema } = props;

  if (props.hidden) {
    return <div className="hidden">{children}</div>;
  }
  
  const isCheckbox = schema.type === 'boolean' && (props.uiSchema?.['ui:widget'] === 'checkbox' || props.uiSchema?.['ui:widget'] === undefined);

  if (isCheckbox) {
      return <div className={classNames}>{children}</div>
  }

  return (
    <div className={classNames}>
      {label && (
        <Label htmlFor={id} className="block text-sm font-medium mb-1">
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}
      
      {description}
      
      {children}
      
      {errors}
      
      {help}
    </div>
  );
}

// --- Custom Object Field Template (for overall form layout) ---
function CustomObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  return (
    <div>
        {props.description && <p className="text-sm text-muted-foreground">{props.description}</p>}
        <div className="mt-4">
            {props.properties.map(element => (
                <div key={element.name} className="mb-4">
                    {element.content}
                </div>
            ))}
        </div>
    </div>
  );
}

// --- Custom Submit Button Template (to hide it) ---
// FIXED: The 'props' parameter was defined but never used, so it has been removed.
function HideSubmitButton() {
    return null;
}

/**
 * A reusable component that dynamically generates a form from a given JSON Schema.
 * It uses react-jsonschema-form with a shadcn/ui theme for a consistent look and feel.
 */
export default function SchemaDrivenForm({ 
  schema, 
  uiSchema, 
  formData, 
  onFormChange, 
  liveValidate = false,
  widgets, // Destructure the correctly typed prop
  formContext // Destructure the formContext prop
}: SchemaDrivenFormProps) {

  const safeFormData = formData || {};

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={safeFormData}
      validator={validator}
      onChange={(e) => onFormChange(e.formData)}
      liveValidate={liveValidate}
      showErrorList={false}
      widgets={widgets}
      formContext={formContext}
      
      templates={{
        FieldTemplate: CustomFieldTemplate,
        ObjectFieldTemplate: CustomObjectFieldTemplate,
        ButtonTemplates: {
            SubmitButton: HideSubmitButton,
        }
      }}
    />
  );
}

================================================================================

File: components/publishing/GroupedFrontmatterFields.tsx
// src/components/publishing/GroupedFrontmatterFields.tsx
'use client';

import { useMemo } from 'react';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import SchemaDrivenForm from './SchemaDrivenForm';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/core/components/ui/accordion";

interface Group {
  title: string;
  fields: string[];
}
type StrictUiSchema = UiSchema & { 'ui:groups'?: Group[] };

interface GroupedFrontmatterFormProps {
  schema: RJSFSchema;
  uiSchema?: StrictUiSchema;
  formData: Record<string, unknown>;
  onFormChange: (newData: Record<string, unknown>) => void;
}

function createSubSchema(originalSchema: RJSFSchema, fields: string[]): RJSFSchema {
  const subSchema: RJSFSchema = { ...originalSchema, properties: {}, required: originalSchema.required?.filter(field => fields.includes(field)) };
  if (!subSchema.properties) subSchema.properties = {};
  for (const field of fields) {
    if (originalSchema.properties && originalSchema.properties[field]) {
      subSchema.properties[field] = originalSchema.properties[field];
    }
  }
  return subSchema;
}

export default function GroupedFrontmatterForm({
  schema,
  uiSchema,
  formData,
  onFormChange,
}: GroupedFrontmatterFormProps) {
  
  const { groups, ungroupedFields } = useMemo(() => {
    const definedGroups = uiSchema?.['ui:groups'] || [];
    const allSchemaFields = Object.keys(schema.properties || {});
    const fieldsInGroups = new Set(definedGroups.flatMap(g => g.fields));
    const remainingFields = allSchemaFields.filter(f => !fieldsInGroups.has(f));
    return { groups: definedGroups, ungroupedFields: remainingFields };
  }, [schema, uiSchema]);

  // FIXED: The handler now accepts the event from rjsf and extracts the formData.
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onFormChange(event.formData || {});
  };

  if (!schema.properties || Object.keys(schema.properties).length === 0) {
    return <p className="text-sm text-muted-foreground">This layout has no configurable fields.</p>;
  }

  return (
    <div className="border-t">
      <Accordion type="multiple" defaultValue={groups.map(g => g.title)} className="w-full">
        {groups.map((group) => {
          if (group.fields.length === 0) return null;
          return (
            <AccordionItem value={group.title} key={group.title}>
              <AccordionTrigger>{group.title}</AccordionTrigger>
              <AccordionContent className="pt-4">
                <SchemaDrivenForm
                  schema={createSubSchema(schema, group.fields)}
                  formData={formData}
                  onFormChange={handleChange}
                />
              </AccordionContent>
            </AccordionItem>
          );
        })}
      </Accordion>

      {ungroupedFields.length > 0 && (
        <div className="">
            <Accordion type='single' collapsible>

<AccordionItem value="item-1">                <AccordionTrigger>
                  Fields
                </AccordionTrigger>
                <AccordionContent>
<SchemaDrivenForm
            schema={createSubSchema(schema, ungroupedFields)}
            formData={formData}
            onFormChange={handleChange}
          />
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </div>
      )}
    </div>
  );
}

================================================================================

File: components/layout/ThreeColumnLayout.tsx
'use client';

import { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/lib/utils';
import EditorHeader from '@/features/editor/components/EditorHeader';

interface ThreeColumnLayoutProps {
  leftSidebar: ReactNode;
  rightSidebar: ReactNode;
  children: ReactNode;
}

export default function ThreeColumnLayout({ leftSidebar, rightSidebar, children }: ThreeColumnLayoutProps) {
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const isRightOpen = useUIStore((state) => state.sidebar.isRightOpen);

  return (
    <div className="flex h-screen w-full flex-col bg-muted/20">
      <EditorHeader />
      
      {/* This is now the positioning context for all three columns */}
      <div className="relative flex-1 overflow-hidden">
        
        {/* --- START OF FIX --- */}
        
        {/* Left Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 left-0 z-20 h-full w-72 border-r bg-background transition-transform duration-300 ease-in-out',
            isLeftOpen ? 'translate-x-0' : '-translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {leftSidebar}
          </div>
        </aside>

        {/* Main Content: The layout is now controlled by padding */}
        <main
          className={cn(
            'h-full overflow-y-auto transition-all duration-300 ease-in-out',
            // When left sidebar is open, add left padding
            isLeftOpen ? 'lg:pl-72' : 'lg:pl-0',
            // When right sidebar is open, add right padding
            isRightOpen ? 'lg:pr-80' : 'lg:pr-0'
          )}
        >
          {children}
        </main>

        {/* Right Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 right-0 z-10 h-full w-80 border-l bg-background transition-transform duration-300 ease-in-out',
            isRightOpen ? 'translate-x-0' : 'translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {rightSidebar}
          </div>
        </aside>

        {/* --- END OF FIX --- */}
      </div>
    </div>
  );
}

================================================================================

File: lib/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { Input } from 'gray-matter'; // Import GrayMatterOption and Input
//import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { MarkdownFrontmatter, ParsedMarkdownFile } from '@/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Signum focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: lib/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: lib/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: lib/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { LocalSiteData, ParsedMarkdownFile, Manifest } from '@/types';
import { parseMarkdownString } from './markdownParser';
import { flattenStructureToPages } from '../core/services/fileTree.service';

async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const url = new URL(filePath, baseUrl).href;
  const response = await fetch(url, { cache: 'no-store' });
  if (!response.ok) {
    throw new Error(`Fetch failed for ${url}: ${response.statusText}`);
  }
  return response.text();
}

/**
 * Fetches and reconstructs an entire remote Signum site into the LocalSiteData format.
 * It fetches the manifest, then fetches all content files listed within it.
 * @param remoteSiteUrl The base URL of the remote Signum site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json, which is now the single source of truth.
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_signum/manifest.json');
    const manifest: Manifest = JSON.parse(manifestString);

    if (!manifest || !manifest.siteId || !manifest.structure) {
        throw new Error("Invalid manifest structure fetched from remote site.");
    }
    
    // 2. Collect all unique file paths from the manifest structure.
    const allPageNodes = flattenStructureToPages(manifest.structure);
    const contentFilePaths = [...new Set(allPageNodes.map(node => node.path))];

    // 3. Fetch all content files in parallel.
    const contentFilesPromises = contentFilePaths.map(async (path) => {
        try {
            const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, `_signum/${path}`);
            const { frontmatter, content } = parseMarkdownString(rawMarkdown);
            const slug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
            return { slug, path, frontmatter, content };
        } catch (error) {
            console.warn(`Could not fetch or parse content file: ${path}`, error);
            return null; // Return null on failure for this specific file
        }
    });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];

    // 4. Construct the final LocalSiteData object.
    const finalSiteData: LocalSiteData = {
      siteId: `remote-${manifest.siteId}`, // Prefix to distinguish in local state
      manifest: manifest,
      contentFiles: validContentFiles,
    };

    return finalSiteData;

  } catch (error) {
    console.error(`CRITICAL ERROR fetching remote site data for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

